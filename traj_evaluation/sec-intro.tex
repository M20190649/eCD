%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\vspace{-0.5ex}
\section{Introduction}
\label{sec-into}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{table*}
	\renewcommand{\arraystretch}{1.20}
	\caption{\small Summary of piece-wise line based algorithms for trajectory simplification}
	\label{tab:summary-lsa}
	\centering
	\small
	\begin{tabular}{|l|c|c|c|c|c|c|c|}
		\hline
		\kw{Name}  & \kw{Type}    & \kw{Key~Ideas}  &\kw{\ped} &\kw{\sed}  &  \kw{Time~Complexity} & \kw{Space~Complexity} \\		\hline
		\dpa\cite{Douglas:Peucker, Meratnia:Spatiotemporal}	&batch &Top-down     &Y &Y    & $O(n^2)$ & O(n)  \\		\hline
		\tpa\cite{Pavlidis:Segment}	&batch	&Bottom-up       &Y &Y   & $O(n^2/K)$ & O(n)  \\		\hline
		\bqsa\cite{Liu:BQS}	&online	&Top-down and Convex hull    &Y   & N& $O(n^2)$  & $O(|Q|)$   \\		\hline
		\squishe\cite{Muckell:SQUISH}	&{online}	& Bottom-up and Priority queue       & N &Y    & $O(n\log|Q|)$ & $O(|Q|)$ \\		\hline
		%swab	&   &online   &Y &Y  & $\Omega(n)$ & $O(n^2)$ & O(w) &\textcolor[rgb]{1.00,0.00,0.00}{} \\		\hline
		%owtd	&   &online    &Y &Y   & $\Omega(n)$ & $O(n^2)$ & O(n) &\textcolor[rgb]{1.00,0.00,0.00}{} \\ 	\hline
		%ddr	    &       &one-pass    &Y  &Y  & $\Omega(n)$ & $O(n)$ & O(n) &\textcolor[rgb]{1.00,0.00,0.00}{} \\  \hline
		\operb\cite{Lin:Operb}	& one-pass	& Fitting function    &Y & N  & $O(n)$ & O(1)  \\		\hline
		\siped\cite{Dunham:Cone, Zhao:Sleeve}	&one-pass	& Sector intersection   &Y & N & $O(n)$ & O(1) \\		\hline
		\cised\cite{Lin:Cised}	&one-pass	& Spatio-temporal cone intersection    	&N & Y & $O(n)$ & O(1) \\		\hline
		%\opt~\cite{Imai:Optimal}	&optimal	& Graph    							&Y & Y & $O(n^3)$	& {$O(n^2)$} \\		\hline
		\optp\cite{Chan:Optimal}	&optimal	& Graph and Sector intersection    	&Y & N & $O(n^2)$	& {$O(n)$} \\		\hline
		\nopts~	&near optimal&Graph and Spatio-temporal cone intersection&N & Y  & $O(n^2)$	& $O(n)$ \\		\hline
	\end{tabular}
	{\\  Note: $K$ is the number of the final segments of a trajectory and $|Q|$ is the size of buffer/window.}
	\vspace{-2ex}
\end{table*}


Various mobile devices, such as smart-phones, on-board diagnostics, personal navigation devices, and wearable smart devices, have been using their GPS sensors to collect massive trajectory data of moving objects at a certain sampling rate, and transmit it to cloud servers for location based services, trajectory mining and many other applications.
\textcolor{blue}{Apart from the widely using of GPS sensors, the sampling rate is also increasing, \eg from 1 point per minute to currently 1 point per second, in order to get more accurate position information of a moving object, which leads to mobile devices collecting, transmitting and storing an increasing size of trajectory data.}
%
It is known that transmitting and storing raw trajectory data consumes too much network bandwidth and storage capacity \cite{Chen:Trajectory,  Chen:Fast, Meratnia:Spatiotemporal, Keogh:online, Liu:BQS, Muckell:Compression,Cao:Spatio, Popa:Spatio, Schmid:Semantic,Richter:Semantic,Long:Direction,Nibali:Trajic}.
Further, we find that the online transmitting of raw trajectories also seriously aggravates several other issues such as out-of-order and duplicate data points in our experiences when implementing an online vehicle-to-cloud data transmission system.
Fortunately, these issues can be resolved or greatly alleviated by the trajectory compression techniques \cite{Douglas:Peucker, Hershberger:Speeding, Meratnia:Spatiotemporal, Liu:BQS, Muckell:Compression, Chen:Trajectory, Chen:Fast, Keogh:online, Cao:Spatio, Shi:Survey, Richter:Semantic ,Long:Direction, Song:PRESS, Nibali:Trajic}.

Trajectory Compression techniques may be lossless or lossy \cite{Muckell:Compression}.
%
Lossless compression methods enable exact reconstruction of the original data from the compressed data without information loss. For example, delta compression \cite{Nibali:Trajic} is a lossless compression technique for trajectory data, which has zero error.
The limitation of lossless compression lies in that its compression ratio is relatively poor \cite{Nibali:Trajic} and {queries on the compressed data are time consuming because data reconstructions from the compressed data are needed before the queries}.
%
In contrast, lossy compression methods typically identify important data points and remove statistical redundant data points from the original data, and allow errors or derivations compared with the original trajectory data. 
These techniques focus on good compression ratios with acceptable errors, and are the mainstream techniques for trajectory compression.
%, or replace original data points in a trajectory with other places of interests, such as roads and shops.

A large number of lossy trajectory compression techniques, most notably the piece-wise line simplification \cite{Douglas:Peucker, Hershberger:Speeding, Keogh:online,Liu:BQS, Muckell:Compression, Chen:Trajectory, Chen:Fast, Cao:Spatio, Shi:Survey}, have been developed. The idea of piece-wise line simplification (\lsa) comes from computational geometry, whose target is to approximate a given finer piece-wise linear curve by another coarser piece-wise linear curve ({normally} a sub set of the former), such that the maximum distance of the former from the later is bounded by a user specified constant. It is widely used due to its distinct advantages: (a) simple and easy to implement, (b) no need of extra knowledge and suitable for freely  moving  objects \cite{Popa:Spatio}, and (c) bounded errors with good compression ratios.

%This work focus on the piece-wise line simplification (\lsa) methods of trajectory compression, more specially, the \emph{min-$\#$ problem} \cite{Chan:Optimal, Imai:Optimal,Pavlidis:Segment} of the piece-wise line based trajectory simplification.
%In trajectory compression, the \lsa algorithms commonly use two distance metrics, \ie the \emph{perpendicular Euclidean distances} (\ped) and the \emph{synchronous Euclidean distances} (\sed).
%Originally, \lsa algorithms adopt \ped as a distance metric.
%\eg $|\vv{P_4P^*_4}|$ is the \ped of data point $P_4$ to line segment $\vv{P_0P_{10}}$ in Figure~\ref{fig:notations} (left).
%\lsa algorithms using \ped have good compression ratios~ \cite{Douglas:Peucker, Hershberger:Speeding, Liu:BQS, Muckell:Compression, Chen:Trajectory, Cao:Spatio, Shi:Survey}. However, when using \ped, the temporal information is lost. 
%Thus, a spatio-temporal query, \eg ``\emph{the position of a moving object at time $t$}", on the compressed trajectories by line simplification algorithms using \ped may return an approximate point $P'$ whose distance to the actual position $P$ of the moving object at time $t$ is unbounded. 
%For example, a query for the position of $P_7$ at time $t_7$ may return an approximate data point $P'_7$ whose distance to $P_7$ is great than the  bound $\epsilon$ in Figure~\ref{fig:notations} (left).
%
The \lsa algorithms for trajectory compression commonly use two distance metrics, namely, the \emph{perpendicular Euclidean distances} (\ped) and the \emph{synchronous Euclidean distances} (\sed).
Originally, \lsa algorithms adopt \ped as a distance metric.
The using \ped bring good compression ratios~ \cite{Douglas:Peucker, Hershberger:Speeding, Liu:BQS, Muckell:Compression, Chen:Trajectory, Cao:Spatio, Shi:Survey}, nevertheless, the temporal information is lost. 
%
\sed was then introduced for trajectory compression to save temporal information \cite{Meratnia:Spatiotemporal}. \sed is the Euclidean distance of a data point to its \emph{approximate temporally synchronized data point} \cite{Meratnia:Spatiotemporal} on the corresponding line segment. 
%For instance, $P'_4$ and $P'_7$ are the \emph{synchronized data points} of points $P_4$ and $P_7$ \wrt line segments $\vv{P_0P_{10}}$ and $\vv{P_4P_{10}}$, respectively, in Figure~\ref{fig:notations} (right).
\lsa algorithms using \sed may produce more line segments. However, the use of \sed ensures that the Euclidean distance between a data point and its synchronized point \wrt the corresponding line segment is bounded. 
%Hence, the above spatio-temporal query over the trajectories compressed by \sed enabled approaches returns the synchronized point $P'$ of a data point $P$ within a bounded distance.

Moreover, the \lsa algorithms fall into two categories, \ie the \textit{optimal} and \textit{sub-optimal} algorithms. 
The \textit{optimal} methods\cite{Imai:Optimal,Chan:Optimal} are to find the minimal number of points or segments to represent the original polygonal lines \wrt an error bound $\epsilon$.
%An optimal $O(n^3)$ \lsa algorithm using \ped was firstly developed in \cite{Imai:Optimal},  where $n$ is the number of the original points.
%Later, an improved optimal  $O(n^2)$  algorithm using \ped was designed in \cite{Chan:Optimal}, with the help of {sector intersection} mechanism.
%However, the time complexity of the optimal \lsa algorithm using \sed remains in $O(n^3)$, as the optimization mechanisms are \ped specific, and cannot work with \sed.
%	The high time complexities of the optimal \lsa algorithms using \sed make them impractical.
%
%Due to the high time complexities of optimal \lsa algorithms, 
The optimal \lsa algorithms have relative high time/space complexities which make them impractical for large trajectory data.
Hence, \textit{sub-optimal} \lsa algorithms have been developed and/or introduced for trajectory compression, including batch algorithms (\eg Douglas-Peucker \cite{Douglas:Peucker, Meratnia:Spatiotemporal} and Theo~Pavlidis \cite{Pavlidis:Segment}), online algorithms (\eg~\bqsa\cite{Liu:BQS} \squishe \cite{Muckell:Compression}) and most recent, one-pass algorithms (\eg~our preview works \operb \cite{Lin:Operb} and \cised \cite{Lin:Cised}). The online algorithms and one-pass algorithms are claimed more efficient, by using some optimization strategies, such as convex hull in \bqsa~\cite{Liu:BQS}, priority queue in \squishe \cite{Muckell:Compression}, {fitting function} in \operb \cite {Lin:Operb} and spatio-temporal cone intersection in \cised \cite {Lin:Cised}. Note some sub-optimal algorithms, \eg ~\bqsa and \operb, are \ped specific while others, \eg~\squishe and \cised, are \sed specific, depending on the optimization techniques they applied.

\stitle{Motivations}. The motivations of this work are four folds.
%\begin{enumerate}

\ni (1) Two distance metrics, \ie the \ped for spatial compression and the \sed \cite{Meratnia:Spatiotemporal} for spatio-temporal compression, which is supported in those algorithms, and what impacts they are on performance, have not been compared systematically under the same experimental platform. 

\ni (2) The effectiveness and the room for improvement of sub optimal \lsa algorithms compared with the optimal \lsa algorithms on trajectory data are not comprehensively studied.

\ni (3) The ``sector intersection" algorithms \cite{Williams:Longest, Sklansky:Cone, Dunham:Cone, Zhao:Sleeve} developed in fields of graphic, cartographic and pattern recognition, which run fast as well as have good performance, are still not introduced to the field of trajectory compression.

\ni (4) The recent important progresses in the trajectory simplification, \ie online algorithms \squishe~\cite{Muckell:Compression} using \sed, \bqsa~\cite{Liu:BQS} using \ped, and one-pass algorithms \operb~\cite{Lin:Operb} using \ped and \cised~\cite{Lin:Cised} using \sed, are not systematically evaluated for trajectory data. 

%\end{enumerate}

As a consequence, it is difficult for a practitioner to decide which algorithm and distance metric should be adopted for a specific application. 
Thus, these issues call for a more comprehensive evaluation of the existing \lsa techniques on trajectory data.

\stitle{Contributions}.
This paper presents an experimental comparison of the state-of-the-art \lsa algorithms for trajectory compression, including \emph{both the optimal and the sub-optimal methods that use either \ped or \sed}. 
The algorithms reviewed and evaluated in our experiments are summarized in \mytable{tab:summary-lsa}, namely,
(i) Douglas-Peucker\cite{Douglas:Peucker,Meratnia:Spatiotemporal} and \pavlidis~\cite{Pavlidis:Segment}, two distinct batch \lsa algorithms,
(ii) \bqsa\cite{Liu:BQS} and \squishe~\cite{Muckell:SQUISH}, two famous online \lsa algorithms,
(iii) \operb\cite{Lin:Operb}, sector intersection \cite{Williams:Longest,Sklansky:Cone,Dunham:Cone, Zhao:Sleeve} and \cised \cite{Lin:Cised}, three one-pass \lsa algorithms, and
(iv) \opt\cite{Chan:Optimal} and \nopts, an optimal and a near optimal \lsa algorithms using \ped and \sed, respectively.
%
%
Using a variety of real trajectory datasets, we evaluated the performance of each technique in terms of its processing time, compression ratio and average error.
%with up to \textcolor{red}{$2.5$} billion data points
Our experimental results reveal the characteristics of different techniques, based on which we provide guidelines on selecting appropriate methods and distance metrics for various scenarios.


\eat{
\stitle{Roadmap}.
The remainder of the paper is organized as follows.
Section 2 introduces notations used in the paper and states the problem of trajectory simplification,
Section 3 and Section 4 review the sub-optimal and optimal \lsa methods,
Section 5 reports the experimental results, and
Section 6 concludes this paper.
The appendix covers additional related work.% and experimental results.
}


