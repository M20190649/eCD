
\textcolor{blue}{\section{Aging of trajectories}}

In this section, we discuss the data aging problem of \lsa algorithms and distance metrics.
%
Suppose we first compressed a trajectory $\dddot{\mathcal{T}_0}$ using an \lsa algorithm $\mathcal{A}$ with error bound $\epsilon_1$ to $\overline{\mathcal{T}}_1$, then we need a coarser trajectory produced from $\overline{\mathcal{T}}_1$  having error bound $\epsilon_1 + \epsilon_2$ corresponding to $\dddot{\mathcal{T}}_0$, can we get that by compressing $\overline{\mathcal{T}}_1$ with error bound $\epsilon_2$?  \emph{Aging friendly \cite{Cao:Spatio}} and \emph{Aging feasible} are concepts to answer this question. Note that \emph{aging friendly} was introduced in \cite{Cao:Spatio} while \emph{aging feasible} is a new concept.

\subsection{Aging Friendly}
	
\stitle{Aging friendly \cite{Cao:Spatio}}. {A \lsa algorithm $\mathcal{A}$ is aging friendly with respect to a distance metric $D$ if for every $\epsilon_1$ and every $\epsilon_2$ such that $\epsilon_1 < \epsilon_2$, and for every trajectory $\dddot{\mathcal{T}}$, $\mathcal{A}(\dddot{\mathcal{T}}, \epsilon_2, D)= \mathcal{A}(\mathcal{A}(\dddot{\mathcal{T}}, \epsilon_1, D), \epsilon_2, D)$.}

	
Authors in \cite{Cao:Spatio} also discussed the aging friendliness of algorithms \opt and \dpa with respect to distance metrics \ped and \sed. It proved that algorithm \dpa is aging friendly \wrt~\ped and \sed, but algorithm \opt is not. 
Though \cite{Cao:Spatio} did not discuss \dad, it is easy to find that algorithm \dpa is aging friendly \wrt~\dad and algorithm \opt is still not. Next we discuss the aging friendliness of other algorithms.


\begin{figure}[tb!]
	\centering
	\includegraphics[scale=0.66]{Figures/Fig-aging-pavlidis.png}

	\caption{\small Counter example of the aging friendliness of algorithm \tpa, where (1) the original trajectory is compressed using $\epsilon_2=6$ to three points $\{P_0, P_3, P_4\}$; (2) the original trajectory is first compressed using $\epsilon_1=3$ to four points $\{P_0, P_1, P_3, P_4\}$, then compressed using $\epsilon_2=6$ to two points $\{P_0, P_4\}$. }
	\vspace{-2ex}
	\label{fig:aging-pavlidis}
\end{figure}


\begin{theorem}
\label{theo-aging-tp}
The \tpa algorithm is not aging friendly \wrt~\ped, \sed or \dad.
\end{theorem}

\begin{proof}
We will prove the theorem by construction.
As shown in Figure~\ref{fig:aging-pavlidis}, we let error bounds $\epsilon_1 =3$ and $\epsilon_2=6$, and without losing generality, we use \ped as the distance metric.
%The proof is easy to be extended to \sed and \dad.

\underline{(1) ${\tpa}(\dddot{\mathcal{T}}, 6, \ped)$}. In the first step, it merges $\overline{P_1P_2}$ and $\overline{P_2P_3}$ to $\overline{P_1P_3}$ as the merging of them has the lowest cost of $2$, the distance from point $P_2$ to line segment $\overline{P_1P_3}$; then it merges $\overline{P_0P_1}$ and $\overline{P_1P_3}$ to $\overline{P_0P_3}$ with the lowest cost of $4.5$, the distance from point $P_1$ to line segment $\overline{P_0P_3}$; at last, because the merging of $\overline{P_0P_3}$ and $\overline{P_3P_4}$ has a cost of $7$, the distance from point $P_2$ to line segment $\overline{P_0P_4}$, which is larger than the error bound of $6$, it outputs three points $\{P_0, P_3, P_4\}$.

\underline{(2) ${\tpa}(\tpa(\dddot{\mathcal{T}}, 3, \ped), 6, \ped)$}. In the first round ($\epsilon_1=3$), the original trajectory is compressed to four points $\{P_0, P_1, P_3, P_4\}$, and in the second round ($\epsilon_1=6$), because all points in the result trajectory $\{P_0, P_1, P_3, P_4\}$ have distances to line segment $P_0P_4$ less than $6$, it is finally compressed to two points $\{P_0, P_4\}$.

In this case, ${\tpa}(\dddot{\mathcal{T}}, 6, \ped) = {\tpa}(\tpa(\dddot{\mathcal{T}}, 3, \ped), 6, \ped)$. Thus, the \tpa algorithm is not aging friendly \wrt~\ped.
\textcolor{red}{Similarly, we can prove the conclusion of \sed and \dad.}
\end{proof}


\eat{
(1) For a trajectory \trajec{T} with one or two points, the simplified result
is sure identical to the original trajectory. Consider a trajectory \trajec{T} = $[P_0, P_1, P_2]$ has three points. 
%
If the distance from $P_1$ to $\overline{P_0P_2}$ is larger than $\epsilon_1$, then
$\mathcal{A}(\dddot{\mathcal{T}}, \epsilon_1, D)=$\trajec{T}, hence, $\mathcal{A}(\mathcal{A}(\dddot{\mathcal{T}}, \epsilon_1, D), \epsilon_2, D)=\mathcal{A}(\dddot{\mathcal{T}}, \epsilon_2, D)$;
%
If the distance from $P_1$ to $\overline{P_0P_2}$ is less than $\epsilon_1$, then
$\mathcal{A}(\dddot{\mathcal{T}}, \epsilon_1, D) = \overline{P_0P_2}$. Obviously $\mathcal{A}(\mathcal{A}(\dddot{\mathcal{T}}, \epsilon_1, D), \epsilon_2, D) =\overline{P_0P_2} = \mathcal{A}(\dddot{\mathcal{T}}, \epsilon_2, D)$.


(2) Assume that the proposition is true for every trajectory \trajec{T} having $n$ points $(n \ge 3)$.
Then we consider a trajectory \trajec{T} with $n+1$ points. 


Let dist denote the maximum
distance between some vertex Pi on T and the straight line P1Pn+1. If
dist < "2, then S(T, "2,M) and S(S(T, "1,M), "2,M)) are the same straight
line segment – P1Pn+1.
On the other hand, if dist > "2 > "1, let Pi be the first vertex that is
farthest from P1Pn+1. Regardless whether the DP algorithm has "1 or "2
as a tolerance, it will split the trajectory T into two segments P1Pi and
PiPn+1, each of which has ≤ n vertices and, consequently, falls into the
inductive hypothesis case.

From (1) and (2) we have the conclusion.
}

\begin{theorem}
	\label{theo-aging-tp}
	The online and one-pass algorithms are not aging friendly \wrt~\ped, \sed or \dad.
	on the number of points of \trajec{T}. 
	%Without losing generality, we use \ped as the distance metric. The proof is easy to be extended to \sed and \dad.
	
\end{theorem}

\begin{proof}
	\todo...all online and one-pass algorithms runs in a incremental manner.
\end{proof}

From the above we can find that only algorithm \dpa is aging friendly, others are not. Indeed, the {aging friendly} is a pretty and rare feature of \lsa algorithms, and it is the result of the specific algorithm nature of the \dpa algorithm.


\subsection{Aging Feasible}
In this section, we define and discuss a widely existing, maybe more practical, feature of \lsa algorithms and distance metrics.

\stitle{Aging feasible}. {A \lsa algorithm $\mathcal{A}$ is aging feasible with respect to a distance metric $D$ if for every $\epsilon_1$ and every $\epsilon_2$, and for every trajectory $\dddot{\mathcal{T}}$, the max error between $\dddot{\mathcal{T}}$ and $\overline{\mathcal{T}}=\mathcal{A}(\mathcal{A}(\dddot{\mathcal{T}}, \epsilon_1, D), \epsilon_2, D)$ is not more than $\epsilon_1+ \epsilon_2$.}


