%\section{Overview of LS algorithms for trajectory compression}	%Trajectory simplification Problem
\section{Overview of algorithms}
\label{sec-problem}

%In this section, we first introduce basic concepts, then state the problem of trajectory simplification.%piece-wise line based




\begin{table*}
	\renewcommand{\arraystretch}{1.20}
	\caption{\small Summary of piece-wise line based algorithms for trajectory simplification}
	\label{tab:summary-lsa}
	\centering
	\small
	\begin{tabular}{|l|c|c|c|c|c|c|c|}
		\hline
		\kw{Name}  & \kw{Type}    & \kw{Key~Ideas}  &\kw{\ped} &\kw{\sed}  &  \kw{Time~Complexity} & \kw{Space~Complexity} \\		\hline
		\dpa\cite{Douglas:Peucker, Meratnia:Spatiotemporal}	&batch &Top-down     &Y &Y    & $O(n^2)$ & O(n)  \\		\hline
		\tpa\cite{Pavlidis:Segment}	&batch	&Bottom-up       &Y &Y   & $O(n^2/K)$ & O(n)  \\		\hline
		\bqsa\cite{Liu:BQS}	&online	&Top-down, opening window and Convex hull    &Y   & N& $O(n^2)$  & $O(|Q|)$   \\		\hline
		\squishe\cite{Muckell:Compression}	&{online}	& Bottom-up and Priority queue       & N &Y    & $O(n\log|Q|)$ & $O(|Q|)$ \\		\hline
		%swab	&   &online   &Y &Y  & $\Omega(n)$ & $O(n^2)$ & O(w) &\textcolor[rgb]{1.00,0.00,0.00}{} \\		\hline
		%owtd	&   &online    &Y &Y   & $\Omega(n)$ & $O(n^2)$ & O(n) &\textcolor[rgb]{1.00,0.00,0.00}{} \\ 	\hline
		%ddr	    &       &one-pass    &Y  &Y  & $\Omega(n)$ & $O(n)$ & O(n) &\textcolor[rgb]{1.00,0.00,0.00}{} \\  \hline
		\operb\cite{Lin:Operb}	& one-pass	& Fitting function    &Y & N  & $O(n)$ & O(1)  \\		\hline
		\siped\cite{Dunham:Cone, Zhao:Sleeve}	&one-pass	& Sector intersection   &Y & N & $O(n)$ & O(1) \\		\hline
		\cised\cite{Lin:Cised}	&one-pass	& Spatio-temporal cone intersection    	&N & Y & $O(n)$ & O(1) \\		\hline
		\opt~\cite{Imai:Optimal}	&optimal	& Graph    							&Y & Y & $O(n^3)$	& {$O(n^2)$} \\		\hline
		\optp\cite{Chan:Optimal}	&optimal	& Graph and Sector intersection    	&Y & N & $O(n^2)$	& {$O(n)$} \\		\hline
		%\nopts~	&near optimal&Graph and Spatio-temporal cone intersection&N & Y  & $O(n^2)$	& $O(n)$ \\		\hline
	\end{tabular}
	{\\  Note: $K$ is the number of the final segments of a trajectory and $|Q|$ is the size of buffer/window.}
	\vspace{-4.5ex}
\end{table*}


\subsection{Problem Definition}
\label{subsec-notation}

%We first introduce basic notations.
A \textit{trajectory} $\dddot{\mathcal{T}}[P_0, \ldots, P_n]$ is a sequence of points in a monotonically increasing order of their associated time values (\ie $P_i.t < P_j.t$ for any $0\le i<j\le n$), where a data \textit{point} is defined as a triple $P(x, y, t)$, which represents that a moving object is located at {\em longitude} $x$ and {\em latitude} $y$ at {\em time} $t$. Note that data points can be viewed as points in a three-dimension Euclidean space.

%Intuitively, a trajectory can also be represented by a continuous $n$-pieces directed line segments (or line segment for simplicity) $\mathcal{L}_i$, $0\le i < n$, where  $\mathcal{L}_i = \vv{P_{i}P_{i+1}}$, represents the closed line segment that connects the start point $P_{i}$ and the end point $P_{i+1}$. 

A \textit{piece-wise line representation} $\overline{\mathcal{T}}[\mathcal{L}_0, \ldots , \mathcal{L}_m]$ ($0< m \le n$) of a trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_n]$ is a sequence of continuous \textit{directed line segments} (or line segment for simplicity) $\mathcal{L}_{i}$ = $\vv{P_{s_i}P_{e_i}}$ ($i\in[0,m]$) of $\dddot{\mathcal{T}}$ such that $\mathcal{L}_{0}.P_{s_0} = P_0$, $\mathcal{L}_{m}.P_{e_m} = P_n$ and  $\mathcal{L}_{i}.P_{e_i}$ = $\mathcal{L}_{i+1}.P_{s_{i+1}}$ for all $i\in[0, m-1]$. 
Note that each directed line segment in $\overline{\mathcal{T}}$ essentially represents a continuous sequence of data points in $\dddot{\mathcal{T}}$.


\eat{
A \textit{directed line segment} (or line segment for simplicity) $\mathcal{L}$ is defined as $\vv{P_{s}P_{e}}$, which represents the closed line segment that connects the start point $P_s$ and the end point $P_e$.
We also use $|\mathcal{L}|$ and $\mathcal{L}.\theta\in [0, 2\pi)$ to denote the length of a directed line segment $\mathcal{L}$, and its angle with the $x$-axis of the coordinate system $(x, y)$, where $x$ and $y$ are the longitude and latitude, respectively.
That is, a directed line segment $\mathcal{L}$ = $\vv{P_{s}P_{e}}$ can be treated as a triple $(P_s, |\mathcal{L}|, \mathcal{L}.\theta)$.
}


Then, given a trajectory \trajec{T}$[P_0, \dots, P_n]$ and a pre-specified constant $\epsilon$, a trajectory simplification algorithm $\mathcal{A}$ approximates the trajectory \trajec{T} by $\overline{\mathcal{T}}[\mathcal{L}_0, \ldots , \mathcal{L}_m]$ ($0< m \le n$), such that  
(1) on each of them the data points $[P_{s_i}, \dots, P_{e_i}]$ are approximated by a line segment $\mathcal{L}_i = \vv{P_{s_i}P_{e_i}}$ with the maximum {error} of point $P_j$ to line segment $\mathcal{L}_i$, $s_i < j<e_i$,  less than $\epsilon$, and
(2) $P_{s_i}$ and $P_{e_i} \in$ \trajec{T}. 
This definition is also an extending of the famous \emph{min-$\#$ problem} \cite{Chan:Optimal, Imai:Optimal,Pavlidis:Segment} of piece-wise line simplification.
%

For trajectory simplification, two error metrics are commonly used, namely, the \emph{perpendicular Euclidean distances} (\ped) and the \emph{synchronous Euclidean distances} (\sed).
%
Given a data point $P$ and a directed line segment $\mathcal{L}$ = $\vv{P_{s}P_{e}}$, the $ped(P, \mathcal{L})$ of point $P$ to line segment $\mathcal{L}$ is $\min\{|PQ|\}$ for any point $Q$ on $\vv{P_{s}P_{e}}$, and the $sed(P, \mathcal{L})$ of $P$ to $\mathcal{L}$ is $|\vv{PP'}|$ that is the Euclidean distance from $P$ to its \textit{synchronized data point} $P'$ \wrt $\mathcal{L}$, where the synchronized data point $P'$ \wrt $\mathcal{L}$ is defined as follows:
(1) $P'.x$ = $P_s.x +  c\cdot(P_e.x - P_s.x)$,
(2) $P'.y$ = $P_s.y +  c\cdot(P_e.y - P_s.y)$ and
(3) $P'.t$ = $P.t$, where $c= \frac{P.t-P_s.t}{P_e.t-P_s.t}$.

We illustrate these notations with examples.


\begin{example}
	\label{exm-notations}
	Consider Figure~\ref{fig:notations}, in which
	%
	(1) $\dddot{\mathcal{T}}[P_0$, $\ldots, P_{10}]$ is a trajectory having 11 data points,
	%
	 (2) the set of two continuous line segments $\{\vv{P_0P_4}$, $\vv{P_4P_{10}}$\} (Left) and the set of four continuous line segments $\{\vv{P_0P_2}$, $\vv{P_2P_4}$, $\vv{P_4P_7}$, $\vv{P_7P_{10}}$\} (Right) are two piecewise line representations of trajectory $\dddot{\mathcal{T}}$,
	%
	(3) $ped(P_4, \vv{P_0P_{10}})=|\vv{P_4P^*_4}|$, where $P^*_4$ is the perpendicular point of $P_4$ \wrt line segment $\vv{P_0P_{10}}$, and
	%
	(4) $sed(P_4, \vv{P_0P_{10}})= |\vv{P_4P'_4}|$, $sed(P_2, \vv{P_0P_{4}})= |\vv{P_2P'_2}|$ and $sed(P_7, \vv{P_4P_{10}})$ $=$ $|\vv{P_7P'_7}|$,
	where points $P'_4$, $P'_2$ and $P'_7$ are the synchronized points of $P_4$, $P_2$ and $P_7$ \wrt line segments $\vv{P_0P_{10}}$, $\vv{P_0P_{4}}$ and $\vv{P_4P_{10}}$, respectively.
\end{example}


\eat{%%%%%%%%%%%%%%%%%%%%%%%%%
Notations used are summarized in Table \ref{tab:notations}.

\begin{table}
	\renewcommand{\arraystretch}{1.20}
	\vspace{-1ex}
	\caption{\small Summary of notations}
	\centering
	%	\footnotesize
	\small
	\begin{tabular}{|c|l|}
		\hline
		{\bf Notations}& {\bf Semantics}   \\		\hline %\hline
		$P$ & a data point \\		\hline
		$\dddot{\mathcal{T}}$ & a trajectory $\dddot{\mathcal{T}}$ is a sequence of data points\\		\hline
		$\overline{\mathcal{T}}$&  {a piece-wise line representation of a trajectory $\dddot{\mathcal{T}}$}	\\		\hline
		$\mathcal{L}$ & a directed line segment  \\		\hline
		$ped(P, \mathcal{L})$ &  {the perpendicular Euclidean distance of $P$ to $\mathcal{L}$}	\\	\hline
		$sed(P, \mathcal{L})$ & {the synchronous Euclidean distance of $P$ to $\mathcal{L}$} 	\\		\hline
		$\epsilon$ & the error bound \\		\hline
		\sector{} & a sector \\		\hline
		%		$\vv{A} \times \vv{B}$ & the cross product of (vectors) $\vv{A}$ and $\vv{B}$\\		\hline
		%		$\mathcal{H}(\mathcal{L})$ & The open half-plane to the left of $\mathcal{L}$ \\		\hline
		%		$\mathcal{R}$& a convex polygon \\		\hline
		%		$\mathcal{R}^*$ & the intersection of convex polygons \\		\hline
		%		$m$ & the maximum number of edges of a polygon\\		\hline
		%		$E^j$ & a group of edges labeled with $j$\\		\hline
		%		$g(e)$ & the label of an edge $e$ of polygons \\		\hline
		%		\circle{} & a synchronous circle\\		\hline
		\cone{} & a spatio-temporal cone \\		\hline
		%		\pcircle{} & a cone projection circle \\		\hline
		$\bigsqcap$ & intersection of geometries\\		\hline
		$G$ &	the reachability graph of a trajectory\\		\hline
	\end{tabular}
	\label{tab:notations}
	\vspace{-1ex}
\end{table}
}%%%%%%%%%%%%%EAT


\subsection {Taxonomy of Algorithms}

Existing \lsa algorithms solving the \emph{min-$\#$} problem \cite{Chan:Optimal, Imai:Optimal,Pavlidis:Segment} fall into two categories, namely (1) the \textit{optimal} method and (2) the \textit{sub-optimal} method. And the sub-optimal algorithms can further be organized with batch method, online method and one-pass method.
We now describe these categories and leave the detailed discussion and description of each algorithm to Section 3 and Section 4.

\stitle{The optimal method.}
The \textit{optimal} methods\cite{Imai:Optimal,Chan:Optimal} are to find the minimal number of points or segments to represent the original polygonal lines \wrt an error bound $\epsilon$.


\stitle{The sub-optimal method.}

\ni (1) 
 batch algorithms (\eg Douglas-Peucker \cite{Douglas:Peucker, Meratnia:Spatiotemporal} and Theo~Pavlidis \cite{Pavlidis:Segment})
 
 
\ni (2) 
online algorithms (\eg~\bqsa\cite{Liu:BQS} \squishe \cite{Muckell:Compression}) and most recent, 

\ni (3) 
one-pass algorithms (\eg~\operb \cite{Lin:Operb} and \cised \cite{Lin:Cised}). Online algorithms and one-pass algorithms are claimed more efficient, by using some optimization strategies, such as convex hull in \bqsa~\cite{Liu:BQS}, priority queue in \squishe \cite{Muckell:Compression}, {fitting function} in \operb \cite {Lin:Operb} and spatio-temporal cone intersection in \cised \cite {Lin:Cised}. 



It is worth pointing out that some algorithms, \eg ~\bqsa and \operb, are \ped specific while others, \eg~\squishe and \cised, are \sed specific, depending on the optimization techniques they applied.

The algorithms reviewed and evaluated in our experiments are summarized in \mytable{tab:summary-lsa}, namely,
(i) Douglas-Peucker\cite{Douglas:Peucker,Meratnia:Spatiotemporal} and \pavlidis~\cite{Pavlidis:Segment}, two distinct batch \lsa algorithms,
(ii) \bqsa\cite{Liu:BQS} and \squishe~\cite{Muckell:SQUISH}, two famous online \lsa algorithms,
(iii) \operb\cite{Lin:Operb}, sector intersection \cite{Williams:Longest,Sklansky:Cone,Dunham:Cone, Zhao:Sleeve} and \cised \cite{Lin:Cised}, three one-pass \lsa algorithms, and
(iv) \opt\cite{Chan:Optimal} and \nopts, an optimal and a near optimal \lsa algorithms using \ped and \sed, respectively.

