\section{Overview of trajectory simplification algorithms}	%\section{Overview of algorithms}
\label{sec-problem}


\begin{figure*}[tb!]
	\centering
	%\vspace{-1ex}
	\includegraphics[scale=0.60]{Figures/Fig-DP.png}
	\vspace{-6ex}
	\caption{\small A trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_{10}]$  with 11 points is represented by (2) two and (3) four continuous line segments (solid blue), compressed by the Douglas--Peucker algorithm \cite{Douglas:Peucker} with error metrics \ped and \sed, respectively.}
	\vspace{-3ex}
	\label{fig:notations}
\end{figure*}

We first introduce the \emph{min-$\#$ problem} of trajectory simplification, then describe the taxonomy of the different algorithms for solving this problem.
Notations used are summarized in Table \ref{tab:notations}.
	
	\begin{table}
		\renewcommand{\arraystretch}{1.20}
		\vspace{-1ex}
		\caption{\small Summary of notations}
		\centering
		%	\footnotesize
		\small
		\begin{tabular}{|c|l|}
			\hline
			{\bf Notations}& {\bf Semantics}   \\		\hline %\hline
			$P$ & a data point \\		\hline
			$\dddot{\mathcal{T}}$ & a trajectory $\dddot{\mathcal{T}}$ is a sequence of data points\\		\hline
			$\overline{\mathcal{T}}$&  {a piece-wise line representation of a $\dddot{\mathcal{T}}$}	\\		\hline
			$\mathcal{L}$ & a directed line segment  \\		\hline
			$ped(P, \mathcal{L})$ &  {the perpendicular Euclidean distance of $P$ to $\mathcal{L}$}	\\	\hline
			$sed(P, \mathcal{L})$ & {the synchronous Euclidean distance of $P$ to $\mathcal{L}$} 	\\		\hline
			$dad(\mathcal{L}_1, \mathcal{L}_2)$ & {the direction-aware distance of $\mathcal{L}_1$ to $\mathcal{L}_2$} 	\\		\hline
			$\epsilon$ & the error bound \\		\hline
			\sector{} & a sector \\		\hline
			%		$\vv{A} \times \vv{B}$ & the cross product of (vectors) $\vv{A}$ and $\vv{B}$\\		\hline
			%		$\mathcal{H}(\mathcal{L})$ & The open half-plane to the left of $\mathcal{L}$ \\		\hline
			%		$\mathcal{R}$& a convex polygon \\		\hline
			%		$\mathcal{R}^*$ & the intersection of convex polygons \\		\hline
			%		$m$ & the maximum number of edges of a polygon\\		\hline
			%		$E^j$ & a group of edges labeled with $j$\\		\hline
			%		$g(e)$ & the label of an edge $e$ of polygons \\		\hline
			%		\circle{} & a synchronous circle\\		\hline
			\cone{} & a spatio-temporal cone \\		\hline
			%		\pcircle{} & a cone projection circle \\		\hline
			$\bigsqcap$ & intersection of geometries\\		\hline
			$G$ &	the reachability graph of a trajectory\\		\hline
		\end{tabular}
		\label{tab:notations}
		\vspace{-1ex}
	\end{table}


\subsection{Problem Definition}
\label{subsec-notation}

%We first introduce basic notations.
A \textit{trajectory} $\dddot{\mathcal{T}}[P_0, \ldots, P_n]$ is a sequence of points in a monotonically increasing order of their associated time values (\ie $P_i.t < P_j.t$ for any $0\le i<j\le n$), where a data \textit{point} is defined as a triple $P(x, y, t)$, which represents that a moving object is located at {\em longitude} $x$ and {\em latitude} $y$ at {\em time} $t$. Note that data points can be viewed as points in a three-dimension Euclidean space.


\eat{
A \textit{directed line segment} (or line segment for simplicity) $\mathcal{L}$ is defined as $\vv{P_{s}P_{e}}$, which represents the closed line segment that connects the start point $P_s$ and the end point $P_e$.
	We also use $|\mathcal{L}|$ and $\mathcal{L}.\theta\in [0, 2\pi)$ to denote the length of a directed line segment $\mathcal{L}$, and its angle with the $x$-axis of the coordinate system $(x, y)$, where $x$ and $y$ are the longitude and latitude, respectively.
	That is, a directed line segment $\mathcal{L}$ = $\vv{P_{s}P_{e}}$ can be treated as a triple $(P_s, |\mathcal{L}|, \mathcal{L}.\theta)$.
}

%Intuitively, a trajectory can also be represented by a continuous $n$-pieces directed line segments (or line segment for simplicity) $\mathcal{L}_i$, $0\le i < n$, where  $\mathcal{L}_i = \vv{P_{i}P_{i+1}}$, represents the closed line segment that connects the start point $P_{i}$ and the end point $P_{i+1}$.

A \textit{piece-wise line representation} $\overline{\mathcal{T}}[\mathcal{L}_0, \ldots , \mathcal{L}_m]$ ($0< m \le n$) of a trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_n]$ is a sequence of continuous \textit{directed line segments} (or line segment for simplicity) $\mathcal{L}_{i}$ = $\vv{P_{s_i}P_{e_i}}$ ($i\in[0,m]$) of $\dddot{\mathcal{T}}$ such that $\mathcal{L}_{0}.P_{s_0} = P_0$, $\mathcal{L}_{m}.P_{e_m} = P_n$ and  $\mathcal{L}_{i}.P_{e_i}$ = $\mathcal{L}_{i+1}.P_{s_{i+1}}$ for all $i\in[0, m-1]$.
Note that each directed line segment in $\overline{\mathcal{T}}$ essentially represents a continuous sequence of data points in $\dddot{\mathcal{T}}$.

For trajectory simplification, three distance metrics are commonly used, namely, the \emph{perpendicular Euclidean distances} (\ped), the \emph{synchronous Euclidean distances} \cite{Meratnia:Spatiotemporal}(\sed) and the \emph{direction-aware distance}\cite{Long:Direction, Zhang:Evaluation}(\dad).
%
Given a data point $P$ and a directed line segment $\mathcal{L}$ = $\vv{P_{s}P_{e}}$,

 (1) the $ped(P, \mathcal{L})$ of point $P$ to line segment $\mathcal{L}$ is $\min\{|PQ|\}$ for any point $Q$ on $\vv{P_{s}P_{e}}$,

 (2) the $sed(P, \mathcal{L})$ of $P$ to $\mathcal{L}$ is $|\vv{PP'}|$ that is the Euclidean distance from $P$ to its \textit{synchronized data point} $P'$ \wrt $\mathcal{L}$, where the synchronized data point $P'$ \wrt $\mathcal{L}$ is defined as follows:
(a) $P'.x$ = $P_s.x +  c\cdot(P_e.x - P_s.x)$,
(b) $P'.y$ = $P_s.y +  c\cdot(P_e.y - P_s.y)$ and
(c) $P'.t$ = $P.t$, where $c= \frac{P.t-P_s.t}{P_e.t-P_s.t}$.

 (3) the $dad(\mathcal{L}_1, \mathcal{L}_2)$, say, the direction deviation from $\mathcal{L}_1$ to $\mathcal{L}_2)$, is $\Delta(\mathcal{L}_1.\theta, \mathcal{L}_2.\theta) = \min\{|\mathcal{L}_1.\theta - \mathcal{L}_2.\theta|, 2\pi - |\mathcal{L}_1.\theta - \mathcal{L}_2.\theta|\}$, where $\theta \in [0, 2\pi)$ is the angular of $\mathcal{L}$.



Then, given a trajectory \trajec{T}$[P_0, \dots, P_n]$ and a pre-specified constant $\epsilon$, the \emph{min-$\#$} problem of trajectory simplification is to approximate the trajectory \trajec{T} by $\overline{\mathcal{T}}[\mathcal{L}_0, \ldots , \mathcal{L}_m]$ ($0< m \le n$), such that
(1) on each of them the points $[P_{s_i}, \dots, P_{e_i}]$ are approximated by a line segment $\mathcal{L}_i = \vv{P_{s_i}P_{e_i}}$ with the maximum \ped or \sed \emph{error} of point $P_j$ (or \dad \emph{error} of line segment $|\vv{P_jP_{j+1}}|$) to line segment $\mathcal{L}_i$, $s_i < j<e_i$,  less than $\epsilon$, and
(2) $P_{s_i}$ and $P_{e_i} \in$ \trajec{T}.
%algorithm $\mathcal{A}$
% an extension of the famous \emph{min-$\#$} problem of piece-wise line simplification\cite{Chan:Optimal, Imai:Optimal,Pavlidis:Segment},



We illustrate the problem and notations with examples.

\begin{example}
	\label{exm-notations}
	Consider Figure~\ref{fig:notations}, in which
	%
	(1) $\dddot{\mathcal{T}}[P_0$, $\ldots, P_{10}]$ is a trajectory having 11 data points,
	%
    (2) the set of two continuous line segments $\{\vv{P_0P_4}$, $\vv{P_4P_{10}}$\}, the set of four continuous line segments $\{\vv{P_0P_2}$, $\vv{P_2P_4}$, $\vv{P_4P_7}$, $\vv{P_7P_{10}}$\} and the set of three continuous line segments $\{\vv{P_0P_4}$, $\vv{P_4P_5}$, $\vv{P_5P_{10}}$\} are three piecewise line representations of trajectory $\dddot{\mathcal{T}}$,
	%
	(3) $ped(P_4, \vv{P_0P_{10}})=|\vv{P_4P^*_4}|$, where $P^*_4$ is the perpendicular point of $P_4$ \wrt line segment $\vv{P_0P_{10}}$,
	%
	(4) $sed(P_4, \vv{P_0P_{10}})= |\vv{P_4P'_4}|$, $sed(P_2, \vv{P_0P_{4}})= |\vv{P_2P'_2}|$ and $sed(P_7, \vv{P_4P_{10}})$ $=$ $|\vv{P_7P'_7}|$,
	where points $P'_4$, $P'_2$ and $P'_7$ are the synchronized points of $P_4$, $P_2$ and $P_7$ \wrt line segments $\vv{P_0P_{10}}$, $\vv{P_0P_{4}}$ and $\vv{P_4P_{10}}$, respectively, and
    %
    (5) $dad(\vv{P_5P_6}, \vv{P_0P_{10}})=\theta_{56}$ is the \dad of line segment $\vv{P_5P_6}$ to $\vv{P_0P_{10}}$.
\end{example}





\eat{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\begin{table*}
		\renewcommand{\arraystretch}{1.20}
		\caption{\small Summary of piece-wise line based algorithms for trajectory simplification}
		\label{tab:summary-lsa}
		\centering
		\small
		\begin{tabular}{|l|c|c|c|c|c|c|c|}
			\hline
			\kw{Name}  & \kw{Type}    & \kw{Key~Ideas}  &\kw{\ped} &\kw{\sed}  &  \kw{Time~Complexity} & \kw{Space~Complexity} \\		\hline
			\opt~\cite{Imai:Optimal}	&optimal	& Graph    							&Y & Y & $O(n^3)$	& {$O(n^2)$} \\		\hline
			\optp\cite{Chan:Optimal}	&optimal	& Graph and Sector intersection    	&Y & N & $O(n^2)$	& {$O(n)$} \\		\hline
			%\nopts~	&near optimal&Graph and Spatio-temporal cone intersection&N & Y  & $O(n^2)$	& $O(n)$ \\		\hline
			\dpa\cite{Douglas:Peucker, Meratnia:Spatiotemporal}	&batch &Top-down     &Y &Y    & $O(n^2)$ & O(n)  \\		\hline
			\tpa\cite{Pavlidis:Segment}	&batch	&Bottom-up       &Y &Y   & $O(n^2/K)$ & O(n)  \\		\hline
			\bqsa\cite{Liu:BQS}	&online	&Top-down, opening window and Convex hull    &Y   & N& $O(n^2)$  & $O(|Q|)$   \\		\hline
			\squishe\cite{Muckell:Compression}	&{online}	& Bottom-up and Priority queue       & N &Y    & $O(n\log|Q|)$ & $O(|Q|)$ \\		\hline
			%swab	&   &online   &Y &Y  & $\Omega(n)$ & $O(n^2)$ & O(w) &\textcolor[rgb]{1.00,0.00,0.00}{} \\		\hline
			%owtd	&   &online    &Y &Y   & $\Omega(n)$ & $O(n^2)$ & O(n) &\textcolor[rgb]{1.00,0.00,0.00}{} \\ 	\hline
			%ddr	    &       &one-pass    &Y  &Y  & $\Omega(n)$ & $O(n)$ & O(n) &\textcolor[rgb]{1.00,0.00,0.00}{} \\  \hline
			\operb\cite{Lin:Operb}	& one-pass	& Fitting function    &Y & N  & $O(n)$ & O(1)  \\		\hline
			\siped\cite{Dunham:Cone, Zhao:Sleeve}	&one-pass	& Sector intersection   &Y & N & $O(n)$ & O(1) \\		\hline
			\cised\cite{Lin:Cised}	&one-pass	& Spatio-temporal cone intersection    	&N & Y & $O(n)$ & O(1) \\		\hline
		\end{tabular}
		{\\  Note: $K$ is the number of the final segments of a trajectory and $|Q|$ is the size of buffer/window.}
		\vspace{-4ex}
	\end{table*}
}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection {Taxonomy of Algorithms}
\label{subsec-taxonomy}

Existing \lsa algorithms, solving the \emph{min-$\#$} problem \cite{Chan:Optimal, Imai:Optimal,Pavlidis:Segment}, fall into two categories, namely the \textit{optimal} method and the \textit{sub-optimal} method. And the sub-optimal algorithms can further be organized with batch method, online method and one-pass method.
We now describe these categories and leave the detailed discussion and description of each algorithm to Section 3 and Section 4.

\stitle{Optimal method.}
The \textit{optimal} method is to find the minimal number of points or segments to represent the original trajectory \wrt an error bound $\epsilon$, by transforms the problem to search for the shortest path of a graph built from the original trajectory. Indeed, the optimal \lsa algorithms have relative high time/space complexities.
Example algorithm of this category is \opt \cite{Imai:Optimal,Chan:Optimal}. % and \optp \cite{Chan:Optimal}.


\stitle{Sub-optimal method.}
The sub-optimal algorithms are heuristic, they achieve better efficiencies at the expense of outputting a little more data points.
From the point of view of the distance checking policies they applied, these algorithms can further be organized with
batch method, online method and one-pass method, as follows:

\ni (1) \textit{batch algorithms} apply the global distance checking policy which requires all trajectory points be loaded before they start compressing and a point may be checked many times to calculate the distance of it to the corresponding line segments during the whole process. Example algorithms are Douglas-Peucker\cite{Douglas:Peucker,Meratnia:Spatiotemporal} and \pavlidis~\cite{Pavlidis:Segment}.

\ni (2) \textit{online algorithms} apply the constraint global distance checking policy which need not have the entire trajectory ready before they start compressing, instead, they restrict the checking within a window and a point is still checked multiple times during the process. Example algorithms are \opwa \cite{Meratnia:Spatiotemporal}, \bqsa\cite{Liu:BQS} and \squishe~\cite{Muckell:SQUISH}.

\ni (3) \textit{one-pass algorithms} apply the local distance checking policy which does not need a window to buffer the preview read points, instead, it processes each point in a trajectory once and only once. Example algorithms are \operb\cite{Lin:Operb}, \siped \cite{Williams:Longest,Sklansky:Cone,Dunham:Cone, Zhao:Sleeve}, \cised \cite{Lin:Cised} and \interval \cite{Ke:Interval}.

We choose the most typical algorithms from each categories.
The algorithms and distance metrics reviewed and evaluated in our experiments are summarized in \mytable{tab:summary-lsa}, namely,
(i) \opt\cite{Chan:Optimal} \eat{and \optp}, a naive optimal algorithm.
(ii) Douglas-Peucker\cite{Douglas:Peucker,Meratnia:Spatiotemporal} and \pavlidis~\cite{Pavlidis:Segment}, two distinct batch \lsa algorithms,
(iii) \bqsa\cite{Liu:BQS} and \squishe~\cite{Muckell:SQUISH}, two important online \lsa algorithms, and
(iv) \operb\cite{Lin:Operb}, \siped \cite{Williams:Longest,Sklansky:Cone,Dunham:Cone, Zhao:Sleeve}, \cised \cite{Lin:Cised} and \interval\cite{Ke:Interval}, four one-pass \lsa algorithms.
%
These algorithms, some are \ped specific (\eg~\bqsa and \operb), some are \sed specific (\eg~\squishe and \cised) and some are \dad specific (\eg~\interval), depending on the optimization techniques they applied.



\begin{table*}
	\renewcommand{\arraystretch}{1.20}
	\vspace{-1ex}
	\caption{\small Evaluated trajectory simplification algorithms}
	\label{tab:summary-lsa}
	\centering
	\small
	\begin{tabular}{|l|c|c|c|c|c|c|c|c}
		\hline
		\kw{Name}  & \kw{Type}      &\kw{\ped} &\kw{\sed}  &\kw{\dad} &  \kw{Time} & \kw{Space} & \kw{Key~Idea}\\		\hline
		\opt~\cite{Imai:Optimal}	&optimal		&Y & Y & Y & $O(n^3)$	& {$O(n^2)$}  & Reachability Graph\\		\hline
%		\optp\cite{Chan:Optimal}	&optimal		&Y & N & N & $O(n^2)$	& {$O(n)$}  &Graph and Sector intersection  \\		\hline
		\dpa\cite{Douglas:Peucker, Meratnia:Spatiotemporal}	&batch  &Y &Y & Y   & $O(n^2)$ & O(n)   & Top-down \\		\hline
		\tpa\cite{Pavlidis:Segment}	&batch       &Y &Y & Y  & $O(n^2/K)$ & O(n)   &Bottom-up \\		\hline
		\bqsa\cite{Liu:BQS}	&online	   &Y   & N & N & $O(n^2)$  & $O(|Q|)$    &Top-down, opening window and Convex hull  \\		\hline
		\squishe\cite{Muckell:Compression}	&{online}	  & N &Y  & N  & $O(n\log|Q|)$ & $O(|Q|)$  &Bottom-up and Priority queue \\		\hline
		\operb\cite{Lin:Operb}	& one-pass	  &Y & N & N & $O(n)$ & O(1)   & Fitting function \\		\hline
		\siped\cite{Dunham:Cone, Zhao:Sleeve}	&one-pass	  &Y & N & N & $O(n)$ & O(1)  & Sector intersection\\		\hline
		\cised\cite{Lin:Cised}	&one-pass	 	&N & Y & N & $O(n)$ & O(1)  & Spatio-temporal cone intersection \\		\hline
		\interval\cite{Ke:Interval}	&one-pass	 	&N & N & Y & $O(n)$ & O(1)  & Interval intersection \\		\hline
	\end{tabular}
	{\\  Note: $K$ is the number of the final segments of a trajectory and $|Q|$ is the size of a buffer/window.}
	\vspace{-3ex}
\end{table*}
