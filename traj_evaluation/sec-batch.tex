\subsection{Batch Algorithms}

Batch algorithms essentially enforce the global distance checking policy that requires all trajectory points be loaded before they start compressing. %, hence they run in batch.
Batch algorithms can be either top-down or bottom-up.

Top-down algorithms, \eg Ramer \cite{Ramer:Split} and Douglas-Peucker \cite{Douglas:Peucker}, recursively divide a trajectory into sub-trajectories until the stopping condition is met.
Authors of \cite{Meratnia:Spatiotemporal} revised the \dpa algorithm to support \sed.
Authors of \cite{Hershberger:Speeding} developed an improved method of \dpa, based on \emph{convex hulls}, that uses the geometric structure of the problem to attain a worst-case running time proportional to $O(n\log n)$, which is the best case of the \dpa algorithm. {This optimization is specific for \ped and cannot work with \sed.}

Bottom-up algorithms, \eg Theo Pavlidis \cite{Pavlidis:Segment}, is the natural complement to top-down ones, which recursively merge adjacent sub-trajectories with the smallest distance, initially $n/2$  sub-trajectories for a trajectory with $n$ points, until the stopping condition is met. Note that the distances of newly generated line segments are recalculated during the process.

We next review algorithms Douglas-Peucker and Theo Pavlidis evaluated in out experiments.

\begin{figure*}[tb!]
	\centering
	\includegraphics[scale=0.55]{figures/Fig-Pavlidis.png}
	\vspace{-5ex}
	\caption{\small The trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_{8}]$ is compressed by the \pavlidis~algorithm using \ped to two line segments. The triple $(i, j, cost)$ is the $cost$ of merging the line segments $\overline{P_iP_t}$ and $\overline{P_tP_j}$.} % The algorithm finally outputs $\vv{P_0P_4}$ and $\vv{P_4P_{10}}$ 
	\vspace{-2ex}
	\label{fig:pavlidis}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Douglas-Peucker Algorithm}

The Douglas-Peucker (\dpa) algorithm \cite{Douglas:Peucker} was invented in 1973, for reducing the number of points required to represent a digitized line or its caricature in the context of computer graphics and image processing.
The \dpa algorithm employ the Top-down and the global checking policy and it is clearly a batch algorithm, hence, the entire raw trajectory is needed at the beginning \cite{Meratnia:Spatiotemporal}.

The basic \dpa uses \ped, as shown in Figure~\ref{alg:dp}.
Given a trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_n]$ and an error bound $\epsilon$, the algorithm uses the first point $P_0$ and the last point $P_n$ of \trajec{T} as the start point $P_s$ and the end point $P_e$ of the first line segment $\mathcal{L}(P_0, P_n)$, then it calculates the distance $ped(P_i, {\mathcal{L}})$ for each point $P_i$ ($i\in[0,n]$) (lines 1--2). If $ped(P_k, {\mathcal{L}})$ = $\max \{ped(P_0, {\mathcal{L}}), \ldots, ped(P_n, {\mathcal{L}}) \} \le \epsilon$, then it returns $\{\mathcal{L}(P_0,P_n)\}$ (lines 3--5). Otherwise, it divides \trajec{T} into two sub-trajectories \trajec{T}$[P_0, \ldots, P_k]$ and \trajec{T}$[P_{k}, \ldots, P_n]$, and recursively compresses these sub-trajectories until the entire trajectory has been considered (lines 6--7).

In the best case, the time complexity of \dpa is $\Omega(n)$; in the worst case, the time complexity of \dpa is $O(n^2)$.

Algorithm \dpa using \sed \cite{Meratnia:Spatiotemporal} runs in the same routine as the basic \dpa, except that $ped$ is replace by $sed$ in Figure~\ref{alg:dp}.

%The \dpa algorithm are \textcolor[rgb]{0.00,0.07,1.00}{widely considered have excellent compression ratio and accuracy.}
%However, the batch nature and high time complexity make it not suitable for the online scenarios.


%%%%%%%%%%%%%%%%%%%%%Baseline Algorithm
\begin{figure}[tb!]
%\vspace{-2ex}
\vspace{1ex}
\begin{center}
{\small
\begin{minipage}{3.3in}
\myhrule \vspace{-1ex}
\mat{0ex}{
{\bf Algorithm}~$\dpa(\dddot{\mathcal{T}}[P_0,\ldots,P_n], \epsilon)$\\
\sstab
\bcc \hspace{1ex}\=\For each point $P_i$ ($i\in[0,n]$) in $\dddot{\mathcal{T}}[P_0, \ldots, P_n]$ \Do\\
\icc \>\hspace{3ex}compute $ped(P_i, {\mathcal{L}})$ between $P_i$ and ${\mathcal{L}}(P_0, P_n)$;\\
\icc \> \Let $ped(P_k, {\mathcal{L}})$ := $\max \{ped(P_0, {\mathcal{L}}), \ldots, ped(P_n, {\mathcal{L}}) \}$;\\
\icc \> \If $ped(P_k, {\mathcal{L}}) \le\epsilon$ \Then \\
\icc \> \hspace{3ex}\Return $\{\mathcal{L}(P_0,P_n)\}$.\\
\icc \> \Else\\
\icc \> \hspace{3ex}\Return $\dpa($\trajec{T}$[P_0, \ldots, P_k], \epsilon)\cup\dpa($\trajec{T}$[P_{k}, \ldots, P_n], \epsilon)$.
}
\vspace{-2.5ex}
\myhrule
\end{minipage}
}
\end{center}
\vspace{-3ex}
\caption{\small Basic Douglas-Peucker algorithm}
\label{alg:dp}
\vspace{-3ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\vspace{-1ex}
\begin{example}
\label{exm-alg-lsa}
Consider the trajectory $\dddot{\mathcal{T}}[P_0,\ldots,P_{10}]$ shown in Figure~\ref{fig:notations}.
The $\dpa$ Algorithm firstly creates $\vv{P_0P_{10}}$, then it calculates the distance of each point in $\{P_0,\ldots,P_{10}\}$ to $\vv{P_0P_{10}}$.
It finds that $P_{4}$ has the maximum distance to $\vv{P_0P_{10}}$, which is greater than $\epsilon$. Then it goes to compress sub-trajectories $[P_0, \ldots, P_{4}]$ and $[P_{4}, \ldots, P_{10}]$, separately.
When using \sed (right), the sub-trajectory $[P_4,\ldots, P_{10}]$ is further split to $[P_4$, $\ldots$, $P_7]$ and $[P_7$, $P_{10}]$.
Finally, the algorithm outputs two continuous directed line segments $\vv{P_0P_4}$ and $\vv{P_4P_{10}}$ when using \ped, and three continuous directed line segments $\vv{P_0P_4}$, $\vv{P_4P_7}$ and $\vv{P_7P_{10}}$ when using \sed.
\end{example}



\subsubsection{Theo Pavlidis Algorithm}

The {\pavlidis~(\tpa) algorithm}~\cite{Pavlidis:Segment}, invented in 1974, is known as the Bottom-up algorithm. It also employs the global checking policy, and hence, it is a batch algorithm. 
%Because the original \tpa algorithm outputs disjoint line segments, 
Note we slightly modify the algorithm to output continuous line segments.

Given a trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_n]$ and an error bound $\epsilon$,
the algorithm begins by creating the finest possible approximation of the trajectory, \ie $[P_0, P_1], [P_2, P_3], \ldots$, so that $n-1$ segments are used to approximate the original $n$-length trajectory.
Next, for each pair of adjacent segments $[P_{s}, P_{s+1}]$ and $[P_{s+1}, P_{s+2}]$, $0\le s \le n-2$,
the max distance of each points $P_i$, $0<i<2$, to the line segment $\vv{P_sP_{s+2}}$, \ie $ped(P_{s+i}, \vv{P_sP_{s+2}})$, is calculated and the maximum of them is saved, denoting the \emph{cost} of merging them.
Then the algorithm begins to iteratively merge the lowest cost adjacent segments pair
until that no cost is below the error bound $\epsilon$.
When the pair of adjacent segments $[P_{s}, P_{s+i}]$ and $[P_{s+i}, P_{s+j}]$ are merged to a new segment $[P_{s}, P_{s+j}]$, the algorithm needs to recalculate the cost of merging the new segment with its preceding neighbour segment, and the cost of merging it with its successor neighbor segment.

The time complexity of the algorithm is $O(n^2/K)$, where $K$ is the number of the final segments.

%Furthermore, it is also easy to implement \sed in the \tpa algorithm.
The \tpa algorithm like \dpa algorithm originally only support \ped, but is also easy to be extended to support \sed.


\begin{example}
\label{exm-alg-pavlidis}
Figure~\ref{fig:pavlidis} is an example of the \tpa algorithm.

\ni (1) Initially, the $10$ segments are created, and for each pair of adjacent segments, the costs of merging them are calculated and saved. For example, the cost of merging $\vv{P_0P_1}$ and $\vv{P_1P_2}$ is $ped(P_{1}, \vv{P_0P_{2}}) = 0.32\epsilon$.
%
(2) The cost of merging $\vv{P_6P_7}$ and $\vv{P_7P_8}$ is $0.02\epsilon$, which is the minimal value among all costs. Hence, $\vv{P_6P_7}$ and $\vv{P_7P_8}$ are merged to $\vv{P_6P_8}$. The cost of merging $\vv{P_5P_6}$ and $\vv{P_6P_8}$, and the cost of merging $\vv{P_6P_8}$ and $\vv{P_8P_9}$ are also updated to $0.37\epsilon$ and $0.11\epsilon$, respectively.
%
(3) $\vv{P_2P_3}$ and $\vv{P_3P_4}$ are merged to $\vv{P_2P_4}$. The cost merging $\vv{P_2P_4}$ and $\vv{P_4P_5}$, and the cost of merging $\vv{P_1P_2}$ and $\vv{P_2P_4}$ are also updated.
%
(4) At last, the algorithm outputs two line segments $\vv{P_0P_4}$ and $\vv{P_4P_{10}}$.
\end{example}

