
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "www2019"
%%% End:

\section{One-pass tracking in strip areas}
\label{sec:strip}


Currently, position tracking and trajectory tracking methods both use \sed as the distance metric to check data points and confirm the actual position of a moving object at time $t$ lives in a circle around the excepting position of the moving object at that time.
However, as mentioned in Section~\ref{sec-intro}, there is a need of tracking a moving object in strip areas.
%Though \sed is currently the only distance metric used in tracking moving objects, we argue that another distance metric, \ped that is wildly used in trajectory simplification and always has remarkable better compression ratios than \sed, is also important in tracking moving objects that confirms moving objects lives in strip areas, \eg a school boy is expected on his way home no matter the speed of his movement.
This section introduces a novel \ped-based method that tracks a moving object in strip areas.


%\subsection{Position tracking in strip areas}
%based on ldr, a direction is needed, no speed;
%  --  distance checking during computing, ped: from a point to a ray.
  

\subsection{\ped, sector and trajectory simplification}
\label{sec:sector-in-simp}

Though \ped is not seemed in position and trajectory tracking, it is familiar in trajectory simplification, where an error-bounded algorithm using \ped always ensures that the original data points live in strip-like areas built from the simplified trajectory. 
%Actually, it is the first distance metric of trajectory simplification, earlier than \sed. 
Thus, \textit{\ped is the potential distance metric to track a moving object in strip areas.}
%
Next, for data simplification using \ped, the most efficient and effective way to check the data points is undoubted \textit{sector intersection} \cite{Williams:Longest, Sklansky:Cone, Dunham:Cone, Zhao:Sleeve}, which is originally developed in fields of computational geometry and cartography to efficient simplifies the border lines of a geometric or cartographic shape in digital format, yet is applicable to simplify trajectories as pointed out in \cite{Lin:Cised}. Here, a \emph{sector} is largely a simplified version of a spatio-temporal cone projected on an x--y 2D space that the temporal information is ignored, that converts the \ped distance tolerance into an angle tolerance for efficiently checking the successive data points.

Given a sequence of points $[P_{s}, P_{s+1}, \ldots, P_{s+k}]$ and an error bound $\epsilon$,
for the start data point $P_s$, any point $P_{s+i}$ and $|\overline{P_sP_{s+i}}|>\epsilon$ ($i\in[1, k]$), there are two directed lines $\overline{P_sP^u_{s+i}}$ and $\overline{P_sP^l_{s+i}}$ such that $ped(P_{s+i}, \overline{P_sP^u_{s+i}})$ $=$ $ped(P_{s+i}, \overline{P_sP^l_{s+i}}) = \epsilon$ and either ($\overline{P_sP^l_{s+i}}.\theta < \overline{P_sP^u_{s+i}}.\theta ~and~\overline{P_sP^u_{s+i}}.\theta - \overline{P_sP^l_{s+i}}.\theta <\pi$) or ($\overline{P_sP^l_{s+i}}.\theta > \overline{P_sP^u_{s+i}}.\theta ~and~ \overline{P_sP^u_{s+i}}.\theta - \overline{P_sP^l_{s+i}}.\theta < -\pi)$. Indeed, they form a \emph{sector} \sector{(P_s, P_{s+i}, \epsilon)} that takes $P_s$ as the center point and $\overline{P_sP^u_{s+i}}$ and $\overline{P_sP^l_{s+i}}$ as the borderlines (Figure~\ref{fig:sleeve}-(1)).
%
Then, like the checking of the common intersection of spatio-temporal cones in \cised, these sector-based algorithms check the common intersection of sectors (Figure~\ref{fig:sleeve}-(2)), \ie $\bigsqcap_{i=1}^{k}$\sector{(P_s, P_{s+i}, \epsilon)} $\ne \{P_s\}$ \cite{Williams:Longest, Sklansky:Cone,Zhao:Sleeve}, to find out whether the sub-trajectory can be represented by a line segment $\overline{P_sQ}$ \wrt error bound $\epsilon$, where $Q$ is a point that may not belong to the sub-trajectory. However, if $Q$ must be $P_{s+k}$, the last point of the sub-trajectory, \eg $P_3$ in Figure~\ref{fig:sleeve}-(3),  then (1) the full-$\epsilon$ sectors should be replaced by half-$\epsilon$ sectors, and (2) $P_{s+k}$ should be one of the points having the furthest distances to $P_s$, \ie $|P_sP_{s+k}| > max\{|P_sP_{s+i}|\} - \epsilon$~for each $i \in (0, k)$. 
%

\begin{figure}[tb!]
	\centering
	\includegraphics[scale=0.9]{figures/Fig-Sleeve.png}
	\vspace{-2ex}
	\caption{\small Examples of sectors and their intersection.}
	\vspace{-2ex}
	\label{fig:sleeve}
\end{figure}


\subsection{Tracking by sector}

Similar as spatio-temporal cones used to track trajectory in circular areas, the half-$\epsilon$ sectors used in trajectory simplification is applicable to track moving objects in strip areas. 
%
Moreover, because the half-$\epsilon$ sectors may limit its compression performance, we also extend it to full-$\epsilon$ sectors for better performance.


%, that is, for any data point $P_{s+i}$ ($i \in [1, ... k]$), its perpendicular Euclidean distance to line segment $\overline{P_sP_{s+k}}$ is not greater than the error bound $\epsilon$.

\begin{theorem}
	\label{theo-half-sector}
	Given a sub-trajectory $[P_s,...,P_{s+k}]$ and an error bound $\epsilon$, it can be tracked in strips by half-$\epsilon$ sectors.
\end{theorem}

\begin{proof}
	Trajectory tracking is the combination of trajectory simplification and position tracking.
	%
	(1) Trajectory simplification: It can be simplified in strip-like areas as shown in Section \ref{sec:sector-in-simp};
	%
	(2) Position tracking: If it can be represented by a line segment by the intersection of sectors, then there is sure a $\vv{v}$ living in the common intersection of sectors, \eg $\vv{v}$ on $P_sP_{s+i}$, such that it is applicable to track the position in strip areas.
	%
	Combine (1) and (2), we have the conclusion.
\end{proof}



\begin{theorem}
	\label{theo-full-sector}
	Given a sub-trajectory $[P_s,...,P_{s+k}]$ and an error bound $\epsilon$, $ped(P_{s+i}, \overline{P_sP_{s+k}})\le \epsilon$ for each $i \in [1,k]$ if line segment $\overline{P_sP_{s+i}}$ passes through $\bigsqcap_{j=1}^{i-1}$\sector{(P_s, P_{s+j}, \epsilon)} - \{$P_s$\} ~and~ $|P_sP_{s+i}| > max\{|P_sP_{s+j}|\} - \epsilon$ for each $j \in (0, i)$.
\end{theorem}

\begin{proof}
	\todo.
\end{proof}

Theorem \ref{theo-full-sector} tells that full-$\epsilon$ sectors with some constrains can also be used in trajectory simplification and/or tracking. 

\begin{theorem}
	\label{theo-sector-vs}
	Given a sub-trajectory $[P_s,...,P_{s+k}]$ and an error bound $\epsilon$, if $\bigsqcap_{i=1}^{k}$\sector{(P_s, P_{s+i}, \epsilon/2)} $\ne \{P_s\}$, then for each $i \in [2, k]$, line segment $\overline{P_sP_{s+i}}$ passes through $\bigsqcap_{j=1}^{i-1}$\sector{(P_s, P_{s+j}, \epsilon)}-$\{P_s\}$; and the opposite is not always true.
\end{theorem}

\begin{proof}
	\todo.
\end{proof}

Theorem \ref{theo-sector-vs} tells that the full-$\epsilon$ sector approach also brings a better effectiveness than the half-$\epsilon$ sector in trajectory simplification and/or tracking.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Algorithm: Traj tracking based on section intersection using full sectors.
\begin{figure}[tb!]   
	\begin{center}
		{\small
			\begin{minipage}{3.3in}
				\myhrule
				%\vspace{-1ex}
				\mat{0ex}{
					{\bf Algorithm}~\sitt $(\dddot{\mathcal{T}}[P_0,\ldots,P_n],~\epsilon)$\\
					%	\sstab
					\bcc \hspace{1ex}\= $P_s := P_0$; ~~~~$\mathcal{S}^*$ := \kw{getSector}($P_s$, $P_{s+1}$, $\epsilon$); ~~~~$l_{m} = |P_sP_{s+1}|$;\\
					\icc \hspace{1ex}\= $\vv{v}.\theta:=\overline{P_{s}P_{s+1}}.\theta$;  \\
					\icc \hspace{1ex}\= update ($P_{s}, \vv{v}$); 	\\
					\icc \hspace{1ex}\= $i:= 2$;  	\\
					\icc \hspace{1ex}\= while $i \le n$ do \\
					\icc \>\hspace{3ex} if $\overline{P_sP_{i}}$ ~does not pass~ $\mathcal{S}^*$ or $|P_sP_{i}| \le l_{m} - \epsilon$ then \\ % // updates velocity and location \\
					\icc \>\hspace{7ex}    $P_s := P_{i-1}$; ~~~~$\mathcal{S}^*$ := $\emptyset$; ~~~~$l_{m} = |P_sP_{i}|$;\\
					\icc \>\hspace{7ex}    $\vv{v}.\theta:=\overline{P_{s}P_{i}}.\theta$;  \\
					\icc \>\hspace{7ex}    update ($P_{s}, \vv{v}$); 	\\
					\icc \>\hspace{3ex} else if $\overline{P_sP_{i}}$ ~passes~ $\mathcal{S}^*$ ~and~ $|P_sP_{i}| > l_{m} - \epsilon$ \\ \hspace{9ex} ~and~ $ped(P_i, \vv{v}) \ge \epsilon $ then  \\ %~// updates velocity only 
					\icc \>\hspace{7ex}    $\vv{v}.\theta:=\overline{P_sP_{i}}.\theta$; \\
					\icc \>\hspace{7ex}    update ($\vv{v}$); \\
					\icc \>\hspace{3ex} if $\mathcal{S}^*=\emptyset$ then $\mathcal{S}^*:=$ \kw{getSector}($P_s$, $P_{i}$, $\epsilon$); \\
					\icc \>\hspace{3ex} else $\mathcal{S}^*$ := $\mathcal{S}^*\bigsqcap$ \kw{getSector}($P_s$, $P_{i}$, $\epsilon$); $l_{m} = \max\{|P_sP_{i}|, l_{m}\}$;\\
					\icc \>\hspace{3ex} $i$ := $i +1$;\\
					\icc \>\hspace{0ex} update ($P_{n}$); 
				}
				\vspace{-2ex}
				\myhrule
			\end{minipage}
		}
	\end{center}
	\vspace{-1ex}
	\caption{\small Trajectory tracking based on sector.}
	\label{alg:sitt}
	\vspace{-1ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Implementation}

We then present a one-pass trajectory tracking algorithm based on full-$\epsilon$ sector, named \underline{S}ector \underline{I}ntersection for \underline{T}rajectory \underline{T}racking (\sitt). As shown in Figure ~\ref{alg:sitt}, \sitt runs in a similar routine as \citt excepts that (1) \sed and spatio-temporal cone are replaces by \ped and sector, (2) only the direction information of $\vv{v}$ is needed while the speed information is not, such that when a distance deviation occurs, \sitt quickly finds out a new feasible direction of velocity $\vv{v}$ by the intersection of sectors and sends it to the MOD server; and (3) it temporarily saves the maximum length of $|P_sP_{s+j}|$, $j\in (0, i)$, in $l_m$ and compares it with the length $|P_sP_{s+i}|$ of the current point $P_{s+i}$ during the process, as mentioned in Theorem \ref{theo-full-sector}. 

\todo{tips for points having distances to $P_s$ smaller than $\epsilon$.}

\begin{example}
	\todo.
\end{example}


\stitle{Correctness and complexity.} 
\todo.


\eat{%%%%%%%%
	\begin{example}
		\label{exm-alg-sleeve}
		Figure~\ref{fig:sleeve} is a running example of algorithm \siped($\frac{\epsilon}{2}$) taking as input the same trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_{10}]$. At the beginning, $P_0$ is the first start point, and points $P_1$, $P_2$, $P_3$, etc., each has a narrow \emph{sector}.
		For example, the narrow \emph{sector} $\mathcal{S}$($P_0$, $P_{3}$, $\epsilon/2$) takes $P_0$ as the center point and $\overline{P_0P^u_{3}}$ and $\overline{P_0P^l_{3}}$ as the borderlines.
		Because $\bigsqcap_{i=1}^{4}\mathcal{S}(P_0, P_{0+i}, \epsilon/2) \ne \{P_0\}$ and $\bigsqcap_{i=1}^{5}\mathcal{S}(P_0, P_{0+i}, \epsilon/2) = \{P_0\}$, $\overline{P_0P_4}$ is output and $P_4$ becomes the start point of the next section.
		At last, the algorithm outputs two continuous line segments $\overline{P_0P_4}$ and $\overline{P_4P_{10}}$.
	\end{example}
	
	\begin{figure}[tb!]
		\centering
		\includegraphics[scale=0.66]{Figures/Fig-sleeve.jpg}
		\vspace{-2ex}
		\caption{\small The trajectory $\dddot{\mathcal{T}}$ is compressed by the sector intersection algorithm using \ped to two line segments.}
		\vspace{-1ex}
		\label{fig:sleeve}
	\end{figure}
}%%%%%%%%
