\section{Effective one-pass tracking in circular areas}
\label{sec:circular}

\ldrh is a one-pass trajectory tracking algorithm, having linear time and constant space complexities, yet suffering in effectiveness (compression ratios).
Observing the recently trajectory simplification algorithm \cised using \sed is also one-pass, which is important for a trajectory tracking algorithm that is supposed to run on mobile devices, and at the same time, it has good compression ratios, these inspire us to develop an efficient and effective trajectory tracking algorithm using \sed.

\subsection{Tracking by spatio-temporal cone}

In this section, we will first show that the counterpart of \ldrh is just a special case of, and has worse effective in terms of compression ratio than the approach of spatio-temporal cone intersection (even it uses a half-$\epsilon$ cone), thus, the latter is obviously a more effective way to develop trajectory tracking algorithms. Then, we further extend the half-$\epsilon$ cone used in \cised to a full-$\epsilon$ cone so as to get an even better effectiveness.



\begin{theorem}
\label{theo-ldrh-cised}
Given a sub-trajectory $\dddot{\mathcal{T}}_s[P_s,...,P_{s+k}]$ and an error bound $\epsilon$, if $\dddot{\mathcal{T}}_s$ can be represented by line segment $\vv{P_sP_{s+k}}$ through algorithm \ldrh, then it can also be represented by approaches based on spatio-temporal cones.
\end{theorem}

\begin{proof}
\todo{1. $\vv{v}$ in 3D space; 2...}

If $|P_{s+i}P'_{s+i}|\le \epsilon/2$ for each $i \in [1,k]$, then $\vv{v}$ must live in the common intersection of half-$\epsilon$ cones $\bigsqcap_{i=1}^{k}$\cone{(P_s, P_{s+i}, \epsilon/2)}, where $P'_{s+i}$ is the synchronized point of $P_{s+i}$ \wrt velocity $\vv{v}$.
\end{proof}

Theorem \ref{theo-ldrh-cised} tells that (1) {spatio-temporal cone can also be used in trajectory tracking}, and (2) \ldrh is just a special case of and has a worse effectiveness than approaches based on spatio-temporal cones. Indeed, \ldrh assumes an initial velocity before the simplification or tracking of a sub-trajectory, while the spatio-temporal cone based methods do not, instead, it has an ability to find out the potentially feasible velocities to fit the movement of the object when it simplifies the sub-trajectory. Thus, the latter is sure a more effective way to develop one-pass trajectory tracking algorithms. 
%
Moreover, observe that the half-$\epsilon$ cone in the above is still a little conservative, we next extend it to a full-$\epsilon$ cone plus certain constrain to get an even better effectiveness.


\begin{theorem}
	\label{theo-full-cone}
	Given a sub-trajectory $[P_s,...,P_{s+k}]$ and an error bound $\epsilon$, $sed(P_{s+i}, \vv{P_sP_{s+k}})\le \epsilon$ for each $i \in [1,k]$ if $\vv{P_sP_{s+i}}$ passes through $\bigsqcap_{j=1}^{i-1}$\cone{(P_s, P_{s+j}, \epsilon)} - \{$P_s$\}.
\end{theorem}

\begin{proof}
	\todo.
\end{proof}

Theorem \ref{theo-full-cone} tells that full-$\epsilon$ spatio-temporal cones, with a constrain that the line segment $\vv{P_sP_{s+i}}$ passes through the common intersection of all the preview full cones can also be used in trajectory simplification and/or tracking. 

\begin{theorem}
	\label{theo-cone-vs}
	Given a sub-trajectory $[P_s,...,P_{s+k}]$ and an error bound $\epsilon$, if $\bigsqcap_{i=1}^{k}$\cone{(P_s, P_{s+i}, \epsilon/2)} $\ne \{P_s\}$, then for each $i \in [2, k]$, line segment $\vv{P_sP_{s+i}}$ passes through $\bigsqcap_{j=1}^{i-1}$\cone{(P_s, P_{s+j}, \epsilon)}-$\{P_s\}$; and the opposite is not always true.
\end{theorem}

\begin{proof}
	\todo.
\end{proof}

Theorem \ref{theo-cone-vs} tells that the full-$\epsilon$ cone approach brings a better effectiveness than the half-$\epsilon$ cone, which is in turn better than \ldrh, in trajectory simplification and/or tracking. Thus, we will use the full-$\epsilon$ cones to develop trajectory tracking algorithms.
%as shown in Proposition \ref{theo-ldrh-cised}

\subsection{Implementation}
We then provide a one-pass trajectory tracking algorithm based on spatio-temporal cone, named \underline{C}one \underline{I}ntersection for \underline{T}rajectory \underline{T}racking (\citt). This algorithm runs on mobile devices and uses full-$\epsilon$ cones to check the distance deviations. In a nutshell, it first initializes its velocity $\vv{v}$ (including value and direction) and sends it coupling with a start position $P_s$ to the MOD server. Then it iteratively checks the deviation of its actual position $P_{s+k}$ to its synchronized point $P'_{s+k}$ built from the start point $P_s$, velocity $\vv{v}$ and time $P_{s+k}.t$, as well as the common intersection of spatio-temporal cones built from points $P_{s+i}$, $i \in [1, k]$. If the deviation is lager than a given threshold or the common intersection except $P_s$ is null, then \textcolor{red}{an update} is sent to the MOD server. Note that like \cised, this algorithm also transforms the intersection of cones to the intersection of regular polygons.


\stitle{Algorithm \citt}.
%We now present algorithm \citt.
As shown in Figure~\ref{alg:citt-s-full}, it takes as input a trajectory \trajec{T}${[P_0, \ldots, P_n]}$, an error bound $\epsilon$ and the number $m$ of edges for inscribed regular polygons, and outputs a set of velocities and a simplified  trajectory $\overline{\mathcal{T}}$ of $\dddot{\mathcal{T}}$.

The algorithm first initializes the start point $P_s$ to $P_0$, the common intersection of polygons $\mathcal{R}^*$ to \textcolor{red}{$\emptyset$} and the expected velocity $(|\vv{v}|, \vv{v}.\theta)$ to ($\frac{|P_{s}P_{s+1}|}{P_{s+1}.t-P_s.t},\vv{P_{s}P_{s+1}}.\theta$) (lines 1--2), then it sends its initial location $P_s$ and the velocity $\vv{v}$ to the MOD server (line 3), meaning that it is supposed to move from point $P_s$ along the direction of $\vv{v}.\theta$ at a speed of $|\vv{v}|$.
%, such that the expecting position of the object at time $t>P_s.t$ can be extrapolated from them as long as no subsequent update is sent to the MOD server.

The algorithm sequentially processes the rest points of the trajectory one by one (lines 4--15). 
For the current point $P_{i}$, if $\vv{P_sP_{i}}$ passes through the common intersection $\mathcal{R}^*$, meaning that it can not includes more points into a line segment, then a line segment $\vv{P_sP_{i-1}}$ and a new section started from  $P_{i-1}$ is generated, and $P_{i-1}$ and a new velocity $\vv{v}$ are sent to the MOD server (lines 6--9).
%
Otherwise, it calculates the distance from the actual location $P_{i}$ to the expecting location $P'_{i}$ extrapolated from the initial location $P_s$ and the velocity $\vv{v}$, and checks whether $\vv{P_sP_{i}}$ passes through the common intersection $\mathcal{R}^*$ of preview points.
If it passes through and the distance $|P_{i}P'_{i}|<\epsilon$, meaning that more points can be included into a line segment while the velocity $\vv{v}$ needs to be updated. Hence, it updates velocity $\vv{v}$ based on $P_s$ and $P_{i}$, and sends it to the MOD server (lines 10--12). 
%
Anyway, the algorithm gets the $m$-edge inscribed regular polygon \wrt the current point $P_{i}$ by calling procedure $\kw{getRegularPolygon}$ \cite{Lin:Cised} and gets the common intersection $\mathcal{R}^*$ of the preview cones (lines 13--14). The process repeats until all points have been processed (line 15).
At last, it outputs the last point $P_{n}$ (line 16).




\begin{figure}[tb!]   % full cones
		\begin{center}
			{\small
				\begin{minipage}{3.3in}
					\myhrule
					%\vspace{-1ex}
					\mat{0ex}{
						{\bf Algorithm}~\citt $(\dddot{\mathcal{T}}[P_0,\ldots,P_n],~\epsilon,~m)$\\
						%	\sstab
						\bcc \hspace{1ex}\= $P_s := P_0$; ~~~~$\mathcal{R}^*$ := \kw{getRegularPolygon}($P_s$, $P_{s+1}$, $\epsilon$, $m$, $P_{s+1}.t$); \\
						\icc \hspace{1ex}\= $|\vv{v}|:=\frac{|P_{s}P_{s+1}|}{P_{s+1}.t-P_s.t}$; ~~~~$\vv{v}.\theta:=\vv{P_{s}P_{s+1}}.\theta$; \\
						\icc \hspace{1ex}\= update ($P_{s}, \vv{v}$); \\
						\icc \hspace{1ex}\= $i := 2$; 	\\
						\icc \hspace{1ex}\= while $i \le n$ do \\
						\icc \>\hspace{3ex} if $\vv{P_sP_{i}}$ does not pass through $\mathcal{R}^*$ then \\ % // updates velocity and location \\
						\icc \>\hspace{7ex}    $P_s := P_{i-1}$; ~~~~$\mathcal{R}^*$ := $\emptyset$; \\
						\icc \>\hspace{7ex}    $|\vv{v}|:=\frac{|P_{s}P_{i}|}{P_{i}.t-P_s.t}$; ~~~~~$\vv{v}.\theta:=\vv{P_{s}P_{i}}.\theta$; \\
						\icc \>\hspace{7ex}    update ($P_{s}, \vv{v}$); \\
						\icc \>\hspace{3ex} else if $\vv{P_sP_{i}}$ passes through $\mathcal{R}^*$ ~and~ $sed(P_{i},\vv{v}) \ge \epsilon $ then  \\ %~// updates velocity only 
						\icc \>\hspace{7ex}    $|\vv{v}|:=\frac{|P_sP_{i}|}{P_{i}.t-P_s.t}$; ~~~~~$\vv{v}.\theta:=\vv{P_sP_{i}}.\theta$; \\
						\icc \>\hspace{7ex}    update ($\vv{v}$); \\
						\icc \>\hspace{3ex} if $\mathcal{R}^*=\emptyset$ then $\mathcal{R}^*:=$ \kw{getRegularPolygon}($P_s$, $P_{i}$, $\epsilon$, $m$, $P_{s+1}.t$); \\
						\icc \>\hspace{3ex} else $\mathcal{R}^*$ := $\mathcal{R}^*\bigsqcap$ \kw{getRegularPolygon}($P_s$, $P_{i}$, $\epsilon$, $m$, $P_{s+1}.t$); \\
						\icc \>\hspace{3ex} $i$ := $i +1$;	\\
						\icc \>\hspace{0ex} update ($P_{n}$); 
					}
					\vspace{-2ex}
					\myhrule
				\end{minipage}
			}
		\end{center}
		\vspace{-1ex}
		\caption{\small Trajectory tracking based on spatio-temporal cone.}
		\label{alg:citt-s-full}
		\vspace{-1ex}
	\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\eat{ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% delete, half cones
\begin{figure}[tb!]
	\begin{center}
		{\small
			\begin{minipage}{3.3in}
				\myhrule
				%\vspace{-1ex}
				\mat{0ex}{
					{\bf Algorithm}~\citt $(\dddot{\mathcal{T}}[P_0,\ldots,P_n],~\epsilon,~m)$\\
					%	\sstab
					\bcc \hspace{1ex}\= $P_s := P_0$; ~$\mathcal{R}^* := \emptyset$;~~~~// $\mathcal{R}^*$ saves the common intersection of polygons \\
					\icc \hspace{1ex}\= $i := 1$; ~$t_c$ := $P_1.t$;\\
					\icc \hspace{1ex}\= $|\vv{v}|:=\frac{|P_i-P_s|}{P_i.t-P_s.t}$; ~$\vv{v}.\theta:=\vv{|P_i-P_s|}.\theta$; \\
					\icc \hspace{1ex}\= update ($P_{s}, \vv{v}$); \\
					\icc \hspace{1ex}\= while $i \le n$ do \\
					\icc \>\hspace{3ex} $\mathcal{R}$ := \kw{getRegularPolygon}($P_s$, $P_i$, $\epsilon/2$, $m$, $t_c$); \\
					\icc \>\hspace{3ex} if $\mathcal{R}^* = \emptyset$  then $\mathcal{R}^* :=\mathcal{R};$ \\
					\icc \>\hspace{3ex} else $\mathcal{R}^*$ := \kw{getIntersection}$(\mathcal{R}^*, ~\mathcal{R})$; \\
					\icc \>\hspace{3ex} if $\mathcal{R}^* = \emptyset$ then  // updates velocity and location \\
					\icc \>\hspace{7ex}    $P_s := P_{i-1}$; \\
					\icc \>\hspace{7ex}    $|\vv{v}|:=\frac{|P_{i}-P_s|}{P_{i}.t-P_s.t}$; ~$\vv{v}.\theta:=\vv{|P_{i}-P_s|}.\theta$; \\
					\icc \>\hspace{7ex}    update ($P_{s}, \vv{v}$); \\
					\icc \>\hspace{7ex}    $t_c$ := $P_{i}.t$; ~$i$ := $i - 1$;		\\
					\icc \>\hspace{3ex} else if $\mathcal{R}^* \ne \emptyset$ ~and~ $|P_iP'_i| \ge \epsilon/2 $ then   ~// updates velocity \\
					\icc \>\hspace{7ex}    $|\vv{v}|:=\frac{|P_i-P_s|}{P_i.t-P_s.t}$; ~$\vv{v}.\theta:=\vv{|P_i-P_s|}.\theta$; \\
					\icc \>\hspace{7ex}    update ($\vv{v}$); \\
					\icc \>\hspace{3ex} $i$ := $i +1$;	\\
					\icc \>\hspace{0ex} update ($P_{n}$); 
				}
				\vspace{-2ex}
				\myhrule
			\end{minipage}
		}
	\end{center}
	\vspace{-1ex}
	\caption{\small Trajectory tracking based on cone intersection (half-$\epsilon$).}
	\label{alg:citt-s-half}
	\vspace{-1ex}
\end{figure}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{example}
	\todo.
\end{example}


\stitle{Correctness and complexity.} 
\todo{correctness.}
Every point is processed only once in \citt, and for each point, it needs $O(1)$ time as getRegularPolygon(), update(), intersecting of polygons and other operations all have a time complexity of $O(1)$. Hence, \citt has a time complexity of $O(n)$, where $n$ is the number of data points.






\eat{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
\subsection{Extension from half-$\epsilon$ cone to full-$\epsilon$ cone}


\stitle{Algorithm \cittsf()}.

\begin{example}
\todo.
\end{example}	

\stitle{Correctness and complexity.} 


\subsection{Weak tracking}

-- theorem: if ldr is true, then the intersection of those cones must not be \{$P_s$\}.
means that, if ldr is true, it is sure those points can be represented by a line segment.
thus, we only need to check the intersection after ldr is false, during the process.

-- algorithm CITT-W(e)

-- example

-- correctness and complexity
}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
