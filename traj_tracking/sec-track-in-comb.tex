
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "www2019"
%%% End:

\section{Tracking in a rectangle-like area}
\label{sec:rectangle}

This section develops an effective and efficient way to track a moving object in a rectangle-like area. Note that though it is possible to do a tracking in a rectangular area, however, it is really hard to design such a shape and at the same time develop such an efficient algorithm. Thus, we alternatively define a rectangle-like area.


\subsection{Building the rectangle-like areas}

Like the circular area related to \sed and the strip area related to \ped, a rectangle-like area is also related to a Euclidean distance metric, namely the binary Euclidean distances of \sed and \ped.

\stitle{Binary Euclidean distances of \sed and \ped}, shortly \bed (\sed, \ped), is the combination of distance metrics \sed and \ped where their error bounds are set separately to $\epsilon_{sed}$ and $\epsilon_{ped}$, such that (1) if $\epsilon_{ped} \ge \epsilon_{sed}$, then it falls back to the \sed, \ie tracking in a circular area, otherwise, (2) it is the double effects of \ped and \sed, and forms a rectangle-like shape whose short sides are replaced by circular arcs of \sed as shown in {Figure~\ref{fig:areas}-(3)}. Note that if $\epsilon_{ped} << \epsilon_{sed}$, then its effect is actually approximate to a \ped.

%By combining \sed and \ped, we get a 
The shape of a rectangle-like area is controlled by two independent parameters, $\epsilon_{ped}$ and $\epsilon_{sed}$, thus, by carefully setting them, we not only build such rectangle-line areas that satisfy the needs of varied applications but also balance two performance metrics, the compression ratios and the errors of spatio-temporal queries, of trajectory simplification/tracking algorithms. 
For the same example of ``the school boy on his way home" mentioned in Section \ref{sec-intro}, if we only use \ped, then we get a simplified trajectory having a good compression ratio and a unbounded query error; if we only use \sed, then we get a poorer compression ratio and a bounded query error. However, if we combine them, \ie~use the \bed, then we could get a medium compression ratio and a bounded query error.



\subsection{Tracking by cone and sector}

\begin{theorem}
	\label{theo-binary}
	Given a sub-trajectory $[P_s,...,P_{s+k}]$ and two error bounds $\epsilon_{sed}$ and $\epsilon_{ped}$, it can be tracked in rectangle-like areas by combining sectors and spatio-temporal cones.
\end{theorem}


\todo{Could ``$|P_sP_{i}| \le l_{m} - \epsilon$" be replaced by a more relaxed constrain, by benefiting from \sed?}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Algorithm: Traj tracking based on section intersection using full sectors.
\begin{figure}[tb!]   
	\begin{center}
		{\small
			\begin{minipage}{3.3in}
				\myhrule
				%\vspace{-1ex}
				\mat{0ex}{
					{\bf Algorithm}~\bitt $(\dddot{\mathcal{T}}[P_0,\ldots,P_n], ~\epsilon_{sed}, m, ~\epsilon_{ped})$\\
					%	\sstab
					\bcc \hspace{1ex}\= $P_s := P_0$; ~~~~$\mathcal{R}^*$ := \kw{getRPolygon}($P_s$, $P_{s+1}$, $\epsilon_{sed}$, $m$, $P_{s+1}.t$); \\
					\icc \hspace{1ex}\= $\mathcal{S}^*$ := \kw{getSector}($P_s$, $P_{s+1}$, $\epsilon_{ped}$); ~~~~$l_{m} = |P_sP_{s+1}|$;\\
					\icc \hspace{1ex}\= $|\vv{v}|:=\frac{|P_{s}P_{s+1}|}{P_{s+1}.t-P_s.t}$; ~~~~$\vv{v}.\theta:=\overline{P_{s}P_{s+1}}.\theta$;  \\
					\icc \hspace{1ex}\= update ($P_{s}, \vv{v}$); 	\\
					\icc \hspace{1ex}\= $i:= 2$;  	\\
					\icc \hspace{1ex}\= while $i \le n$ do \\
					\icc \>\hspace{3ex} if $\overline{P_sP_{i}}$ ~does not pass~ $\mathcal{S}^*~or~\mathcal{R}^*$, or $|P_sP_{i}| \le l_{m} - \epsilon$ then \\ % // updates velocity and location \\
					\icc \>\hspace{7ex}    $P_s := P_{i-1}$; ~~~~$\mathcal{R}^*$ := $\emptyset$;~~~~$\mathcal{S}^*$ := $\emptyset$; ~~~~$l_{m} = |P_sP_{i}|$;\\
					\icc \>\hspace{7ex}    $|\vv{v}|:=\frac{|P_sP_{i}|}{P_{i}.t-P_s.t}$; ~~~~$\vv{v}.\theta:=\overline{P_{s}P_{i}}.\theta$;  \\
					\icc \>\hspace{7ex}    update ($P_{s}, \vv{v}$); 	\\
					\icc \>\hspace{3ex} else if $ped(P_i, \vv{v}) \ge \epsilon_{ped}$ ~or~ $sed(P_i, \vv{v}) \ge \epsilon_{sed}$ then  \\ %$\overline{P_sP_{i}}$ ~passes ~ $\mathcal{R}^*$ and $\mathcal{S}^*$, $|P_sP_{i}| > l_{m} - \epsilon$ \\ \hspace{9ex} ~and~
					\icc \>\hspace{7ex}    $|\vv{v}|:=\frac{|P_sP_{i}|}{P_{i}.t-P_s.t}$; ~~~~$\vv{v}.\theta:=\overline{P_sP_{i}}.\theta$; \\
					\icc \>\hspace{7ex}    update ($\vv{v}$); \\
					\icc \>\hspace{3ex} if $\mathcal{S}^*=\emptyset$ then $\mathcal{R}^*:=$ \kw{getRPolygon}($P_s$, $P_{i}$, $\epsilon_{sed}$, $m$, $P_{s+1}.t$); \\
					\icc \>\hspace{7ex}    $\mathcal{S}^*:=$ \kw{getSector}($P_s$, $P_{i}$, $\epsilon_{ped}$); \\
					\icc \>\hspace{3ex} else $\mathcal{R}^*:=$ \kw{getRPolygon}($P_s$, $P_{i}$, $\epsilon_{sed}$, $m$, $P_{s+1}.t$); \\
					\icc \>\hspace{7ex}    $\mathcal{S}^*$ := $\mathcal{S}^*\bigsqcap$ \kw{getSector}($P_s$, $P_{i}$, $\epsilon_{ped}$); $l_{m} = \max\{|P_sP_{i}|, l_{m}\}$;\\
					\icc \>\hspace{3ex} $i$ := $i +1$;\\
					\icc \>\hspace{0ex} update ($P_{n}$); 
				}
				\vspace{-2ex}
				\myhrule
			\end{minipage}
		}
	\end{center}
	\vspace{-1ex}
	\caption{\small Trajectory tracking based on sector and cone.}
	\label{alg:bitt}
	\vspace{-1ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Implementation.}
We now present the algorithm of \underline{B}inary \underline{I}ntersection for \underline{T}rajectory \underline{T}racking (BITT) that tracks moving objects in combined areas of circular and strip by \sed and \ped, as shown in Figure~\ref{alg:bitt}. 
%
Indeed, it is a double check of cone intersection and sector intersection for each point for the purpose of trajectory simplification, and a double check of \sed and \ped distance deviations for position tracking. In addition to that, it uses a uniform velocity $\vv{v}$ for both position tracks of \sed and \ped such that either deviation of \ped or \sed distance will cause an update of velocity $\vv{v}$. 
%
\bitt is the super version of \citt and \sitt, that is, if $\epsilon_{sed} >> \epsilon_{ped}$, then ``$\overline{P_sP_{i}}$ does not pass $\mathcal{R}^*$" of line 7 and ``$sed(P_i, \vv{v}) \ge \epsilon_{sed}$" of line 11 are always false, thus \bitt falls back to \sitt. \todo{Similarly, if $\epsilon_{sed} \le \epsilon_{ped}$, then it falls back to \citt.}

\begin{example}
Figure {\todo.} is a running example of \bitt. 
\end{example}



\stitle{Correctness and complexity.} 
The correctness of algorithm \bitt follows from Theorem \ref{theo-binary}.
It is also easy to find that it has a linear time complexity like \citt and \sitt.

\eat{%%%%%%%%%%%%
weak tracking

-- principle, adjust velocity...
	must checking \textcolor{blue}{consistently} of cone, sector and interval, couple with ldr.
	if the common intersection of all metrics is false, then new line segment.
	otherwise, checks ldr, 	if any ldr is false, then adjust velocity, point select from the common area.
	
-- algorithm. intersection based trajectory tracking (ITT-W)

-- example

-- correctness and complexity
}%%%%%%%%%%%%eat

\stitle{Discuss.} Relations to position tracking and traj simplification. 
