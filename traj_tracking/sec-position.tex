\section{Effective one-pass tracking in circular areas}
\label{sec:circular}

\ldrh is an efficient trajectory tracking algorithm but suffer in effectiveness (compression ratios).
Observing one-pass algorithms, \cised using \sed, having low time complexity and good compression ratios, this inspires us to develop an efficient as well as effective trajectory tracking algorithm.

\subsection{Tracking by spatio-temporal cone}
\cised \cite{Lin:Cised} is a one-pass trajectory simplification algorithm using \sed, using a local synchronous distance checking approach based on a concept of spatio-temporal cone, defined in a 3D Cartesian coordinate system whose $x$-axis, $y$-axis and $t$-axis are longitude, latitude and time, respectively, that converts the \sed distance tolerance into the intersection of cones for testing the successive points.




\stitle{Spatio-temporal cones (\cone{}) \cite{Lin:Cised}}. 
Given a start point $P_s$ of sub-trajectory $\dddot{\mathcal{T}}_s[P_s, \ldots, P_{s+k}]$ and an error bound $\epsilon$, the spatio-temporal cone (or simply \textit{cone}) of a data point $P_{s+i}$ ($1\le i\le k$) in $\dddot{\mathcal{T}_s}$ \wrt $P_s$ and $\epsilon$, denoted as \cone{(P_s, P_{s+i}, \epsilon)}, or \cone{_{s+i}} in short, is an oblique circular cone such that point $P_s$ is its apex and the synchronous circle $\mathcal{O}(P_{s+i}, \epsilon)$ of point $P_{s+i}$, or \circle{_{s+i}} in short, a circle on the plane $P.t-P_{s+i}.t = 0$ such that $P_{s+i}$ is its center and $\epsilon$ is its radius, is its base.


\begin{example}
	\label{exm-circles-cones}
	Figure~\ref{fig:cis} shows 
	(1) two synchronous circles, \circle{(P_{s+i}, \epsilon)} of point $P_{s+i}$ and \circle{(P_{s+k}, \epsilon)} of point $P_{s+k}$.
	It is easy to see that for any point in the area of a circle \circle{(P_{s+i}, \epsilon)}, its distance to $P_{s+i}$ is not greater than $\epsilon$, 
	and (2) two example spatio-temporal cones, \cone{(P_s, P_{s+i}, \epsilon)} {(purple)} and \cone{(P_s, P_{s+k}, \epsilon)} (red), with the same apex $P_s$ and error bound $\epsilon$. %\eop
\end{example}

%Note that in this definition, a \emph{synchronous circle} $\mathcal{O}(P_i, \epsilon)$ is only defined by a central point $P_i$ and a constant $\epsilon$. Indeed, it is nothing to do with any start point $P_s$ or end point $P_e$.


%\textcolor{blue}{We define \textit{synchronous circles and Spatio-temporal cones} in a \emph{x-y-t} 3D coordinate system, and build the connection between \textit{synchronous circles} and \textit{synchronous distances}.}



\begin{figure}[tb!]
	\centering
	\includegraphics[scale=0.66]{figures/Fig-CIS.png}
	%	\vspace{-1ex}
	\caption{\small Examples of spatio-temporal cones in a 3D Cartesian coordinate system taking point $P_s$ as the origin, where (1) $P_{s+i}$ and $P_{s+k}$ are two points, (2) \circle{_{s+i}} and \circle{_{s+k}} are two synchronous circles, (3) \cone{_{s+i}} and \cone{_{s+k}} are two spatio-temporal cones, (4) $Q$ is a point in synchronous circle \circle{_{s+k}}, and (5) $P'_{s+i}$ is the intersection point of line $\protect\vv{P_sQ}$ and synchronous circle \circle{_{s+i}}.}
	%\vspace{-1ex}
	\label{fig:cis}
\end{figure}


\cite{Lin:Cised} proves that the \sed distance tolerance can be checked by finding the common intersection of spatio-temporal cones, \ie~\emph{given a sub-trajectory $[P_s,...,P_{s+k}]$ and an error bound $\epsilon$, $sed(P_{s+i}, \vv{P_sP_{s+k}})\le \epsilon$ for each $i \in [1,k]$ if  $\bigsqcap_{i=1}^{k}$\cone{(P_s, P_{s+i}, \epsilon/2)} $\ne \{P_s\}$}.
It also projects the cones on a plane so as to convert the checking of cones intersection into a much simpler way, \ie the checking of circles intersection on the plane. Finally a one-pass trajectory simplification algorithm \cised is developed based on the spatio-temporal cone intersection. 

%We next show that the cones intersection approach is much more effective than the policy used in \ldrh. Actually, the latter is just a special case of the former.

\begin{theorem}
\label{theo-ldrh-cised}
Given a sub-trajectory $\dddot{\mathcal{T}}_s[P_s,...,P_{s+k}]$, an error bound $\epsilon$ and a velocity $\vv{v}$, if $\dddot{\mathcal{T}}_s$ can be represented by line segment $\vv{P_sP_{s+k}}$ through algorithm \ldrh, then it can also be represented by the line segment through algorithm \cised.
\end{theorem}

\begin{proof}
\todo{1. $\vv{v}$ in 3D space; 2...}

if $|P_{s+i}P'_{s+i}|\le \epsilon/2$ for each $i \in [1,k]$, then $\vv{v}$ must live in the common intersection of half-$\epsilon$ cones $\bigsqcap_{i=1}^{k}$\cone{(P_s, P_{s+i}, \epsilon/2)}, where $P'_{s+i}$ is the synchronized point of $P_{s+i}$ \wrt $\vv{v}$.
\end{proof}

Theorem \ref{theo-ldrh-cised} tells that \ldrh is a special case of, and has worse effective than, \cised. Hence, the spatio-temporal cone intersection is a better way to develop a one-pass trajectory tracking algorithm. 
%
We next present two trajectory tracking algorithms, strong tracking and weak tracking, based on spatio-temporal cones.


\subsection{Strong tracking}

We now present a {\em trajectory tracking} approach based on spatio-temporal cones, including two variations, algorithms \cittsh using half-$\epsilon$ cones and \cittsf using full-$\epsilon$ cones. These algorithms share a similar routine, in a nutshell, a moving object first initializes its velocity $\vv{v}$ (including value and direction) and sends it coupling with a start position $P_s$ to the MOD server. Then it iteratively checks the deviation of its actual position $P_{s+k}$ to its synchronized point $P'_{s+k}$ built from the start point $P_s$, velocity $\vv{v}$ and time $P_{s+k}.t$, as well as the common intersection of spatio-temporal cones built from points $P_{s+i}$, $i \in [1, k]$. If the deviation is lager than a given threshold or the common intersection except $P_s$ is null, then an update is sent to the MOD server.


\stitle{Algorithm \cittsh()}.
%We now present algorithm \cist.
It is an extension of \ldrh that uses half-$\epsilon$ cones to check the distance deviations. As shown in Figure~\ref{alg:citt-s-half}, it takes as input a trajectory \trajec{T}${[P_0, \ldots, P_n]}$, an error bound $\epsilon$ and the number $m$ of edges for inscribed regular polygons, and outputs a simplified  trajectory $\overline{\mathcal{T}}$ of $\dddot{\mathcal{T}}$ and a set of velocities.



The algorithm first initializes the start point $P_s$ to $P_0$, the index $i$ of the current data point to $1$, the intersection polygon $\mathcal{R}^*$ to $\emptyset$, the output $\overline{\mathcal{T}}$ to $\emptyset$, and $t_c$ to $P_1.t$, respectively (line 1).

It sends its initial location $P_s$ and the expected velocity $\vv{v}$ to the MOD server, still meaning that it will move from $P_s$ along the direction of $\vv{v}$ at a speed of $|\vv{v}|$, such that the expecting position of the object at time $t>P_s.t$ can be extrapolated from them as long as no subsequent update is sent to the MOD server.


The algorithm sequentially processes the data points of the trajectory one by one  (lines 2--10). 

For the current point $P$, it gets the $m$-edge inscribed regular polygon \wrt the current point $P_i$ (line 3) by calling procedure $\kw{getRegularPolygon}$. 

it compares the actual location of the time with the expecting location of time $t$ extrapolated from the initial location $P_s$ and the velocity $\vv{v}$. 

If its actual location at a given time $t$ does not deviate by more than $\epsilon/2$ from the expecting location $P$ of $t$, then the algorithm goes on to process the next point, otherwise, 
it computes the common intersection of cones built from those points, if the common intersection is not null, 

When $\mathcal{R}^* = \emptyset$, the intersection polygon $\mathcal{R}^*$ is simply initialized as $\mathcal{R}$ (lines 4, 5). Otherwise,
$\mathcal{R}^*$ is  the intersection of the current regular polygon $\mathcal{R}$ with $\mathcal{R}^*$ (line 7). If the resulting intersection $\mathcal{R}^*$ is empty, then a new line segment $\vv{P_sP_{i-1}}$ is generated (lines 8--10). then an update of velocity $\vv{v}$ will be sent while the start point is still the start point $P_s$,

 otherwise, other update of (start point $P_{s+k-1}$, velocity $\vv{v}$) will be sent, meaning a new tracking started from $P_{s+k-1}$ is triggered.


The process repeats until all points have been processed (line 11).
After the  final line segment $\vv{P_sP_{n}}$ is generated (line 12), it returns the simplified  piece-wise line representation $\overline{\mathcal{T}}$ (line 13).





%%%%%%%%%%%%%%%%%%%%%algorithm
\begin{figure}[tb!]
	\begin{center}
		{\small
			\begin{minipage}{3.3in}
				\myhrule
				%\vspace{-1ex}
				\mat{0ex}{
					{\bf Algorithm}~\cittsh$(\dddot{\mathcal{T}}[P_0,\ldots,P_n],~\epsilon,~m)$\\
					%	\sstab
					\bcc \hspace{1ex}\= $P_s := P_0$; ~$i := 1$;  ~$\mathcal{R}^* := \emptyset$;  ~$\overline{\mathcal{T}} := \emptyset$; ~$t_c$ := $P_1.t$;\\
					\icc \hspace{1ex}\= while $i \le n$ do \\
					\icc \>\hspace{2ex} $\mathcal{R}$ := \kw{getRegularPolygon}($P_s$, $P_i$, $\epsilon/2$, $m$, $t_c$); \\
					\icc \>\hspace{2ex} if $\mathcal{R}^* = \emptyset$  then \hspace{3ex} /* $\mathcal{R}^*$ needs to be initialized */\\
					\icc \>\hspace{2ex} \ \ \ $\mathcal{R}^* :=\mathcal{R};$ \\
					\icc \>\hspace{2ex} else \\
					\icc \>\hspace{2ex}\ \ \ \ $\mathcal{R}^*$ := \kw{getIntersection}$(\mathcal{R}^*, ~\mathcal{R})$; \\
					\icc \>\hspace{4ex} if $\mathcal{R}^* = \emptyset$ then \hspace{1ex} /* generate a new line segment */\\
					\icc \> \hspace{4ex} \ \ \ $i$ := $i - 1$;\ \ $\overline{\mathcal{T}} := \overline{\mathcal{T}}\cup \{\vv{P_sP_{i}}\}$; \\
					\icc \> \hspace{4ex} \ \ \ $P_s := P_{i}$; \ \ $t_c$ := $P_{i+1}.t$;\\
					\icc \>\hspace{2ex} $i$ := $i +1$;\\
					\icc \> \hspace{0ex} $\overline{\mathcal{T}}$ := $\overline{\mathcal{T}}\cup \{\vv{P_sP_{n}}\}$; \\
					\icc \hspace{1ex} return $\overline{\mathcal{T}}$. \\
				}
				\vspace{-2ex}
				\myhrule
			\end{minipage}
		}
	\end{center}
	\vspace{-1ex}
	\caption{\small One-pass strong trajectory  simplification algorithm.}
	\label{alg:citt-s-half}
	\vspace{-1ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%









-- example

-- correctness and complexity

------------------------------

--- extend from half cone to full cone

-- full cone with constraint: theory and proof

-- algorithm CITT-S(e)

-- example

\subsection{Weak tracking}

-- theorem: if ldr is true, then the intersection of those cones must not be \{$P_s$\}.
means that, if ldr is true, it is sure those points can be represented by a line segment.
thus, we only need to check the intersection after ldr is false, during the process.

-- algorithm CITT-W(e)

-- example

-- correctness and complexity

