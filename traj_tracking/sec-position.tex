\section{Effective one-pass tracking in circular areas}
\label{sec:circular}

\ldrh is an efficient trajectory tracking algorithm but suffer in effectiveness (compression ratios).
Observing one-pass algorithms, \cised using \sed, having low time complexity and good compression ratios, this inspires us to develop an efficient as well as effective trajectory tracking algorithm.

\subsection{Tracking by spatio-temporal cone}
\cised \cite{Lin:Cised} is a one-pass trajectory simplification algorithm using \sed, using a local synchronous distance checking approach based on a concept of spatio-temporal cone, defined in a 3D Cartesian coordinate system whose $x$-axis, $y$-axis and $t$-axis are longitude, latitude and time, respectively, that converts the \sed distance tolerance into the intersection of cones for testing the successive points.




\stitle{Spatio-temporal cones (\cone{}) \cite{Lin:Cised}}. 
Given a start point $P_s$ of sub-trajectory $\dddot{\mathcal{T}}_s[P_s, \ldots, P_{s+k}]$ and an error bound $\epsilon$, the spatio-temporal cone (or simply \textit{cone}) of a data point $P_{s+i}$ ($1\le i\le k$) in $\dddot{\mathcal{T}_s}$ \wrt $P_s$ and $\epsilon$, denoted as \cone{(P_s, P_{s+i}, \epsilon)}, or \cone{_{s+i}} in short, is an oblique circular cone such that point $P_s$ is its apex and the synchronous circle $\mathcal{O}(P_{s+i}, \epsilon)$ of point $P_{s+i}$, or \circle{_{s+i}} in short, a circle on the plane $P.t-P_{s+i}.t = 0$ such that $P_{s+i}$ is its center and $\epsilon$ is its radius, is its base.


\begin{example}
	\label{exm-circles-cones}
	Figure~\ref{fig:cis} shows 
	(1) two synchronous circles, \circle{(P_{s+i}, \epsilon)} of point $P_{s+i}$ and \circle{(P_{s+k}, \epsilon)} of point $P_{s+k}$.
	It is easy to see that for any point in the area of a circle \circle{(P_{s+i}, \epsilon)}, its distance to $P_{s+i}$ is not greater than $\epsilon$, 
	and (2) two example spatio-temporal cones, \cone{(P_s, P_{s+i}, \epsilon)} {(purple)} and \cone{(P_s, P_{s+k}, \epsilon)} (red), with the same apex $P_s$ and error bound $\epsilon$. %\eop
\end{example}

%Note that in this definition, a \emph{synchronous circle} $\mathcal{O}(P_i, \epsilon)$ is only defined by a central point $P_i$ and a constant $\epsilon$. Indeed, it is nothing to do with any start point $P_s$ or end point $P_e$.


%\textcolor{blue}{We define \textit{synchronous circles and Spatio-temporal cones} in a \emph{x-y-t} 3D coordinate system, and build the connection between \textit{synchronous circles} and \textit{synchronous distances}.}



\begin{figure}[tb!]
	\centering
	\includegraphics[scale=0.66]{figures/Fig-CIS.png}
	%	\vspace{-1ex}
	\caption{\small Examples of spatio-temporal cones in a 3D Cartesian coordinate system taking point $P_s$ as the origin, where (1) $P_{s+i}$ and $P_{s+k}$ are two points, (2) \circle{_{s+i}} and \circle{_{s+k}} are two synchronous circles, (3) \cone{_{s+i}} and \cone{_{s+k}} are two spatio-temporal cones, (4) $Q$ is a point in synchronous circle \circle{_{s+k}}, and (5) $P'_{s+i}$ is the intersection point of line $\protect\vv{P_sQ}$ and synchronous circle \circle{_{s+i}}.}
	%\vspace{-1ex}
	\label{fig:cis}
\end{figure}




\begin{proposition}
\label{theo-half-cone}
{Given a sub-trajectory $[P_s,...,P_{s+k}]$ and an error bound $\epsilon$, $sed(P_{s+i}, \vv{P_sP_{s+k}})\le \epsilon$ for each $i \in [1,k]$ if  $\bigsqcap_{i=1}^{k}$\cone{(P_s, P_{s+i}, \epsilon/2)} $\ne \{P_s\}$} \cite{Lin:Cised}.
\end{proposition}

Proposition \ref{theo-half-cone} tells that the \sed distance tolerance can be checked by finding the common intersection of spatio-temporal cones (half-$\epsilon$), and it serves as the foundation of a one-pass trajectory simplification algorithm \cised~\cite{Lin:Cised}. And for efficiency consideration, \cised projects the cones on a plane so as to convert the checking of cones intersection into a much simpler way, \ie the checking of circles intersection on the plane. For the same reason, a circle is approximated by its inscribe regular polygon and the intersecting of circles is approximated by the intersecting of these polygons.

%We next show that the cones intersection approach is much more effective than the policy used in \ldrh. Actually, the latter is just a special case of the former.

\begin{proposition}
\label{theo-ldrh-cised}
Given a sub-trajectory $\dddot{\mathcal{T}}_s[P_s,...,P_{s+k}]$, an error bound $\epsilon$ and a velocity $\vv{v}$, if $\dddot{\mathcal{T}}_s$ can be represented by line segment $\vv{P_sP_{s+k}}$ through algorithm \ldrh, then it can also be represented by approaches based on spatio-temporal cones.
\end{proposition}

\begin{proof}
\todo{1. $\vv{v}$ in 3D space; 2...}

If $|P_{s+i}P'_{s+i}|\le \epsilon/2$ for each $i \in [1,k]$, then $\vv{v}$ must live in the common intersection of half-$\epsilon$ cones $\bigsqcap_{i=1}^{k}$\cone{(P_s, P_{s+i}, \epsilon/2)}, where $P'_{s+i}$ is the synchronized point of $P_{s+i}$ \wrt $\vv{v}$.
\end{proof}

Proposition \ref{theo-ldrh-cised} tells that \ldrh is a special case of, and has worse effective than, approaches based on spatio-temporal cones. Hence, the latter is a more effective way to develop one-pass trajectory tracking algorithms. 
Note the half-$\epsilon$ cone in the above is still a little conservative, and it can be extended to a full-$\epsilon$ cone with some constrains to get a better effectiveness.


\begin{proposition}
	\label{theo-full-cone}
	Given a sub-trajectory $[P_s,...,P_{s+k}]$ and an error bound $\epsilon$, $sed(P_{s+i}, \vv{P_sP_{s+k}})\le \epsilon$ for each $i \in [1,k]$ if $\vv{P_sP_{s+i}}$ passes through $\bigsqcap_{j=1}^{i-1}$\cone{(P_s, P_{s+j}, \epsilon)} - \{$P_s$\}.
\end{proposition}

\begin{proof}
	\todo.
\end{proof}

Proposition \ref{theo-full-cone} tells that full-$\epsilon$ cones, with a constrain that the line segment $\vv{P_sP_{s+i}}$ passes through the common intersection of the preview full cones other than the start point $P_s$, can also be used in trajectory simplification or tracking. 

\begin{proposition}
	\label{theo-cone-vs}
	Given a sub-trajectory $[P_s,...,P_{s+k}]$ and an error bound $\epsilon$, if $\bigsqcap_{i=1}^{k}$\cone{(P_s, P_{s+i}, \epsilon/2)} $\ne \{P_s\}$, then for each $i \in [2, k]$, line segment $\vv{P_sP_{s+i}}$ passes through $\bigsqcap_{j=1}^{i-1}$\cone{(P_s, P_{s+j}, \epsilon)}-$\{P_s\}$; and the opposite is not always true.
\end{proposition}

\begin{proof}
	\todo.
\end{proof}

Proposition \ref{theo-cone-vs} tells that the full-$\epsilon$ cones always bring a better effectiveness than the half-$\epsilon$ cones.

\subsection{Implementation}

We next present a {\em trajectory tracking} algorithm based on spatio-temporal cones. This algorithm runs on moving objects and uses full-$\epsilon$ cones to check the distance deviations. In a nutshell, it first initializes its velocity $\vv{v}$ (including value and direction) and sends it coupling with a start position $P_s$ to the MOD server. Then it iteratively checks the deviation of its actual position $P_{s+k}$ to its synchronized point $P'_{s+k}$ built from the start point $P_s$, velocity $\vv{v}$ and time $P_{s+k}.t$, as well as the common intersection of spatio-temporal cones built from points $P_{s+i}$, $i \in [1, k]$. If the deviation is lager than a given threshold or the common intersection except $P_s$ is null, then an update is sent to the MOD server. Note that like \cised, this algorithm also transforms the intersection of cones to the intersection of regular polygons.


\stitle{Algorithm \citt}.
%We now present algorithm \cist.
As shown in Figure~\ref{alg:citt-s-half}, it takes as input a trajectory \trajec{T}${[P_0, \ldots, P_n]}$, an error bound $\epsilon$ and the number $m$ of edges for inscribed regular polygons, and outputs a set of velocities and a simplified  trajectory $\overline{\mathcal{T}}$ of $\dddot{\mathcal{T}}$.

The algorithm first initializes the start point $P_s$ to $P_0$, the common intersection of polygons $\mathcal{R}^*$ to $\emptyset$ and the expected velocity $(|\vv{v}|, \vv{v}.\theta)$ to ($\frac{|P_{s}P_{s+1}|}{P_{s+1}.t-P_s.t},\vv{P_{s}P_{s+1}}.\theta$) (lines 1--2), then it sends its initial location $P_s$ and the velocity $\vv{v}$ to the MOD server (line 3), meaning that it is supposed to move from point $P_s$ along the direction of $\vv{v}.\theta$ at a speed of $|\vv{v}|$.
%, such that the expecting position of the object at time $t>P_s.t$ can be extrapolated from them as long as no subsequent update is sent to the MOD server.

The algorithm sequentially processes the rest points of the trajectory one by one (lines 4--15). 
For the current point $P_{s+i}$, if $\vv{P_sP_{s+i}}$ passes through the common intersection $\mathcal{R}^*$, meaning that it can not includes more points into a line segment, then a line segment $\vv{P_sP_{i-1}}$ and a new section started from  $P_{i-1}$ is generated, and $P_{i-1}$ and a new velocity $\vv{v}$ are sent to the MOD server (lines 6--9).
%
Otherwise, it calculates the distance from the actual location $P_{s+i}$ to the expecting location $P'_{s+i}$ extrapolated from the initial location $P_s$ and the velocity $\vv{v}$, and checks whether $\vv{P_sP_{s+i}}$ passes through the common intersection $\mathcal{R}^*$ of preview points.
If it passes through and the distance $|P_{s+i}P'_{s+i}|<\epsilon$, meaning that more points can be included into a line segment while the velocity $\vv{v}$ needs to be updated. Hence, it updates velocity $\vv{v}$ based on $P_s$ and $P_{s+i}$, and sends it to the MOD server (lines 10--12). 
%
Anyway, the algorithm gets the $m$-edge inscribed regular polygon \wrt the current point $P_{s+i}$ by calling procedure $\kw{getRegularPolygon}$ \cite{Lin:Cised} and gets the common intersection $\mathcal{R}^*$ of the preview cones (lines 13--14). The process repeats until all points have been processed (line 15).
At last, it outputs the last point $P_{n}$ (line 16).




	\begin{figure}[tb!]   % full cones
		\begin{center}
			{\small
				\begin{minipage}{3.3in}
					\myhrule
					%\vspace{-1ex}
					\mat{0ex}{
						{\bf Algorithm}~\citt $(\dddot{\mathcal{T}}[P_0,\ldots,P_n],~\epsilon,~m)$\\
						%	\sstab
						\bcc \hspace{1ex}\= $P_s := P_0$; ~~~~$\mathcal{R}^*$ := \kw{getRegularPolygon}($P_s$, $P_{s+1}$, $\epsilon$, $m$, $P_{s+1}.t$); \\
						\icc \hspace{1ex}\= $|\vv{v}|:=\frac{|P_{s}P_{s+1}|}{P_{s+1}.t-P_s.t}$; ~$\vv{v}.\theta:=\vv{P_{s}P_{s+1}}.\theta$; \\
						\icc \hspace{1ex}\= update ($P_{s}, \vv{v}$); \\
						\icc \hspace{1ex}\= $i := 2$; 	\\
						\icc \hspace{1ex}\= while $i \le n$ do \\
						\icc \>\hspace{3ex} if $\vv{P_sP_{s+i}}$ does not pass through $\mathcal{R}^*$ then \\ % // updates velocity and location \\
						\icc \>\hspace{7ex}    $P_s := P_{s+i-1}$; ~~~~$\mathcal{R}^*$ := $\emptyset$; \\
						\icc \>\hspace{7ex}    $|\vv{v}|:=\frac{|P_{s}P_{s+i}|}{P_{s+i}.t-P_s.t}$; ~$\vv{v}.\theta:=\vv{P_{s}P_{s+i}}.\theta$; \\
						\icc \>\hspace{7ex}    update ($P_{s}, \vv{v}$); \\
						\icc \>\hspace{3ex} else if $\vv{P_sP_{s+i}}$ passes through $\mathcal{R}^*$ ~and~ $|P_{s+i}P'_{s+i}| \ge \epsilon $ then  \\ %~// updates velocity only 
						\icc \>\hspace{7ex}    $|\vv{v}|:=\frac{|P_sP_{s+i}|}{P_{s+i}.t-P_s.t}$; ~$\vv{v}.\theta:=\vv{P_sP_{s+i}}.\theta$; \\
						\icc \>\hspace{7ex}    update ($\vv{v}$); \\
						\icc \>\hspace{3ex} if $\mathcal{R}^*=\emptyset$ then $\mathcal{R}^*:=$ \kw{getRegularPolygon}($P_s$, $P_{s+i}$, $\epsilon$, $m$, $P_{s+1}.t$); \\
						\icc \>\hspace{3ex} else $\mathcal{R}^*$ := $\mathcal{R}^*\bigsqcap$ \kw{getRegularPolygon}($P_s$, $P_{s+i}$, $\epsilon$, $m$, $P_{s+1}.t$); \\
						\icc \>\hspace{3ex} $i$ := $i +1$;	\\
						\icc \>\hspace{0ex} update ($P_{n}$); 
					}
					\vspace{-2ex}
					\myhrule
				\end{minipage}
			}
		\end{center}
		\vspace{-1ex}
		\caption{\small Trajectory tracking based on spatio-temporal cone.}
		\label{alg:citt-s-half}
		\vspace{-1ex}
	\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\eat{ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% delete, half cones
\begin{figure}[tb!]
	\begin{center}
		{\small
			\begin{minipage}{3.3in}
				\myhrule
				%\vspace{-1ex}
				\mat{0ex}{
					{\bf Algorithm}~\citt $(\dddot{\mathcal{T}}[P_0,\ldots,P_n],~\epsilon,~m)$\\
					%	\sstab
					\bcc \hspace{1ex}\= $P_s := P_0$; ~$\mathcal{R}^* := \emptyset$;~~~~// $\mathcal{R}^*$ saves the common intersection of polygons \\
					\icc \hspace{1ex}\= $i := 1$; ~$t_c$ := $P_1.t$;\\
					\icc \hspace{1ex}\= $|\vv{v}|:=\frac{|P_i-P_s|}{P_i.t-P_s.t}$; ~$\vv{v}.\theta:=\vv{|P_i-P_s|}.\theta$; \\
					\icc \hspace{1ex}\= update ($P_{s}, \vv{v}$); \\
					\icc \hspace{1ex}\= while $i \le n$ do \\
					\icc \>\hspace{3ex} $\mathcal{R}$ := \kw{getRegularPolygon}($P_s$, $P_i$, $\epsilon/2$, $m$, $t_c$); \\
					\icc \>\hspace{3ex} if $\mathcal{R}^* = \emptyset$  then $\mathcal{R}^* :=\mathcal{R};$ \\
					\icc \>\hspace{3ex} else $\mathcal{R}^*$ := \kw{getIntersection}$(\mathcal{R}^*, ~\mathcal{R})$; \\
					\icc \>\hspace{3ex} if $\mathcal{R}^* = \emptyset$ then  // updates velocity and location \\
					\icc \>\hspace{7ex}    $P_s := P_{i-1}$; \\
					\icc \>\hspace{7ex}    $|\vv{v}|:=\frac{|P_{i}-P_s|}{P_{i}.t-P_s.t}$; ~$\vv{v}.\theta:=\vv{|P_{i}-P_s|}.\theta$; \\
					\icc \>\hspace{7ex}    update ($P_{s}, \vv{v}$); \\
					\icc \>\hspace{7ex}    $t_c$ := $P_{i}.t$; ~$i$ := $i - 1$;		\\
					\icc \>\hspace{3ex} else if $\mathcal{R}^* \ne \emptyset$ ~and~ $|P_iP'_i| \ge \epsilon/2 $ then   ~// updates velocity \\
					\icc \>\hspace{7ex}    $|\vv{v}|:=\frac{|P_i-P_s|}{P_i.t-P_s.t}$; ~$\vv{v}.\theta:=\vv{|P_i-P_s|}.\theta$; \\
					\icc \>\hspace{7ex}    update ($\vv{v}$); \\
					\icc \>\hspace{3ex} $i$ := $i +1$;	\\
					\icc \>\hspace{0ex} update ($P_{n}$); 
				}
				\vspace{-2ex}
				\myhrule
			\end{minipage}
		}
	\end{center}
	\vspace{-1ex}
	\caption{\small Trajectory tracking based on cone intersection (half-$\epsilon$).}
	\label{alg:citt-s-half}
	\vspace{-1ex}
\end{figure}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{example}
	\todo.
\end{example}


\stitle{Correctness and complexity.} 
\todo{correctness.}
Every point is processed only once in \citt, and for each point, it needs $O(1)$ time as getRegularPolygon(), update(), intersecting of polygons and other operations all have a time complexity of $O(1)$. Hence, \citt has a time complexity of $O(n)$, where $n$ is the number of data points.






\eat{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
\subsection{Extension from half-$\epsilon$ cone to full-$\epsilon$ cone}


\stitle{Algorithm \cittsf()}.

\begin{example}
\todo.
\end{example}	

\stitle{Correctness and complexity.} 


\subsection{Weak tracking}

-- theorem: if ldr is true, then the intersection of those cones must not be \{$P_s$\}.
means that, if ldr is true, it is sure those points can be represented by a line segment.
thus, we only need to check the intersection after ldr is false, during the process.

-- algorithm CITT-W(e)

-- example

-- correctness and complexity
}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
