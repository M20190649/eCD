\section{Effective one-pass tracking in circular areas}
\label{sec:circular}

\ldrh is an efficient trajectory tracking algorithm but suffer in effectiveness (compression ratios).
Observing one-pass algorithms, \cised using \sed, having low time complexity and good compression ratios, this inspires us to develop an efficient as well as effective trajectory tracking algorithm.

\subsection{Tracking by spatio-temporal cone}
\cised \cite{Lin:Cised} is a one-pass trajectory simplification algorithm using \sed, using a local synchronous distance checking approach based on a concept of spatio-temporal cone, defined in a 3D Cartesian coordinate system whose $x$-axis, $y$-axis and $t$-axis are longitude, latitude and time, respectively, that converts the \sed distance tolerance into the intersection of cones for testing the successive points.




\stitle{Spatio-temporal cones (\cone{}) \cite{Lin:Cised}}. 
Given a start point $P_s$ of sub-trajectory $\dddot{\mathcal{T}}_s[P_s, \ldots, P_{s+k}]$ and an error bound $\epsilon$, the spatio-temporal cone (or simply \textit{cone}) of a data point $P_{s+i}$ ($1\le i\le k$) in $\dddot{\mathcal{T}_s}$ \wrt $P_s$ and $\epsilon$, denoted as \cone{(P_s, P_{s+i}, \epsilon)}, or \cone{_{s+i}} in short, is an oblique circular cone such that point $P_s$ is its apex and the synchronous circle $\mathcal{O}(P_{s+i}, \epsilon)$ of point $P_{s+i}$, or \circle{_{s+i}} in short, a circle on the plane $P.t-P_{s+i}.t = 0$ such that $P_{s+i}$ is its center and $\epsilon$ is its radius, is its base.


\begin{example}
	\label{exm-circles-cones}
	Figure~\ref{fig:cis} shows 
	(1) two synchronous circles, \circle{(P_{s+i}, \epsilon)} of point $P_{s+i}$ and \circle{(P_{s+k}, \epsilon)} of point $P_{s+k}$.
	It is easy to see that for any point in the area of a circle \circle{(P_{s+i}, \epsilon)}, its distance to $P_{s+i}$ is not greater than $\epsilon$, 
	and (2) two example spatio-temporal cones, \cone{(P_s, P_{s+i}, \epsilon)} {(purple)} and \cone{(P_s, P_{s+k}, \epsilon)} (red), with the same apex $P_s$ and error bound $\epsilon$. %\eop
\end{example}

%Note that in this definition, a \emph{synchronous circle} $\mathcal{O}(P_i, \epsilon)$ is only defined by a central point $P_i$ and a constant $\epsilon$. Indeed, it is nothing to do with any start point $P_s$ or end point $P_e$.


%\textcolor{blue}{We define \textit{synchronous circles and Spatio-temporal cones} in a \emph{x-y-t} 3D coordinate system, and build the connection between \textit{synchronous circles} and \textit{synchronous distances}.}



\begin{figure}[tb!]
	\centering
	\includegraphics[scale=0.66]{figures/Fig-CIS.png}
	%	\vspace{-1ex}
	\caption{\small Examples of spatio-temporal cones in a 3D Cartesian coordinate system taking point $P_s$ as the origin, where (1) $P_{s+i}$ and $P_{s+k}$ are two points, (2) \circle{_{s+i}} and \circle{_{s+k}} are two synchronous circles, (3) \cone{_{s+i}} and \cone{_{s+k}} are two spatio-temporal cones, (4) $Q$ is a point in synchronous circle \circle{_{s+k}}, and (5) $P'_{s+i}$ is the intersection point of line $\protect\vv{P_sQ}$ and synchronous circle \circle{_{s+i}}.}
	%\vspace{-1ex}
	\label{fig:cis}
\end{figure}




\begin{theorem}
\label{theo-half-cone}
{Given a sub-trajectory $[P_s,...,P_{s+k}]$ and an error bound $\epsilon$, $sed(P_{s+i}, \vv{P_sP_{s+k}})\le \epsilon$ for each $i \in [1,k]$ if  $\bigsqcap_{i=1}^{k}$\cone{(P_s, P_{s+i}, \epsilon/2)} $\ne \{P_s\}$} \cite{Lin:Cised}.
\end{theorem}

Theorem \ref{theo-half-cone} tells that the \sed distance tolerance can be checked by finding the common intersection of spatio-temporal cones, and it serves as the foundation of a one-pass trajectory simplification algorithm \cised~\cite{Lin:Cised}. And for efficiency consideration, \cised projects the cones on a plane so as to convert the checking of cones intersection into a much simpler way, \ie the checking of circles intersection on the plane. For the same reason, a circle is approximated by its inscribe regular polygon and the intersecting of circles is approximated by the intersecting of these polygons.

%We next show that the cones intersection approach is much more effective than the policy used in \ldrh. Actually, the latter is just a special case of the former.

\begin{theorem}
\label{theo-ldrh-cised}
Given a sub-trajectory $\dddot{\mathcal{T}}_s[P_s,...,P_{s+k}]$, an error bound $\epsilon$ and a velocity $\vv{v}$, if $\dddot{\mathcal{T}}_s$ can be represented by line segment $\vv{P_sP_{s+k}}$ through algorithm \ldrh, then it can also be represented by approaches based on spatio-temporal cones.
\end{theorem}

\begin{proof}
\todo{1. $\vv{v}$ in 3D space; 2...}

If $|P_{s+i}P'_{s+i}|\le \epsilon/2$ for each $i \in [1,k]$, then $\vv{v}$ must live in the common intersection of half-$\epsilon$ cones $\bigsqcap_{i=1}^{k}$\cone{(P_s, P_{s+i}, \epsilon/2)}, where $P'_{s+i}$ is the synchronized point of $P_{s+i}$ \wrt $\vv{v}$.
\end{proof}

Theorem \ref{theo-ldrh-cised} tells that \ldrh is a special case of, and has worse effective than, approaches based on spatio-temporal cones. Hence, the latter is a more effective way to develop one-pass trajectory tracking algorithms. 
The half-$\epsilon$ cone in the above is still a little conservative. Fortunately, it can be extended to a full-$\epsilon$ cone with some constrains so as to get a better effectiveness.


\begin{theorem}
	\label{theo-full-cone}
	Given a sub-trajectory $[P_s,...,P_{s+k}]$ and an error bound $\epsilon$, $sed(P_{s+i}, \vv{P_sP_{s+k}})\le \epsilon$ for each $i \in [1,k]$ if $P_{s+i} \in \bigsqcap_{i=1}^{k-1}$\cone{(P_s, P_{s+i}, \epsilon)}.
\end{theorem}

\begin{proof}
	\todo.
\end{proof}

Theorem \ref{theo-full-cone} 

\begin{theorem}
	\label{theo-cone-vs}
	Given a sub-trajectory $[P_s,...,P_{s+k}]$ and an error bound $\epsilon$, if $\bigsqcap_{i=1}^{k}$\cone{(P_s, P_{s+i}, \epsilon/2)} $\ne \{P_s\}$, then $P_{s+i} \in \bigsqcap_{i=1}^{k-1}$\cone{(P_s, P_{s+i}, \epsilon)}; the opposite is not always true.
\end{theorem}

\begin{proof}
	\todo.
\end{proof}

\subsection{Implementation}

We next present a {\em trajectory tracking} algorithm based on spatio-temporal cones. This algorithm runs on moving objects and uses half-$\epsilon$ cones to check the distance deviations. In a nutshell, it first initializes its velocity $\vv{v}$ (including value and direction) and sends it coupling with a start position $P_s$ to the MOD server. Then it iteratively checks the deviation of its actual position $P_{s+k}$ to its synchronized point $P'_{s+k}$ built from the start point $P_s$, velocity $\vv{v}$ and time $P_{s+k}.t$, as well as the common intersection of spatio-temporal cones built from points $P_{s+i}$, $i \in [1, k]$. If the deviation is lager than a given threshold or the common intersection except $P_s$ is null, then an update is sent to the MOD server.


\stitle{Algorithm \cittsh()}.
%We now present algorithm \cist.
As shown in Figure~\ref{alg:citt-s-half}, it takes as input a trajectory \trajec{T}${[P_0, \ldots, P_n]}$, an error bound $\epsilon$ and the number $m$ of edges for inscribed regular polygons, and outputs a simplified  trajectory $\overline{\mathcal{T}}$ of $\dddot{\mathcal{T}}$ and a set of velocities.

The algorithm first initializes the start point $P_s$ to $P_0$,  the intersection polygon $\mathcal{R}^*$ to $\emptyset$, the index $i$ of the current point to $P_1$, and $t_c$ to $P_1.t$, respectively (lines 1--2). It also sets the expected velocity $\vv{v}$ based on $\vv{P_0P_1}$, and sends its initial location $P_s$ and the velocity $\vv{v}$ to the MOD server (lines 3--4), meaning that it is supposed to move from $P_s$ along the direction of $\vv{v}.\theta$ at a speed of $|\vv{v}|$.
%, such that the expecting position of the object at time $t>P_s.t$ can be extrapolated from them as long as no subsequent update is sent to the MOD server.

The algorithm sequentially processes the data points of the trajectory one by one (lines 5--17). 
For the current point $P$, it gets the $m$-edge inscribed regular polygon \wrt the current point $P_i$ by calling procedure $\kw{getRegularPolygon}$ \cite{Lin:Cised}, and gets the common intersection $\mathcal{R}^*$ by calling procedure $\kw{getIntersection}$ \cite{Lin:Cised}. When $\mathcal{R}^* = \emptyset$, the intersection polygon $\mathcal{R}^*$ is simply initialized as $\mathcal{R}$. Otherwise, $\mathcal{R}^*$ is  the intersection of the current regular polygon $\mathcal{R}$ with $\mathcal{R}^*$ (lines 6--8). 
%
If the common intersection $\mathcal{R}^*$ is not empty, meaning that it can not includes any points into a line segment, then a line segment $\vv{P_sP_{i-1}}$ and a new section start from  $P_{i-1}$ is generated, hence, point $P_{i-1}$ and a new velocity $\vv{v}$ are sent to the MOD server (lines 9--13).
%
Otherwise, it calculates the distance from the actual location $P$ with the expecting location $P'$ of the current time extrapolated from the initial location $P_s$ and the velocity $\vv{v}$. 
If the common intersection $\mathcal{R}^*$ is not empty and the distance does not deviate by more than $\epsilon/2$ from the expecting location $P'$, meaning it can includes more points into a line segment while the velocity need to be updated. Hence, it updates velocity $\vv{v}$ based on $P_s$ and $P_i$ and sends it to the MOD server (lines 14--16). 
%
Anyway, the algorithm goes on to process the next point (line 17).
%
The process repeats until all points have been processed.
At last, it outputs the last point $P_{n}$ (line 18).





%%%%%%%%%%%%%%%%%%%%%algorithm
\begin{figure}[tb!]
	\begin{center}
		{\small
			\begin{minipage}{3.3in}
				\myhrule
				%\vspace{-1ex}
				\mat{0ex}{
					{\bf Algorithm}~\cittsh $(\dddot{\mathcal{T}}[P_0,\ldots,P_n],~\epsilon,~m)$\\
					%	\sstab
					\bcc \hspace{1ex}\= $P_s := P_0$; ~$\mathcal{R}^* := \emptyset$;~~~~// $\mathcal{R}^*$ saves the common intersection of polygons \\
					\icc \hspace{1ex}\= $i := 1$; ~$t_c$ := $P_1.t$;\\
					\icc \hspace{1ex}\= $|\vv{v}|:=\frac{|P_i-P_s|}{P_i.t-P_s.t}$; ~$\vv{v}.\theta:=\vv{|P_i-P_s|}.\theta$; \\
					\icc \hspace{1ex}\= update ($P_{s}, \vv{v}$); \\
					\icc \hspace{1ex}\= while $i \le n$ do \\
					\icc \>\hspace{3ex} $\mathcal{R}$ := \kw{getRegularPolygon}($P_s$, $P_i$, $\epsilon/2$, $m$, $t_c$); \\
					\icc \>\hspace{3ex} if $\mathcal{R}^* = \emptyset$  then $\mathcal{R}^* :=\mathcal{R};$ \\
					\icc \>\hspace{3ex} else $\mathcal{R}^*$ := \kw{getIntersection}$(\mathcal{R}^*, ~\mathcal{R})$; \\
					\icc \>\hspace{3ex} if $\mathcal{R}^* = \emptyset$ then  // updates velocity and location \\
					\icc \>\hspace{7ex}    $P_s := P_{i-1}$; \\
					\icc \>\hspace{7ex}    $|\vv{v}|:=\frac{|P_{i}-P_s|}{P_{i}.t-P_s.t}$; ~$\vv{v}.\theta:=\vv{|P_{i}-P_s|}.\theta$; \\
					\icc \>\hspace{7ex}    update ($P_{s}, \vv{v}$); \\
					\icc \>\hspace{7ex}    $t_c$ := $P_{i}.t$; ~$i$ := $i - 1$;		\\
					\icc \>\hspace{3ex} else if $\mathcal{R}^* \ne \emptyset$ ~and~ $|P_iP'_i| \ge \epsilon/2 $ then   ~// updates velocity \\
					\icc \>\hspace{7ex}    $|\vv{v}|:=\frac{|P_i-P_s|}{P_i.t-P_s.t}$; ~$\vv{v}.\theta:=\vv{|P_i-P_s|}.\theta$; \\
					\icc \>\hspace{7ex}    update ($\vv{v}$); \\
					\icc \>\hspace{3ex} $i$ := $i +1$;	\\
					\icc \>\hspace{0ex} update ($P_{n}$); 
				}
				\vspace{-2ex}
				\myhrule
			\end{minipage}
		}
	\end{center}
	\vspace{-1ex}
	\caption{\small Trajectory tracking based on cone intersection (half-$\epsilon$).}
	\label{alg:citt-s-half}
	\vspace{-1ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{example}
	\todo.
\end{example}


\stitle{Correctness and complexity.} 
\todo{correctness.}
Every point is processed only once in \cittsh, and for each point, it needs $O(1)$ time as getRegularPolygon(), getIntersection(), update() and other operations all have a time complexity of $O(1)$. Hence, \cittsh has a time complexity of $O(n)$.






\eat{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
\subsection{Extension from half-$\epsilon$ cone to full-$\epsilon$ cone}


\stitle{Algorithm \cittsf()}.

\begin{example}
\todo.
\end{example}	

\stitle{Correctness and complexity.} 


\subsection{Weak tracking}

-- theorem: if ldr is true, then the intersection of those cones must not be \{$P_s$\}.
means that, if ldr is true, it is sure those points can be represented by a line segment.
thus, we only need to check the intersection after ldr is false, during the process.

-- algorithm CITT-W(e)

-- example

-- correctness and complexity
}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
