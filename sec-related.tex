%\vspace{-0.5ex}
\section{Related Work}
\label{sec-related}
%\vspace{-1ex}


Constraint-based data cleaning was introduced in~\cite{leo99}, which
proposed to use dependencies, \eg~\FDs, \INDs and denial
constraints, to detect and repair errors in real-life data (see,
\eg~\cite{Chomicki07} for a comprehensive survey). As an extension
of traditional \FDs, \CFDs were developed in~\cite{CFDs}, for
improving the quality of data. It was shown in~\cite{CFDs} that the
satisfiability and implication problems for \CFDs are \NP-complete
and \coNP-complete, respectively. Along the same lines, \CINDs were
proposed in~\cite{CINDs} to extend \INDs. It was shown~\cite{CINDs}
that the satisfiability and implication problems for \CINDs are in
constant time and \EXPTIME-complete, respectively. \SQL techniques
were developed in~\cite{CFDs} to detect errors by using \CFDs, but
have not been studied for \CINDs. This work extends the static
analyses of conditional dependencies of~\cite{CFDs,CINDs}, and has
established several new complexity results, notably in the absence
of finite-domain attributes (\eg~Theorems~\ref{thm-sat-pcfd-infin},
\ref{thm-imp-pcfd-infin}, \ref{thm-imp-pcind-infin}). In addition,
it is the first work to develop \SQL-based techniques for checking
violations of \CINDs and violations of \pCFDs and \pCINDs taken
together.

Extensions of \CFDs have been proposed to support disjunction and
negation~\cite{icde08}, cardinality constraints and synonym
rules~\cite{ChenFM09}, and to specify patterns in terms of value
ranges~\cite{divesh08}. While \pCFDs are more powerful than the
extension of~\cite{divesh08}, they cannot express
disjunctions~\cite{icde08}, cardinality constraints and synonym
rules~\cite{ChenFM09}. To our knowledge no extensions of \CINDs have
been studied. This work is the first full treatment of extensions of
\CFDs and \CINDs by incorporating built-in predicates ($\ne, <, \le,
>, \ge$), from static analyses to error detection.

Methods have been developed for discovering
\CFDs~\cite{CM08,divesh08,icde09} and for repairing data based on
either \CFDs~\cite{repair}, traditional \FDs and \INDs taken
together~\cite{sigmod05}, denial
constraints~\cite{BertossiBFL08,ChomickiM05}, or aggregate
constraints~\cite{FlescaFP05}. We defer the treatment of these
topics for \pCFDs and \pCINDs to future work.


A variety of extensions of \FDs and \INDs have been studied for
specifying constraint databases and constraint logic
programs~\cite{BCW99,BP83,Maher97,MS96}. While the languages
of~\cite{BCW99,Maher97} cannot express \CFDs,
constraint-generating dependencies (\CGDs)
of~\cite{BCW99} and constrained tuple-generating dependencies
(\CTGDs) of~\cite{MS96} can express \pCFDs,
and \CTGDs can also express \pCINDs. The increased expressive
power of \CTGDs comes at the price of a higher complexity:
both their satisfiability and implication problems are undecidable.
Built-in predicates and arbitrary constraints are supported
by \CGDs, for which it is not clear whether effective \SQL
queries can be developed to detect errors. It is worth mentioning
that Theorems~\ref{thm-sat-pcfd-infin} and \ref{thm-imp-pcfd-infin}
of this work provide lower bounds for the consistency and implication analyses
of \CGDs, by using patterns with built-in predicates only.
