
\subsection{A fast regular polygon intersection method}


Observe that the algorithm of ~\cite{ORourke:Intersection} is for general convex polygons, while the approximate polygons are special polygons. We further develop an even fast approximate polygon intersection method based on the properties of approximate polygons.
%
The presented approximate polygon intersection algorithm is indeed a customized version of the convex polygon algorithm of ~\cite{ORourke:Intersection}.
%
Given intersection polygon $\mathcal{G}^*_k$ of the preview $k$ polygons and the next approximate polygon $\mathcal{G}_{k+1}$, the algorithm returns $\mathcal{G}^*_{k+1} = \mathcal{G}^*_k  \bigcap \mathcal{G}_{k+1}$.







%%%%%%%%%%%%%%%%%%%%%Baseline Algorithm
\begin{figure}[tb!]
\begin{center}
{\small
\begin{minipage}{3.36in}
\myhrule
\vspace{-1ex}
\mat{0ex}{
	{\bf Algorithm} ~$PolyInter$($\mathcal{G}^*$, $\mathcal{G}$, \textcolor[rgb]{1.00,0.00,0.00}{CandidateEdges of $\mathcal{G}^*$})\\
	\bcc \hspace{1ex}\= \textcolor[rgb]{1.00,0.00,0.00}{Get candidate edges} \\
	\bcc \hspace{1ex}\= \textcolor[rgb]{1.00,0.00,0.00}{Handle $G_1 \subset G_2$ and $G_2 \subset G_1$ cases, return?}  \\
	\bcc \hspace{1ex}\= Choose A and B \textcolor[rgb]{0.00,0.07,1.00}{arbitrarily} \\
	\icc \hspace{1ex}\= repeat \\
	\icc \>\hspace{3ex} if A intersects B then \\
	\icc \>\hspace{6ex} \textcolor[rgb]{0.00,0.07,1.00}{Check for termination} \\
	\icc \>\hspace{6ex} Update an inside flag. \\
	\icc \> \hspace{3ex} Moves on either A or B \textcolor[rgb]{0.00,0.07,1.00}{on candidate edges}.\\
	\icc \hspace{1ex} until \textcolor[rgb]{1.00,0.00,0.00}{both} A and B cycle their polygons \\
	\icc \hspace{1ex} return the intersection polygon
}
\vspace{-2ex}
\myhrule
\end{minipage}
}
\end{center}
\vspace{-2ex}
\caption{\small Intersection of approximate polygons.}
\label{alg:poly-inter}
\vspace{-2ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%







\stitle{\textcolor[rgb]{0.00,0.07,1.00}{polygon intersection algorithm}}
Given two approximate polygons $\mathcal{G}^*_k$ and $\mathcal{G}_{k+1}$, and the candidate intersection edges, the algorithm returns the intersection polygon (may be null).

The sketch of the algorithm is shown in Figure~\ref{alg:poly-inter}.

Let $A$ and $B$ be directed edges on $\mathcal{G}^*_k$ and $\mathcal{G}_{k+1}$ respectively. The algorithm has $A$ and $B$ ``chasing" one another. During the chasing, $A$ or $B$ moves on step by step in the counterclockwise order, following some rules designed depending on geometric conditions, as described in ~\cite{ORourke:Intersection}.






\begin{figure}[tb!]
\centering
\includegraphics[scale=0.88]{figures/Fig-r-poly-inter.png}
\vspace{-1ex}
\caption{\small A running example of intersection of polygons.}
\vspace{-2ex}
\label{fig:r-poly-inter}
\end{figure}




\begin{example}
Figure~\ref{fig:r-poly-inter} is a running example of the approximate polygon intersection algorithm.
Initially, the candidate edges are marked and directed edges $A$ and $B$ are on polygons $\mathcal{G}_{k+1}$ and $\mathcal{G}^*_{k}$ separately

\ni (1) Initially, directed edges $A$ and $B$ are on polygons $\mathcal{G}_{k+1}$ and $\mathcal{G}^*_{k}$ separately. $A \bigcap B = P_1$.

\ni (2) $A$ moves forward a 4-steps. $A \bigcap B = \phi$.

\ni (3) After 4 steps of moving, $A \bigcap B = P_2$

\ni (4) $B$ moves forward a 2-steps. $A \bigcap B = \phi$.

\ni (5) After 5 steps of moving, both $A$ and $B$ cycle their polygons;

\ni (6) At last, it returns the intersection polygon.
\end{example}






