%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%example of Algorithm CISED
\begin{figure*}[tb!]
\centering
\includegraphics[scale=0.8]{figures/Fig-ex-conest.png}
\vspace{-1ex}
\caption{\small A running example of the \cist algorithm. The points and the oblique circular cones are projected on an x-y space. The trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_{10}]$ is compressed to four line segments.}
\vspace{-2ex}
\label{fig:exm-const}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\subsubsection{A fast regular polygon intersection method}


Observe that the \cpia algorithm (Figure~\ref{alg:c-poly-inter}) is for general convex polygons, while the approximate polygons are special polygons. We further develop an even fast polygon intersection method based on the properties of approximate polygons.
%
The presented polygon intersection algorithm is indeed a customized version of the \cpia algorithm.

\stitle{Data structures}.

\stitle{Parallel of edges}.

\stitle{Advancing rules}.
Let $A$ and $B$ be directed edges on polygons $\mathcal{G}_{k+1}$ and $\mathcal{G}^*_k$ respectively.
Originally, $A$ and $B$ are advanced step by step each time by the advancing rules of the \cpia algorithm.
%
However, the new algorithm allows the algorithm to advance $A$ or $B$ multiple steps at one time.

The advancing rules of the \cpia algorithm are indeed four categories, \ie $A \bigcap B \ne \phi$ and advances $A$, $A \bigcap B \ne \phi$ and advances $B$, $A \bigcap B = \phi$ and advances $A$, and $A \bigcap B = \phi$ and advances $B$.
For $A \bigcap B \ne \phi$, extensions are developed, as follows.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{1ex}
\ni \emph{\underline{Rule 1}:
If $A \bigcap B \ne \phi$ and advances $B$, then advance $B$ to $next(e)$ on $\mathcal{G}^*_k$, where (1) $g(e) = g(A)$ and $g(e)$ denotes the edge group of edge $e$; (2) $next(e)$ denotes the first edge on the graph that follows $e$.}
\vspace{1ex}

For example, in Figure~\ref{fig:r-poly-inter}-(3), $A \bigcap B = P_2$ and $B$ moves on, hence rule 1 is applied. $B$ moves forward to $e^*_{k, 3}$, \ie the next edge of the $4^{th}$ edge as $g(A) = 4$ (Figure~\ref{fig:r-poly-inter}-(4)).
%In this case, the $4^{th}$ edge does not exist in $\mathcal{G}^*_k$.
Note if the $3^{th}$ edge were not actually existing in $\mathcal{G}^*_k$, then $B$ should move on to the next real edge of $\mathcal{G}^*_k$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{1ex}
\ni \emph{\underline{Rule 2}:
If $A \bigcap B \ne \phi$ and advances $A$, then moves $A$ forward ``$a$" steps, where}
%\vspace{-1ex}
\begin{equation*}
\label{equ-rule2}
\small
    \hspace{2ex} a =  \left\{
    \begin{aligned}
        & 2*(g(A) - g(B)),  \hspace{5ex} ~if  ~g(A) > g(B) \\
        & {1},              \hspace{20.5ex}~if  ~g(A) = g(B) \\
        & 2*(M+g(A) - g(B)), ~if  ~g(A) < g(B) \\
    \end{aligned}
    \right.       \hspace{6ex}(4)
\end{equation*}
%\vspace{-1ex}


For example, in Figure~\ref{fig:r-poly-inter}-(1), $A \bigcap B = P_1$ and $A$ moves on, hence, rule 2 is applied. Because $g(A)=2 < 8=g(B)$, $A$ moves forward $2*(M+g(A) - g(B)) = 2*(8+2-8)= 4$ steps, \ie from $2^{th}$ to $6^{th}$ (Figure~\ref{fig:r-poly-inter}-(2)).


\eat{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{1ex}
\ni \emph{\underline{Rule 3}:
If $A \bigcap B = \phi$ and advances $A$, then moves $A$ and $B$ forward ``$a$ and $b$" steps respectively, where}
%\vspace{-1ex}
\begin{equation*}
\label{equ-rule3}
\small
    \hspace{0ex} (a,b) =  \left\{
    \begin{aligned}
        & (2,0), ~if~ g(next(A)) = g(B) ~and~ {outside}(A)  \\
        & (1,1), ~if~ g(next(A)) = g(B) ~and~ {inside}(A)\\
        & (1,0), ~else
    \end{aligned}
    \right.       \hspace{2ex}(5)
    %\vspace{-1ex}
\end{equation*}
%\vspace{-1ex}
\emph{and procedure $inside()$ or $outside()$ is a checking of the ``{\emph{inside}}" flag (line 5) of the \cpia algorithm (Figure~\ref{alg:c-poly-inter}).}
\vspace{1ex}


For example, in Figure~\ref{fig:r-poly-inter}-(4), $A \bigcap B = \phi$ and advances $A$, hence, rule 3 is applied. Because $A$ is inside and $g(next(A))=3 = g(B)$, $A$ and $B$ both move forward one step (Figure~\ref{fig:r-poly-inter}-(5)).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{1ex}
\ni \emph{\underline{Rule 4}:
If $A \bigcap B = \phi$ and advances $B$, then moves $A$ and $B$ forward ``$a$ and $b$" steps respectively, where}
%\vspace{-1ex}
\begin{equation*}
\label{equ-rule4}
\small
    \hspace{0ex} (a,b) =  \left\{
    \begin{aligned}
        & (0,2), ~if~ g(next(B)) = g(A) ~and~ outside(B)\\
        & (1,1), ~if~ g(next(B)) = g(A) ~and~ inside(B)\\
        & (0,1), ~else
    \end{aligned}
    \right.       \hspace{2ex}(6)
\end{equation*}
\vspace{-1ex}

}%%%%%%%%%%%%%%%%%%%%%%%%%%End of Eat



%%%%%%%%%%%%%%%%%%%%%example of intersection of regular polygons
\begin{figure}[tb!]
\centering
\includegraphics[scale=0.88]{figures/Fig-r-poly-inter.png}
\vspace{-2ex}
\caption{\small A running example of intersection of polygons.}
%\vspace{-2ex}
\label{fig:r-poly-inter}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%Algorithm
\begin{figure}[tb!]
\begin{center}
{\small
\begin{minipage}{3.36in}
\myhrule
\vspace{-1ex}
\mat{0ex}{
	{\bf Algorithm} ~$RegularPolyInter$($\mathcal{G}^*_k$, $\mathcal{G}_{k+1}$) \\
	\bcc \hspace{2ex}\=  Set $A$ and $B$ {arbitrarily} on $\mathcal{G}^*_k$ and $\mathcal{G}_{k+1}$\\
	\icc \>\hspace{0ex}\= Repeat \\
	\icc \>\hspace{3ex} If $A \bigcap B \ne \phi$ Then \\
	\icc \>\hspace{6ex} {\textcolor[rgb]{0.00,0.00,1.00}{Check for termination}.} \\
	\icc \>\hspace{6ex} Update an {\emph{inside}} flag for $A$ or $B$. \\
	\icc \>\hspace{6ex} {\emph{Moves on either $A$ or $B$ under rule 1 or 2.}}\\
	\icc \>\hspace{3ex} Else \\
	\icc \>\hspace{6ex} {\emph{Moves on either $A$ or $B$.}}\\
	\icc \hspace{1ex} Until both $A$ and $B$ cycle their polygons \\
	\icc \hspace{0ex} Handle $\mathcal{G}^*_k \subset \mathcal{G}_{k+1}$ and $\mathcal{G}^*_k \subset \mathcal{G}_{k+1}$ and $\mathcal{G}^*_k \bigcap \mathcal{G}_{k+1} = \phi$ cases \\
    \icc \hspace{0ex} Return $\mathcal{G}^*_k \bigcap \mathcal{G}_{k+1}$
}
\vspace{-2ex}
\myhrule
\end{minipage}
}
\end{center}
\vspace{-2ex}
\caption{\small Intersection of Regular polygons.}
\label{alg:r-poly-inter}
\vspace{-2ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%








\stitle{{Regular polygon intersection algorithm.}}
Given intersection polygon $\mathcal{G}^*_k$ of the preview $k$ polygons and the next approximate polygon $\mathcal{G}_{k+1}$, the algorithm returns $\mathcal{G}^*_{k+1} = \mathcal{G}^*_k  \bigcap \mathcal{G}_{k+1}$.
The sketch of the algorithm is shown in Figure~\ref{alg:r-poly-inter}.
%
It runs the similar routine as the \cpia algorithm, except the advance strategies are partitioned into two parts, \ie $A \bigcap B \ne \phi$ and $A \bigcap B = \phi$, where the former applies rules 1 and 2 (line 6), and the later remains the same as the \cpia algorithm (line 8).








\begin{example}
Figure~\ref{fig:r-poly-inter} is a running example of the approximate polygon intersection algorithm.

\ni (1) Initially, directed edges $A$ and $B$ are on polygons $\mathcal{G}_{k+1}$ and $\mathcal{G}^*_{k}$ separately. $A \bigcap B = P_1$ and $A$ moves on.

\ni (2) $A$ moves forward a 4-steps, from $2^{th}$ to $6^{th}$, under rule 2. Then, $A \bigcap B = \phi$ and $B$ moves on.

\ni (3) After 4 steps of moving (in turn), $A \bigcap B = P_2$ and $B$ moves on.

\ni (4) $B$ advances a 2-steps, from $6^{th}$ to $3^{th}$, under rule 1. Then $A \bigcap B = \phi$ and $A$ moves on.

\ni (5) $A$ advances a step. Then $A \bigcap B = \phi$ and $B$ moves on.

\ni (6) After 3 steps of moving, both $A$ and $B$ cycle their polygons. The intersection polygon is returned.
\end{example}






