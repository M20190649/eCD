



\subsubsection{A fast regular polygon intersection method}


Observe that the \cpia algorithm (Figure~\ref{alg:c-poly-inter}) is for general convex polygons, while the approximate polygons are special polygons. We further develop an even fast polygon intersection method based on the properties of approximate polygons.
%
The presented regular polygon intersection algorithm, \ie \rpia, is indeed a customized version of the \cpia algorithm.
The major modifications are 2 folds.

\vspace{1ex}
\ni \emph{{(1) Saves vertexes or edges of a polygon in an array}}.
In \cpia algorithm, polygons are saved in linked lists.
Considering the regular polygons each having a fixed number of edges, marked from $1$ to $M$, we save vertexes or edges of a polygon in an fixed size array. This policy alow us to quickly address an edge or vertex by its index.
%, as well as avoid the creating and removing of link nodes.

%\stitle{Parallel of edges}.

\vspace{1ex}
\ni \emph{(2) Advances $\vv{A}$ or $\vv{B}$ multiple steps one time}.
Let $\vv{A}$ and $\vv{B}$ be directed edges on polygons $\mathcal{G}_{k+1}$ and $\mathcal{G}^*_k$ respectively.
Originally, $\vv{A}$ and $\vv{B}$ are advanced step by step each time by the advancing rules of algorithm \cpia .
%
However, algorithm \rpia allows to advance $\vv{A}$ or $\vv{B}$ multiple steps at one time by the following rules.

\eat{
The advancing rules of \cpia are indeed four categories, \ie $\vv{A} \bigcap \vv{B} \ne \phi$ and advances $\vv{A}$, $\vv{A} \bigcap \vv{B} \ne \phi$ and advances $\vv{B}$, $\vv{A} \bigcap \vv{B} = \phi$ and advances $\vv{A}$, and $\vv{A} \bigcap \vv{B} = \phi$ and advances $\vv{B}$.
For $\vv{A} \bigcap \vv{B} \ne \phi$, extensions are developed, as follows.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{1ex}
\ni \emph{\underline{Rule 1}:
If $\vv{A} \bigcap \vv{B} \ne \phi$ and advances $\vv{B}$, then advance $\vv{B}$ to $next(e)$ on $\mathcal{G}^*_k$, where (1) $g(e) = g({A})$ and $g(e)$ denotes the edge group of edge $e$; (2) $next(e)$ denotes the first edge on the graph that follows $e$.}
\vspace{1ex}

For example, in Figure~\ref{fig:r-poly-inter}-(3), $\vv{A} \bigcap \vv{B} = P_2$ and $\vv{B}$ moves on, hence rule 1 is applied. $\vv{B}$ moves forward to $e^*_{k, 3}$, \ie the next edge of the $4^{th}$ edge as $g(A) = 4$ (Figure~\ref{fig:r-poly-inter}-(4)).
%In this case, the $4^{th}$ edge does not exist in $\mathcal{G}^*_k$.
Note if the $3^{th}$ edge were not actually existing in $\mathcal{G}^*_k$, then $\vv{B}$ should move on to the next real edge of $\mathcal{G}^*_k$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{1ex}
\ni \emph{\underline{Rule 2}:
If $\vv{A} \bigcap \vv{B} \ne \phi$ and advances $\vv{A}$, then moves $\vv{A}$ forward ``$a$" steps, where}
%\vspace{-1ex}
\begin{equation*}
\label{equ-rule2}
\small
    \hspace{2ex} a =  \left\{
    \begin{aligned}
        & 2*(g(A) - g(B)),  \hspace{5ex} ~if  ~g(A) > g(B) \\
        & {1},              \hspace{20.5ex}~if  ~g(A) = g(B) \\
        & 2*(M+g(A) - g(B)), ~if  ~g(A) < g(B) \\
    \end{aligned}
    \right.       \hspace{6ex}(4)
\end{equation*}
%\vspace{-1ex}


For example, in Figure~\ref{fig:r-poly-inter}-(1), $\vv{A} \bigcap \vv{B} = P_1$ and $\vv{A}$ moves on, hence, rule 2 is applied. Because $g(A)=2 < 8=g(B)$, $\vv{A}$ moves forward $2*(M+g(A) - g(B)) = 2*(8+2-8)= 4$ steps, \ie from $2^{th}$ to $6^{th}$ (Figure~\ref{fig:r-poly-inter}-(2)).


\eat{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{1ex}
\ni \emph{\underline{Rule 3}:
If $A \bigcap B = \phi$ and advances $A$, then moves $A$ and $B$ forward ``$a$ and $b$" steps respectively, where}
%\vspace{-1ex}
\begin{equation*}
\label{equ-rule3}
\small
    \hspace{0ex} (a,b) =  \left\{
    \begin{aligned}
        & (2,0), ~if~ g(next(A)) = g(B) ~and~ {outside}(A)  \\
        & (1,1), ~if~ g(next(A)) = g(B) ~and~ {inside}(A)\\
        & (1,0), ~else
    \end{aligned}
    \right.       \hspace{2ex}(5)
    %\vspace{-1ex}
\end{equation*}
%\vspace{-1ex}
\emph{and procedure $inside()$ or $outside()$ is a checking of the ``{\emph{inside}}" flag (line 5) of the \cpia algorithm (Figure~\ref{alg:c-poly-inter}).}
\vspace{1ex}


For example, in Figure~\ref{fig:r-poly-inter}-(4), $A \bigcap B = \phi$ and advances $A$, hence, rule 3 is applied. Because $A$ is inside and $g(next(A))=3 = g(B)$, $A$ and $B$ both move forward one step (Figure~\ref{fig:r-poly-inter}-(5)).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{1ex}
\ni \emph{\underline{Rule 4}:
If $A \bigcap B = \phi$ and advances $B$, then moves $A$ and $B$ forward ``$a$ and $b$" steps respectively, where}
%\vspace{-1ex}
\begin{equation*}
\label{equ-rule4}
\small
    \hspace{0ex} (a,b) =  \left\{
    \begin{aligned}
        & (0,2), ~if~ g(next(B)) = g(A) ~and~ outside(B)\\
        & (1,1), ~if~ g(next(B)) = g(A) ~and~ inside(B)\\
        & (0,1), ~else
    \end{aligned}
    \right.       \hspace{2ex}(6)
\end{equation*}
\vspace{-1ex}

}%%%%%%%%%%%%%%%%%%%%%%%%%%End of Eat



%%%%%%%%%%%%%%%%%%%%%example of intersection of regular polygons
\begin{figure}[tb!]
\centering
\includegraphics[scale=0.88]{figures/Fig-r-poly-inter.png}
\vspace{-1ex}
\caption{\small A running example of intersection of polygons.}
%\vspace{-2ex}
\label{fig:r-poly-inter}
\end{figure}




\stitle{{Regular polygon intersection algorithm.}}
Given intersection polygon $\mathcal{G}^*_k$ of the preview $k$ polygons and the next approximate polygon $\mathcal{G}_{k+1}$, the algorithm \rpia returns $\mathcal{G}^*_{k+1} = \mathcal{G}^*_k  \bigcap \mathcal{G}_{k+1}$.
The sketch of the algorithm is shown in Figure~\ref{alg:r-poly-inter}.
%
It runs the similar routine as the \cpia algorithm, except that it saves polygons in arrays, and the advance strategies are partitioned into two parts, \ie $\vv{A} \bigcap \vv{B} \ne \phi$ and $\vv{A} \bigcap \vv{B} = \phi$, where the former applies rules 1 and 2 (line 6), and the later remains the same as the \cpia algorithm (line 8).







\begin{example}
Figure~\ref{fig:r-poly-inter} is a running example of algorithm \rpia. The input is the same as Figure~\ref{fig:c-poly-inter}.

\ni (1) Initially, directed edges $\vv{A}$ and $\vv{B}$ are on polygons $\mathcal{G}_{k+1}$ and $\mathcal{G}^*_{k}$ separately. $\vv{A} \bigcap \vv{B} = P_1$ and $\vv{A}$ moves on.
\ni (2) $\vv{A}$ moves forward a 4-steps, directly from $2^{th}$ to $6^{th}$, under rule 2. Then, $\vv{A} \bigcap \vv{B} = \phi$ and $\vv{B}$ moves on.
\ni (3) After 4 steps of moving (in turn), $\vv{A} \bigcap \vv{B} = P_2$ and $\vv{B}$ moves on.
\ni (4) $\vv{B}$ advances a 2-steps, from $6^{th}$ to $3^{th}$, under rule 1. Then $\vv{A} \bigcap \vv{B} = \phi$ and $\vv{A}$ moves on.
\ni (5) $\vv{A}$ advances a step. Then $\vv{A} \bigcap \vv{B} = \phi$ and $\vv{B}$ moves on.
\ni (6) After 3 steps of moving, both $\vv{A}$ and $\vv{B}$ cycle their polygons. The intersection polygon, the same as the result of \cpia (also see Figure~\ref{fig:c-poly-inter}), is returned.
\end{example}




%%%%%%%%%%%%%%%%%%%%%Algorithm
\begin{figure}[tb!]
\begin{center}
{\small
\begin{minipage}{3.36in}
\myhrule
\vspace{-1ex}
\mat{0ex}{
	{\bf Algorithm} ~\rpia ($\mathcal{G}^*_k$, $\mathcal{G}_{k+1}$) \\
	\bcc \hspace{2ex}\=  Set $\vv{A}$ and $\vv{B}$ {arbitrarily} on $\mathcal{G}^*_k$ and $\mathcal{G}_{k+1}$\\
	\icc \>\hspace{0ex}\= Repeat \\
	\icc \>\hspace{3ex} If $\vv{A} \bigcap \vv{B} \ne \phi$ Then \\
	\icc \>\hspace{6ex} {Check for termination}. \\
	\icc \>\hspace{6ex} Update an {\emph{inside}} flag for $\vv{A}$ or $\vv{B}$. \\
	\icc \>\hspace{6ex} {\emph{Moves on either $\vv{A}$ or $\vv{B}$ under rule 1 or 2.}}\\
	\icc \>\hspace{3ex} Else \\
	\icc \>\hspace{6ex} {{Moves on either $\vv{A}$ or $\vv{B}$.}}\\
	\icc \hspace{1ex} Until both $\vv{A}$ and $\vv{B}$ cycle their polygons \\
	\icc \hspace{0ex} Handle $\mathcal{G}^*_k \subset \mathcal{G}_{k+1}$ and $\mathcal{G}^*_k \subset \mathcal{G}_{k+1}$ and $\mathcal{G}^*_k \bigcap \mathcal{G}_{k+1} = \phi$ cases \\
    \icc \hspace{0ex} Return $\mathcal{G}^*_k \bigcap \mathcal{G}_{k+1}$
}
\vspace{-2ex}
\myhrule
\end{minipage}
}
\end{center}
\vspace{-2ex}
\caption{\small Intersection of Regular polygons.}
\label{alg:r-poly-inter}
\vspace{-2ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\stitle{Correctness and complexity analysis.}
Algorithm \emph{regularPolyInter} runs in the same routine as algorithm \cpia, except that it fastens the advancing speed of directed edges $\vv{A}$ and $\vv{B}$ in some circumstances as shown in Rule 1 and Rule 2. Given $\mathcal{G}^*_k$ and $\mathcal{G}_{k+1}$,  Rule 1 and Rule 2 will not changes the result the output, \ie $\mathcal{G}^*_{k+1}$. This ensure the correctness of \emph{regularPolyInter}.
For time complexity, algorithm \rpia runs the same time, $O(M)$, as algorithm \cpia.


