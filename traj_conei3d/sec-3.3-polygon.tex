\subsection{Approximate circles intersection}

%\textcolor[rgb]{1.00,0.00,0.00}{Todo....}
The checking of the $N$ circles intersection has a time complexity of \textcolor[rgb]{1.00,0.00,0.00}{${O(N\log N)}$~\cite{Shamos:Circle}}, which is not a linear time.
To develop a linear time complexity spatio-temporal simplification algorithm, we provide an approximate circles intersection method.
That is, we further replace a circle $\mathcal{O}(P, r)$ to a $M$-edges inscribed regular polygon,
then we check the intersection of the regular polygons instead of the checking of circles intersection.
Note that the intersection of regular polygons is only a sufficient condition of the intersection of the corresponding circles , and
algorithms employ this policy may loss some compression ratio. Obviously, a larger $M$ leads to a better compression ratio and a poorer
efficiency.

\stitle{Proximate polygons ($\mathcal{G}$)}.
Given a circle $\mathcal{O}(P, r)$, its approximate polygons is a $M$ edges inscribed regular polygon $\mathcal{G}(V, E)$,
where $V=\{v_1, \ldots, v_{M}\}$ is the set of vertexes and
$E= \{\overline{v_jv_{j+1}}| j\in [1,M-1]\} \bigcup \{\overline{v_Mv_1}\}$ is the set of edges.
Furthermore, let the center point $P$ of the circle be the origin of a polar coordinate system, then each vertex satisfies:

\vspace{-2ex}
\begin{equation*}
\label{equ-regular-polygon}
%\hspace{-1.5ex}
    \begin{aligned}
        \hspace{10ex}  v_j = (r, \frac{2(j-1)}{M}\pi), ~j \in [1, M]    \hspace{10ex} (3)\\
    \end{aligned}
\end{equation*}
\vspace{-1ex}

%\stitle{intersection polygons ($\mathcal{G}^*$)}.

For example, Figure~\ref{fig:polygons}-(1) is a regular octagon whose vertexes satisfying the Equation (3).

%The intersection of two M-edges convex polygons has a time complexity of $O(M)$ \cite{ORourke:Intersection}.
The regular polygons built by equation (3) have elegant properties, which is helpful to derive an algorithm of linear time and constant space
for the intersection of $N$ regular polygons.


\stitle{Edge groups}.
Let $e_{i,j} = \overline{v_{i,j}v_{i,j+1}}$, $j\in [1,M)$, or $e_{i,j} = \overline{v_{i,M}v_{i,1}}$, $j = M$, be an edge of an approximate polygon
$\mathcal{G}_i$, then all $e_{i,j}$, $i\in [1, k]$, form an \emph{edge group}, namely the $j^{th}$ edge group.
For example, in Figure~\ref{fig:polygons}-(2), all the $1^{th}$ edges form the $1^{th}$ edge group.




\begin{figure}[tb!]
\centering
\includegraphics[scale=0.88]{figures/Fig-polygons.png}
\vspace{-1ex}
\caption{\small Regular octagons and their intersections.}
\vspace{-3ex}
\label{fig:polygons}
\end{figure}



\begin{theorem}
\label{prop-rp-intersection}
If $\mathcal{G}_i$, $i \in [1, k]$, are M-edges regular polygons on a plane which are built by equation (3), then the intersection polygon
$\mathcal{G}^*_k$ of all $\mathcal{G}_i$ includes at most one edge from an edge group, \eg the $j^{th}$ edge group.
\end{theorem}


\begin{proof}
We prove this by contradiction.

Suppose $\mathcal{G}^*_k$ have two different edges, $e_{h,j}$ and $e_{l,j}$, $h\ne l$, belonging to the $j^{th}$ edge group. Obviously, edge
$e_{h,j}$ belongs to regular polygon $\mathcal{G}_h$, edge $e_{l,j}$ belongs to regular polygon $\mathcal{G}_l$ and $e_{h,j}$ is parallel to
$e_{l,j}$.

If $\mathcal{G}_l \bigcap \mathcal{G}_h = \phi$, then $\mathcal{G}^*_k=\phi$, which conflicts with the hypothetic premises.

If $\mathcal{G}_l \bigcap \mathcal{G}_h \ne \phi$, then the intersection polygon of $\mathcal{G}_h$ and $\mathcal{G}_l$ must include at most
one edge of $e_{h,j}$ and $e_{l,j}$, which is also the contradiction with the hypothetic premises.

Hence, the intersection polygon $\mathcal{G}^*_k$ includes at most one edge of an edge group.
%
%There are at most $M$ edge groups, thus, the intersection polygon $\mathcal{G}^*$ has no more than $M$ edges.
\end{proof}



For example, in Figure~\ref{fig:polygons}-(2), the intersection polygon (red lines) of $G_1$, $G_2$ and $G_3$ has 7 edges, marked 1, 2, 3, 5-8, each from a different edge group. Note the $4^{th}$ edge group has no contribution to the intersection polygon.


By Theorem~\ref{prop-rp-intersection}, the intersection polygon $\mathcal{G}^*_k$ of all proximate polygon $\mathcal{G}_i$, $i \in [1, k]$, has no more than $M$ edges. 
We know the convex polygon intersection algorithm of~\cite{ORourke:Intersection} has a time complexity of $O(|\mathcal{G}^*_k| + |\mathcal{G}_{k+1}|)$, which is $O(2M)$ here, thus, the computing of the intersection polygon of polygon $\mathcal{G}^*_k$ and proximate polygon $\mathcal{G}_{k+1}$ can be implemented in a constant time, \ie time $O(M)$, by the distinct polygon intersection algorithm of~\cite{ORourke:Intersection}.
%
Moreover, observe that the algorithm of ~\cite{ORourke:Intersection} is for general convex polygons, while the proximate polygons are special polygons. We further develop an even fast proximate polygon intersection method based on the properties of proximate polygons.

\subsubsection{Proximate polygons intersection}


\begin{figure}[tb!]
\centering
\includegraphics[scale=0.88]{figures/Fig-poly-edges.png}
\vspace{-1ex}
\caption{\small Samples of Candidate intersection edges.}
\vspace{-2ex}
\label{fig:poly-edges}
\end{figure}

The presented proximate polygon intersection algorithm is indeed a customized version of the convex polygon algorithm of ~\cite{ORourke:Intersection}.
%
Given intersection polygon $\mathcal{G}^*_k$ of the preview $k$ polygons and the next proximate polygon $\mathcal{G}_{k+1}$, the algorithm returns $\mathcal{G}^*_{k+1} = \mathcal{G}^*_k  \bigcap \mathcal{G}_{k+1}$.

The basic idea of the algorithm is a two steps processing, \ie \emph{Filtering} and \emph{Intersecting}:
 (1) \emph{Filtering}, which picks out $M$ candidate intersection edges, one edge of an edge group, from $\mathcal{G}^*_k $ and $\mathcal{G}_{k+1}$;
 (2) \emph{Intersecting}, which tries to form the intersection polygon, \ie $\mathcal{G}^*_{k+1}$, from these candidate edges.



\stitle{Candidate intersection edges}.
Let $e_{i,j}$, $1 \le i \le k+1$ and $1 \le j \le M$, be an edge of $\mathcal{G}_{i}$. The line containing the edge partitions the full plane into two half plane, the half plane that contains the central point $P_i$ of $\mathcal{G}_i$ be the \emph{inner half plane} of $e_{i,j}$, denoted as $\mathcal{H}(e_{i,j})$.
%
Then, the candidate intersection edge of the $j^{th}$ edge group is $e_{i,j}$, satisfying,

\vspace{-2ex}
\begin{equation*}
\label{equ-inter-edge}
%\hspace{-1.5ex}
    \begin{aligned}
        \hspace{2ex}  \forall l \in [1, M] (e_{i,j} \in \mathcal{H}(e_{l,j}) ~or~ \mathcal{H}(e_{i,j}) = \mathcal{H}(e_{l,j}) )    \hspace{5ex} (4)\\
    \end{aligned}
\end{equation*}
\vspace{-2ex}


If there are more than one edges of an edge group satisfying Equation (4), then we random choose one edge from them so as to guarantee the unique of the candidate intersection edge of an edge group. Note that not all candidate edges have contributions to intersection polygon.


%\stitle{Picks out $M$ candidate edges from $\mathcal{G}^*_k $ and $\mathcal{G}_{k+1}$.}
By this definition, the selection of candidate edges can be implemented in an incremental way:

\vspace{-2ex}
\begin{equation*}
\label{equ-inter-edge}
%\hspace{-1.5ex}
    \begin{aligned}
        \hspace{1ex}  e^*_{k+1, j} = \left\{
            \begin{aligned}
                & e_{k+1, j},   \hspace{8ex}if~~ e_{k+1,j} \in \mathcal{H}(e^*_{k,j}) \\
                & e^*_{k, j},   \hspace{10ex}if~~ e^*_{k,j} \in \mathcal{H}(e_{k+1,j})      \hspace{6ex} (5)  \\
                & e_{k+1, j} ~or~ e^*_{k, j}, ~if~ \mathcal{H}(e^*_{k,j}) = \mathcal{H}(e_{k+1,j}) \\
            \end{aligned}
        \right.
    \end{aligned}
\end{equation*}
\vspace{-1ex}

where,  $e^*_{1, j} = e_{1, j}$, $j \in [1, M]$ and $k\ge 1$.



\begin{example}
In Figure~\ref{fig:poly-edges}(1)-(6), the eight candidate intersection edges of $\mathcal{G}^*_{k+1}$ are:

(1) $e^*_{k,1}$, $e^*_{k,2}$, $e^*_{k,3}$, $e^*_{k,4}$, $e_{k+1,5}$, $e_{k+1,6}$, $e_{k+1,7}$ and $e_{k+1,8}$;

(2) $e_{k+1,1}$, $e_{k+1,2}$, $e_{k+1,3}$, $e_{k+1,4}$, $e^*_{k,5}$, $e^*_{k,6}$, $e^*_{k,7}$ and $e^*_{k,8}$;

(3) $e_{k+1,1}$ or $e^*_{k,1}$, $e_{k+1,2}$, $e_{k+1,3}$ or $e^*_{k,3}$, $e_{k+1,4}$, $e^*_{k,5}$, $e^*_{k,6}$ or $e_{k+1,6}$, $e_{k+1,7}$ and $e^*_{k,8}$;

(4) $e_{k+1,j}$, $j \in [1, 8]$;

(5) $e^*_{k,j}$, $j \in [1, 8]$;

(6) $e^*_{k,1}$, $e^*_{k,2}$, $e^*_{k,3}$, $e_{k+1,4}$, $e_{k+1,5}$, $e_{k+1,6}$, $e_{k+1,7}$ and $e^*_{k,8}$.


\end{example}





\begin{figure}[tb!]
\centering
\includegraphics[scale=0.88]{figures/Fig-poly-inter.png}
\vspace{-1ex}
\caption{\small A running example of intersection of polygons.}
\vspace{-2ex}
\label{fig:poly-inter}
\end{figure}


\stitle{\textcolor[rgb]{0.00,0.07,1.00}{polygon intersection algorithm}}
Given two proximate polygons $\mathcal{G}^*_k$ and $\mathcal{G}_{k+1}$, and the candidate intersection edges, the algorithm returns the intersection polygon (may be null).

The sketch of the algorithm is shown in Figure~\ref{alg:poly-inter}.

Get the candidate edges

Handle $G_1 \subset G_2$ and $G_2 \subset G_1$ cases.
From the candidate intersection edges, one can straightly conclude whether $\mathcal{G}_{k+1}$ belongs to $\mathcal{G}^*_{k}$ (Figure~\ref{fig:poly-edges}-(4)) or $\mathcal{G}^*_{k}$ belongs to $\mathcal{G}_{k+1}$ (Figure~\ref{fig:poly-edges}-(5)).

%

Handle the other cases.
Let $A$ and $B$ be directed edges on $\mathcal{G}^*_k$ and $\mathcal{G}_{k+1}$ respectively. The algorithm has $A$ and $B$ ``chasing" one another. During the chasing, $A$ or $B$ moves on step by step in the counterclockwise order, following some rules designed depending on geometric conditions, as described in ~\cite{ORourke:Intersection}.


%%%%%%%%%%%%%%%%%%%%%Baseline Algorithm
\begin{figure}[tb!]
\begin{center}
{\small
\begin{minipage}{3.36in}
\myhrule
\vspace{-1ex}
\mat{0ex}{
	{\bf Algorithm} ~$PolyInter$($\mathcal{G}^*$, $\mathcal{G}$, \textcolor[rgb]{1.00,0.00,0.00}{CandidateEdges of $\mathcal{G}^*$})\\
	\bcc \hspace{1ex}\= \textcolor[rgb]{1.00,0.00,0.00}{Get candidate edges} \\
	\bcc \hspace{1ex}\= \textcolor[rgb]{1.00,0.00,0.00}{Handle $G_1 \subset G_2$ and $G_2 \subset G_1$ cases, return?}  \\
	\bcc \hspace{1ex}\= Choose A and B \textcolor[rgb]{0.00,0.07,1.00}{arbitrarily} \\
	\icc \hspace{1ex}\= repeat \\
	\icc \>\hspace{3ex} if A intersects B then \\
	\icc \>\hspace{6ex} \textcolor[rgb]{0.00,0.07,1.00}{Check for termination} \\
	\icc \>\hspace{6ex} Update an inside flag. \\
	\icc \> \hspace{3ex} Moves on either A or B \textcolor[rgb]{0.00,0.07,1.00}{on candidate edges}.\\
	\icc \hspace{1ex} until both A and B cycle their polygons \\
	\icc \hspace{1ex} return the intersection polygon \\
}
\vspace{-2ex}
\myhrule
\end{minipage}
}
\end{center}
\vspace{-2ex}
\caption{\small Intersection of proximate polygons.}
\label{alg:poly-inter}
\vspace{-2ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%






\begin{example}

\end{example}
