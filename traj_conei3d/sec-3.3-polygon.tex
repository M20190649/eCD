
\subsection{A fast regular polygon intersection method}


Observe that the algorithm of ~\cite{ORourke:Intersection} is for general convex polygons, while the approximate polygons are special polygons. We further develop an even fast approximate polygon intersection method based on the properties of approximate polygons.
%
The presented approximate polygon intersection algorithm is indeed a customized version of the convex polygon algorithm of ~\cite{ORourke:Intersection}.
%
Given intersection polygon $\mathcal{G}^*_k$ of the preview $k$ polygons and the next approximate polygon $\mathcal{G}_{k+1}$, the algorithm returns $\mathcal{G}^*_{k+1} = \mathcal{G}^*_k  \bigcap \mathcal{G}_{k+1}$.






%%%%%%%%%%%%%%%%%%%%%Baseline Algorithm
\begin{figure}[tb!]
\begin{center}
{\small
\begin{minipage}{3.36in}
\myhrule
\vspace{-1ex}
\mat{0ex}{
	{\bf Algorithm} ~$RegularPolyInter$($\mathcal{G}^*_k$, $\mathcal{G}_{k+1}$) \\
	\bcc \hspace{2ex}\=  Set $A$ and $B$ {arbitrarily} on $\mathcal{G}^*_k$ and $\mathcal{G}_{k+1}$\\
	\icc \>\hspace{0ex}\= Repeat \\
	\icc \>\hspace{3ex} If $A$ intersects $B$ Then \\
	\icc \>\hspace{6ex} {Check for termination.} \\
	\icc \>\hspace{6ex} Update an inside flag. \\
	\icc \>\hspace{6ex} \textcolor[rgb]{0.00,0.00,1.00}{Moves on either $A$ or $B$ multiple steps.}\\
	\icc \>\hspace{3ex} Else \\
	\icc \>\hspace{6ex} Moves on either $A$ or $B$.\\
	\icc \hspace{1ex} Until both $A$ and $B$ cycle their polygons \\
	\icc \hspace{0ex} Handle $\mathcal{G}^*_k \subset \mathcal{G}_{k+1}$ and $\mathcal{G}^*_k \subset \mathcal{G}_{k+1}$ and $\mathcal{G}^*_k \bigcap \mathcal{G}_{k+1} = \phi$ cases \\
    \icc \hspace{0ex} Return $\mathcal{G}^*_k \bigcap \mathcal{G}_{k+1}$
}
\vspace{-2ex}
\myhrule
\end{minipage}
}
\end{center}
\vspace{-2ex}
\caption{\small Intersection of Regular polygons.}
\label{alg:r-poly-inter}
\vspace{-2ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%






\stitle{\textcolor[rgb]{0.00,0.07,1.00}{Regular polygon intersection algorithm}}
Given two approximate polygons $\mathcal{G}^*_k$ and $\mathcal{G}_{k+1}$, and the candidate intersection edges, the algorithm returns the intersection polygon (may be null).

The sketch of the algorithm is shown in Figure~\ref{alg:r-poly-inter}.

Let $A$ and $B$ be directed edges on $\mathcal{G}^*_k$ and $\mathcal{G}_{k+1}$ respectively. The algorithm has $A$ and $B$ ``chasing" one another. During the chasing, $A$ or $B$ moves on step by step in the counterclockwise order, following some rules designed depending on geometric conditions, as described in ~\cite{ORourke:Intersection}.






\begin{figure}[tb!]
\centering
\includegraphics[scale=0.88]{figures/Fig-r-poly-inter.png}
\vspace{-1ex}
\caption{\small A running example of intersection of polygons.}
\vspace{-2ex}
\label{fig:r-poly-inter}
\end{figure}




\begin{example}
Figure~\ref{fig:r-poly-inter} is a running example of the approximate polygon intersection algorithm.
Initially, the candidate edges are marked and directed edges $A$ and $B$ are on polygons $\mathcal{G}_{k+1}$ and $\mathcal{G}^*_{k}$ separately

\ni (1) Initially, directed edges $A$ and $B$ are on polygons $\mathcal{G}_{k+1}$ and $\mathcal{G}^*_{k}$ separately. $A \bigcap B = P_1$.

\ni (2) $A$ moves forward a 4-steps. $A \bigcap B = \phi$.

\ni (3) After 4 steps of moving, $A \bigcap B = P_2$

\ni (4) $B$ moves forward a 2-steps. $A \bigcap B = \phi$.

\ni (5) After 5 steps of moving, both $A$ and $B$ cycle their polygons;

\ni (6) At last, it returns the intersection polygon.
\end{example}






