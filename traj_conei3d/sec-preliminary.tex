\section{Preliminaries}
\label{sec-preliminary}
In this section, we introduce basic concepts and cone intersection based one-pass algorithms using the perpendicular Euclidean distances for trajectory compression.
%\textcolor[rgb]{1.00,0.00,0.00}{A discussion and summary is presented in the last.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Cone Intersection
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[tb!]
\centering
\includegraphics[scale=0.8]{figures/Fig-sleeve.png}
\vspace{-2ex}
\caption{\small The trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_{10}]$ in Figure~\ref{fig:notations} is compressed into two line segments by the Sector Intersection algorithm.}
\vspace{-3ex}
\label{fig:sleeve}
\end{figure*}



\subsection{Basic Notations}
We first introduce basic notations.


\stitle{Points ($P$)}. A data point is defined as a triple $P(x, y, t)$, which represents that a moving object is located at {\em longitude} $x$ and {\em latitude} $y$ at {\em time} $t$. Note that data points can be viewed as points in a three-dimension Euclidean space.

\stitle{Trajectories ($\dddot{\mathcal{T}}$)}. A trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_n]$ is a sequence of data points in a monotonically increasing order of their associated time values (\ie $P_i.t < P_j.t$ for any $0\le i<j\le n$). Intuitively, a trajectory is the path (or track) that a moving object follows through space as a function of time~\cite{physics-trajectory}.


\stitle{Directed line segments ($\mathcal{L}$)}. A directed line segment (or line segment for simplicity) $\mathcal{L}$ is defined as $\vv{P_{s}P_{e}}$, which represents the closed line segment that connects the start point $P_s$ and the end point $P_e$.
Note that here $P_s$ or $P_e$ may not be a point in a trajectory $\dddot{\mathcal{T}}$, and hence, we also use notation $\mathcal{R}$ instead of $\mathcal{L}$ when both $P_s$ and $P_e$ belong to $\dddot{\mathcal{T}}$.

We also use $|\mathcal{L}|$ and $\mathcal{L}.\theta\in [0, 2\pi)$ to denote the length of a directed line segment $\mathcal{L}$, and its angle with the $x$-axis of the coordinate system $(x, y)$, where $x$ and $y$ are the longitude and latitude, respectively.
That is, a directed line segment $\mathcal{L}$ = $\vv{P_{s}P_{e}}$ can be treated as a triple $(P_s, |\mathcal{L}|, \mathcal{L}.\theta)$.

\stitle{Piecewise line representation ($\overline{\mathcal{T}}$)}. A piece-wise line representation $\overline{\mathcal{T}}[\mathcal{L}_0, \ldots , \mathcal{L}_m]$ ($0< m \le n$) of a trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_n]$ is a sequence of continuous directed line segments $\mathcal{L}_{i}$ = $\vv{P_{s_i}P_{e_i}}$ of $\dddot{\mathcal{T}}$ ($i\in[0,m]$)  such that $\mathcal{L}_{0}.P_{s_0} = P_0$, $\mathcal{L}_{m}.P_{e_m} = P_n$ and  $\mathcal{L}_{i}.P_{e_i}$ = $\mathcal{L}_{i+1}.P_{s_{i+1}}$ for all $i\in[0, m-1]$. Note that each directed line segment in $\overline{\mathcal{T}}$ essentially represents a continuous sequence of data points in $\dddot{\mathcal{T}}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\eat{
\subsubsection{Notations of error metrics}

{For line simplification, there are distance based and shape based error metrics\cite{Shi:Survey} that measure the errors between the original trajectory and the simplified trajectory.
However, for trajectory simplification, the distance based metrics are definitely the distinct metrics.}

\stitle{Included angles ($\angle$)}. Given two directed line segments $\mathcal{L}_1$ = $\vv{P_{s}P_{e_1}}$ and $\mathcal{L}_2$ = $\vv{P_{s}P_{e_2}}$ with the same start point $P_s$, the included angle from $\mathcal{L}_1$ to $\mathcal{L}_2$, denoted as $\angle(\mathcal{L}_1, \mathcal{L}_2)$,  is $\mathcal{L}_2.\theta - \mathcal{L}_1.\theta$. For convenience, we also represent the included angle  $\angle(\mathcal{L}_1, \mathcal{L}_2)$ as $\angle{P_{e_1}P_sP_{e_2}}$.
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\stitle{Perpendicular Euclidean Distances (\ped)}. Given a data point $P$ and a directed line segment $\mathcal{L}$ = $\vv{P_{s}P_{e}}$, the perpendicular Euclidean distance (or simply perpendicular distance) $ped(P, \mathcal{L})$ of $P$ to $\mathcal{L}$  is the Euclidean distance of $P$ to line $\overline{P_{s}P_{e}}$, adopted by many trajectory simplification methods, \eg~\cite{Douglas:Peucker, Hershberger:Speeding, Liu:BQS, Williams:Longest, Sklansky:Cone, Dunham:Cone, Zhao:Sleeve, Lin:Operb}.


\stitle{Synchronized points}. Given a sub-trajectory $\dddot{\mathcal{T}}_s[P_s, \ldots, P_e]$, the synchronized point $P'$ of a data point  $P \in \dddot{\mathcal{T}}_s$, ~\wrt line segment $\vv{P_sP_e}$ is defined as follows:
(1) $P'.x$ = $P_s.x +  c\cdot(P_e.x - P_s.x)$,
(2) $P'.y$ = $P_s.y +  c\cdot(P_e.y - P_s.y)$ and
(3) $P'.t$ = $P.t$, where $c= \frac{P.t-P_s.t}{P_e.t-P_s.t}$.


\stitle{Synchronous Euclidean Distances (\sed)}. Given a data point $P$ and a directed line segment $\mathcal{L}$ = $\vv{P_{s}P_{e}}$, the synchronous Euclidean distance (or simply synchronous distance) $sed(P, \mathcal{L})$ of $P$ to $\mathcal{L}$ is $|\vv{PP'}|$ that is the Euclidean distance from $P$ to its synchronized data point $P'$ \wrt $\mathcal{L}$. %, adopted by recent trajectory simplification methods~\cite{Meratnia:Spatiotemporal, Potamias:Sampling, Chen:Fast, Muckell:Compression, Popa:Spatio}.


We illustrate these notations with examples.


\begin{example}
\label{exm-notations}
Consider Figure~\ref{fig:notations}, in which

\sstab(1) $\dddot{\mathcal{T}}[P_0$, $\ldots, P_{10}]$ is a trajectory having eleven data points,

\sstab (2) the set of two continuous line segments $\{\vv{P_0P_4}$, $\vv{P_4P_{10}}$\} (Left) and the set of four continuous line segments $\{\vv{P_0P_2}$, $\vv{P_2P_4}$, $\vv{P_4P_7}$, $\vv{P_7P_{10}}$\} (Right) are two piecewise line representations of trajectory $\dddot{\mathcal{T}}$,

\sstab(3) $ped(P_4, \vv{P_0P_{10}})=|\vv{P_4P^*_4}|$, where $P^*_4$ is the perpendicular point of $P_4$ \wrt line segment $\vv{P_0P_{10}}$, and

\sstab (4) $sed(P_4, \vv{P_0P_{10}})= |\vv{P_4P'_4}|$, $sed(P_2, \vv{P_0P_{4}})= |\vv{P_2P'_2}|$ and $sed(P_7, \vv{P_4P_{10}})$ $=$ $|\vv{P_7P'_7}|$,
where points $P'_4$, $P'_2$ and $P'_7$ are the synchronized points of points $P_4$, $P_2$ and $P_7$ \wrt line segments $\vv{P_0P_{10}}$, $\vv{P_0P_{4}}$ and $\vv{P_4P_{10}}$, respectively.
\end{example}

\stitle{Error bounded algorithms}. Given a trajectory \trajec{T} and its compression  algorithm $\mathcal{A}$ using \sed (respectively \ped) that produces another trajectory \trajec{T'},
we say that algorithm $\mathcal{A}$ is error bounded by $\epsilon$ if  for each point $P$ in \trajec{T}, there exists a point $P_j$ in \trajec{T'} such that the  $sed(P, \mathcal{L}(P_j,P_{j+1}))\le \epsilon$ (respectively $ped(P, \mathcal{L}(P_j,P_{j+1}))\le \epsilon$).



We summarize notations used in Table~\ref{tab:notations}.

\begin{table}
\caption{\small Summary of notations}
\vspace{-2ex}
\centering
\footnotesize
\begin{tabular}{|c|l|}
\hline
\kw{Notations}& \kw{Semantics}   \\
\hline %\hline
 $P$ & a data point \\
\hline
 $\dddot{\mathcal{T}}$ & a trajectory $\dddot{\mathcal{T}}$ is a sequence of data points\\
\hline
$\mathcal{L}$ & a directed line segment  \\
\hline
$\overline{\mathcal{T}}$&  a piece-wise line representation $\overline{\mathcal{T}}$ \\
\hline
$ped(P, \mathcal{L})$ & the perpendicular Euclidean distance of $P$ to $\mathcal{L}$\\
\hline
$sed(P, \mathcal{L})$ & the synchronous Euclidean distances of $P$ to $\mathcal{L}$\\
\hline
$\epsilon$ & the error bound \\
\hline
\sector{} & a sector\\
\hline
$\vv{A} \times \vv{B}$ & the cross product of (vectors) $\vv{A}$ and $\vv{B}$\\
\hline
$\mathcal{H}(\mathcal{L})$ & The open half-plane to the left of $\mathcal{L}$ \\
\hline
$\mathcal{G}$& a convex polygon \\
\hline
$\mathcal{G}^*$ & the intersection of convex polygons \\
\hline
$m$ & the max number of vertexes/edges of a polygon\\
\hline
$E^j$ & a group of edges labeled with $j$\\
\hline
$g(e)$ & the label of edge $e$ \\
\hline
\circle{} & a synchronous circle\\
\hline
\cone{} & a spatio-temporal cone \\
\hline
\pcircle{} & a cone projection circle \\
\hline
$\bigsqcap$ & intersection of geometries\\
\hline
\end{tabular}
\label{tab:notations}
\vspace{-3ex}
\end{table}




\subsection{Sector Intersection based Algorithms using \ped}
\label{sub-ci-ped}


The sector intersection (\cia) algorithm \cite{Williams:Longest, Sklansky:Cone} was developed for graphic and pattern recognition in the late 1970s, for the approximation of arbitrary planar curves by linear segments or finding a polygonal approximation of a set of input data points in a 2D Cartesian coordinate system. The \sleeve algorithm \cite{Zhao:Sleeve} in the cartographic discipline essentially applies the same idea as the \cia algorithm.
Further, \cite{Dunham:Cone}  optimized algorithm \cia by considering the distance between a potential end point and the initial point of a line segment. It is worth pointing out that all these \cia based algorithms use the perpendicular Euclidean distances.

%Note that these notable algorithms are not introduced to the discipline of trajectory compression.
%though these notable algorithms are famous in disciplines of graphic and pattern recognition,

Given a sequence of data points $[P_{s}, P_{s+1}, \ldots, P_{s+k}]$ and an error bound $\epsilon$, the \cia based algorithms process the input points one by one in order, and produce a simplified polyline.  Instead of using the distance threshold $\epsilon$ directly, the \cia based algorithms convert the distance tolerance into a variable angle tolerance for testing the points.

For the start point $P_s$ and any point $P_{s+i}$ ($i\in[1, k]$), there are two different lines $\vv{P_sP^u_{s+i}}$ and $\vv{P_sP^l_{s+i}}$ such that $ped(P_i, \vv{P_sP^u_{s+i}})$ $=$ $ped(P_i, \vv{P_sP^l_{s+i}}) = \epsilon$ and $\vv{P_sP^l_{s+i}}.\theta < \vv{P_sP^u_{s+i}}.\theta$. Indeed, they forms a \emph{sector} \sector{(P_s, P_{s+i}, \epsilon)} that takes $P_s$ as the center point and $\vv{P_sP^u_{s+i}}$ and $\vv{P_sP^l_{s+i}}$ as the border lines.
% , where $P_s$ is the center point, and $\vv{P_sP^l_{s+i}}$ and $\vv{P_sP^l_{s+i}}$ are two bound lines.
Then there exists a data point $Q$ such that for any data point $P_{s+i}$ ($i \in [1, ... k]$), its \ped to
line $\overline{P_sQ}$ is no greater than the error bound $\epsilon$ if and only if there $k$ sectors \sector{(P_s, P_{s+i}, \epsilon)} ($i\in[1,k]$) share common data points other than $P_s$, \ie $\bigsqcap_{i=1}^{k}$\sector{(P_s, P_{s+i}, \epsilon)} $\ne \{P_s\}$ \cite{Williams:Longest, Sklansky:Cone,Zhao:Sleeve}.

The point $Q$ may not belong to $\{P_{s}, P_{s+1},$ $\ldots, P_{s+k}\}$.
However, if $P_{s+i}$ ($1\le i\le k$) is chosen as $Q$, then
for any data point $P_{s+i}$ ($i \in [1, ... i]$), its \ped to
line $\overline{P_sP_{s+i}}$ is no greater than the error bound $\epsilon$ if and only if $\bigsqcap_{j=1}^{i}$\sector{(P_s, P_{s+i}, \epsilon/2)} $\ne \{P_s\}$, as pointed out in \cite{Zhao:Sleeve}.

 That is, {\em these \cia based algorithms can be easily adopted for trajectory compression although they have been overlooked by existing trajectory simplification studies}.  It is also worth pointing out that the \cia based algorithms  run in $O(n)$ time and $O(1)$ space, and are one-pass algorithms.

We next illustrate how the \cia based algorithms can be used for trajectory compression.

%Note that it runs in a 2D plane, and the \sed is not supported in the algorithm.


\begin{example}
\label{exm-alg-sleeve}
Consider Figure~\ref{fig:sleeve}. A \cia based algorithm takes as input a trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_{10}]$, and returns a simplified ployline consisting of two line segments $\vv{P_0P_4}$ and  $\vv{P_4P_{10}}$.

\sstab(1) Initially, $P_0$ is the start point. Point $P_1$ is firstly read, and the sector \sector{(P_0, P_{1}, \epsilon/2)} of $P_1$ is created as shown in Figure~\ref{fig:sleeve}.(1).
Then $P_2$ is read, and the sector \sector{(P_0, P_{2}, \epsilon/2)}  is created for $P_2$. The intersection of sectors \sector{(P_0, P_{1}, \epsilon/2)} and  \sector{(P_0, P_{2}, \epsilon/2)} contains data points other than $P_0$  which has an up border line $P_0P_2^u$ and a low border line $P_0P_1^l$, as shown in Figure~\ref{fig:sleeve}.(2).
Similarly, points $P_3$ and $P_4$ are processed, as shown in Figures~\ref{fig:sleeve}.(3) and \ref{fig:sleeve}.(4), respectively.

\sstab(2) When point $P_5$ is read,  line segment $\vv{P_0P_4}$ is produced, and point $P_4$ becomes the start point, as $\bigsqcap_{i=1}^{4}$\sector{(P_0, P_{s+1}, \epsilon/2)} $\ne\{P_0\}$ and $\bigsqcap_{i=1}^{5}$\sector{(P_0, P_{s+1}, \epsilon/2)} $=\{P_0\}$ as shown in Figure~\ref{fig:sleeve}.(5).


\sstab(3) Points $P_5, \ldots, P_{10}$ are processed similarly one by one in order, and finally the algorithm outputs another line segment $\vv{P_4P_{10}}$ as shown in Figure~\ref{fig:sleeve}.(5).
\end{example}




\subsection{Intersection Computation of Convex Polygons}
\label{subsec-cpi}

We also employ a convex polygon intersection algorithm in~\cite{ORourke:Intersection}, whose basic idea is straightforward.
Assume \kwlog that the edges of polygons $\mathcal{G}_1$ and $\mathcal{G}_2$ are oriented counterclockwise, and $\vv{A} = (P_{s_A}, P_{e_A})$ and $\vv{B} = (P_{s_B}, P_{e_B})$ are two (directed) edges on $\mathcal{G}_2$ and $\mathcal{G}_1$, repectively (see Figure~\ref{fig:c-poly-inter}).

The algorithm has $\vv{A}$ and $\vv{B}$ ``chasing'' one another, \ie moves $\vv{A}$ on $\mathcal{G}_1$ and $\vv{B}$ on $\mathcal{G}_1$ counter-clockwise step by step under certain rules, so that they meet at every crossing of $\mathcal{G}_1$ and $\mathcal{G}_2$.
%
The rules, called \emph{advance rules}, are carefully designed depending on geometric conditions of $\vv{A}$ and $\vv{B}$.
%If $\vv{B}$ ``aims toward" the line containing $\vv{A}$, but does not cross it, then we want to advance $\vv{B}$ in order to ``close in" on a possible intersection with A.
Let $\vv{A} \times \vv{B}$ be the cross product of (vectors) $\vv{A}$ and $\vv{B}$, and $\mathcal{H}(\vv{A})$ be the open half-plane to the left of $\vv{A}$, the rules are as follows:

\sstab {\em Rule (1)}: If $\vv{A} \times \vv{B} < 0$ and $P_{e_A} \not \in \mathcal{H}(\vv{B})$, or $\vv{A} \times \vv{B} > 0$ and $P_{e_B} \in \mathcal{H}(\vv{A})$, then $\vv{A}$ is advanced a step.

For example, in Figure~\ref{fig:c-poly-inter}.(1) and ~\ref{fig:c-poly-inter}.(2), $\vv{A}$ moves forward a step as  $\vv{A} \times \vv{B} > 0$ and $P_{e_B} \in \mathcal{H}(\vv{A})$.

\sstab {\em Rule (2)}: If $\vv{A} \times \vv{B} > 0$ and $P_{e_B} \not \in \mathcal{H}(\vv{A})$, or $\vv{A} \times \vv{B} < 0$ and $P_{e_A} \in \mathcal{H}(\vv{B})$, then  $\vv{B}$ is advanced a step.

For example, in Figure~\ref{fig:c-poly-inter}.(6) and ~\ref{fig:c-poly-inter}.(7), $\vv{B}$ moves forward a step as $\vv{A} \times \vv{B} < 0$ and $P_{e_A} \in \mathcal{H}(\vv{B})$.


\begin{figure}[tb!]
\centering
\includegraphics[scale=0.88]{figures/Fig-convex-poly-inter.png}
\vspace{-2ex}
\caption{\small A running example of convex polygons intersection.}
\vspace{-2ex}
\label{fig:c-poly-inter}
\end{figure}


\stitle{Algorithm \cpia}. The complete algorithm is shown in Figure~\ref{alg:c-poly-inter}.
Given polygons $\mathcal{G}_1$ and $\mathcal{G}_2$, algorithm \cpia first arbitrarily sets $\vv{A}$ and $\vv{B}$ on $\mathcal{G}_2$ and $\mathcal{G}_1$, respectively (line 1).
%
It then checks the intersection of $\vv{A}$ and $\vv{B}$. If $\vv{A}$ intersects $\vv{B}$ (line 3), then the algorithm checks for some special termination conditions (\eg if $\vv{A}$ and $\vv{B}$ are overlapped and, at the same time, $\mathcal{G}_1$ and $\mathcal{G}_2$ are on the opposite sides of the overlapped edges, then the process is terminated) (line 4), and records the inner edge, which is a boundary segment of the intersection polygon (line 5).
After that, the algorithm moves on $\vv{A}$ or $\vv{B}$ one step under the advance rules (lines 6--11).
The above processes repeated, until both $\vv{A}$ and $\vv{B}$ cycle their polygons (line 12).
%
Next, the algorithm handles three special cases of the two polygons, \ie $\mathcal{G}_1$ is inside of $\mathcal{G}_2$, $\mathcal{G}_2$ is inside of $\mathcal{G}_1$ and $\mathcal{G}_1 \bigsqcap \mathcal{G}_2 = \emptyset$ cases (line 13).
%
At last, it returns the intersection polygon (line 14).


The algorithm has a time complexity of $O(|\mathcal{G}_1| + |\mathcal{G}_2|)$, where $|\mathcal{G}|$ is the number of edges of polygon $\mathcal{G}$.
It is worth to point out that $|\mathcal{G}_1 \bigsqcap \mathcal{G}_2| \le (|\mathcal{G}_1| + |\mathcal{G}_2|)$.




\begin{example}
Figure~\ref{fig:c-poly-inter} shows a running example of the convex polygon intersection algorithm \cpia.

\sstab(1) Initially, directed edges $\vv{A}$ and $\vv{B}$ are on polygons $\mathcal{G}_2$ and $\mathcal{G}_1$, respectively, such that $\vv{A} \bigsqcap \vv{B} = \{P_1\}$, \ie $\vv{A}$ and $\vv{B}$ intersect on point $P_1$, as shown in Figure~\ref{fig:c-poly-inter}.(1).

\sstab(2) Then, by the advance rules, edge $\vv{A}$ moves on a step and makes $\vv{A} \bigsqcap \vv{B} = \emptyset$ as shown in Figure~\ref{fig:c-poly-inter}.(2).
After 7 steps of moving of $\vv{A}$ or $\vv{B}$, each by an advance rule, edges $\vv{A}$ and $\vv{B}$ intersect on point $P_2$, as shown in Figure~\ref{fig:c-poly-inter}.(6).

\sstab(3) Next, edge $\vv{B}$ moves on a step, and makes $\vv{A} \bigsqcap \vv{B} = \emptyset$, as shown in Figure~\ref{fig:c-poly-inter}.(7).
After 6 steps of moving of edge $\vv{B}$ or $\vv{A}$ one by one, both edges $\vv{A}$ and $\vv{B}$ have finished their cycles as shown in Figure~\ref{fig:c-poly-inter}.(8).

\sstab(4) The algorithm finally returns the intersection polygon as shown in Figure~\ref{fig:c-poly-inter}.(9).
\end{example}





%%%%%%%%%%%%%%%%%%%%%Baseline Algorithm
\begin{figure}[tb!]
\begin{center}
{\small
\begin{minipage}{3.36in}
\myhrule
\vspace{-1ex}
\mat{0ex}{
	{\bf Algorithm} ~\cpia($\mathcal{G}_1$, $\mathcal{G}_2$) \\
	\bcc \hspace{1ex}\=  \SET $\vv{A}$ and $\vv{B}$ {arbitrarily} on $\mathcal{G}_1$ and $\mathcal{G}_2$\\
	\icc \hspace{1ex}\= \Repeat \\
	\icc \>\hspace{2ex} \If $\vv{A} \bigsqcap \vv{B} \ne \emptyset$ \Then \\
	\icc \>\hspace{4ex} {Check for termination.} \\
	\icc \>\hspace{4ex} Update an inside flag. \\
	\icc \> \hspace{2ex} \If ($\vv{A}\times\vv{B} < 0$ \And $P_{e_A} \not \in \mathcal{H}(\vv{B})$) \Or \\
	\icc \> \hspace{4ex} ($\vv{A} \times \vv{B} > 0$ \And $P_{e_B} \in \mathcal{H}(\vv{A})$) \Then \\
	\icc \> \hspace{4ex} advance $\vv{A}$ one step \\
	\icc \> \hspace{2ex} \ElseIf ($\vv{A} \times \vv{B} > 0$ \And $P_{e_B} \not \in \mathcal{H}(\vv{A})$) \Or\\
	\icc \> \hspace{4ex}  ($\vv{A} \times \vv{B} < 0$ \And $P_{e_A} \in \mathcal{H}(\vv{B})$) \Then \\
	\icc \> \hspace{4ex} advance $\vv{B}$ one step \\
	\icc \hspace{0ex} \Until both $\vv{A}$ and $\vv{B}$ cycle their polygons \\
	\icc \hspace{0ex} \Handle $\mathcal{G}_1 \subset \mathcal{G}_2$ and $\mathcal{G}_2 \subset \mathcal{G}_1$ and $\mathcal{G}_1 \bigsqcap \mathcal{G}_2 = \emptyset$ cases \\
    \icc \hspace{0ex} \Return $\mathcal{G}_1 \bigsqcap \mathcal{G}_2$
}
\vspace{-2ex}
\myhrule
\end{minipage}
}
\end{center}
\vspace{-2ex}
\caption{\small Algorithm for convex polygons intersection~\cite{ORourke:Intersection}.}
\label{alg:c-poly-inter}
\vspace{-2ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\eat{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\vspace{-3ex}
\subsection{Problem Definition}
This paper focus on the \emph{min-$\#$ problem} \cite{Chan:Optimal, Imai:Optimal,Pavlidis:Segment} of trajectory simplification.
Given a trajectory \trajec{T}$[P_0, \dots, P_n]$ and a pre-specified constant $\epsilon$, a trajectory simplification algorithm $\mathcal{A}$ approximates \trajec{T} by $\overline{\mathcal{T}}[\mathcal{L}_0, \ldots , \mathcal{L}_m]$ ($0< m \le n$), where on
each of them the data points $[P_{s_i}, \dots, P_{e_i}]$ are approximated by a line segment $\mathcal{L}_i = \vv{P_{s_i}P_{e_i}}$ with the maximum error of  $ped(P_j, \mathcal{L}_i)$ or $sed(P_j, \mathcal{L}_i)$, $s_i < j<e_i$,  less than $\epsilon$.
The optimal methods that find the minimal $m$, having the time complexity of $O(n^2)$\cite{Chan:Optimal},
making it impractical for large inputs\cite{Heckbert:Survey}.
Hence, this paper evaluates the distinct sub-optimal methods.



\begin{figure}[tb!]
\label{fig:scope}
\centering
\includegraphics[scale=0.8]{figures/Fig-scope.png}
\vspace{-1ex}
\caption{Example \emph{scopes} of Synchronous points. The Synchronous point $P'$ has (1) a circle scope  when using \sed, and (2) a rectangle scope when using \ded.}

\vspace{-2ex}
\end{figure}

%Given a line $\overline{P_sP_e}$, a Synchronous point $P'$ on line $\overline{P_sP_e}$ and a error bound $\epsilon_s$ of ~\sed (or error bounds $\epsilon_p$ and $\epsilon_r$ of \ded), all points potentially be compressed to a Synchronous point $P'$ forms a \emph{scope} of $P'$ (Fig.\ref{fig:scope}). The \emph{scope} of $P'$ in \sed is a circle around $P'$ whose radius is less than the \sed error bound $\epsilon_s$, and the \emph{scope} of $P'$ in \ded is a rectangle, paralleling to the line $\overline{P_sP_e}$, taking $P'$ as the central point and whose height and width are less than the \ded error bounds $\epsilon_p$ and $\epsilon_r$ respectively. With he help of \ded, one can set the value of $\epsilon_p$ and $\epsilon_r$ separately according to varied application requirements, \eg a smaller $\epsilon_p$ to limit the perpendicular deviation of the car to the road while a bigger $\epsilon_r$ to ensure a better compression ratio.
}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
