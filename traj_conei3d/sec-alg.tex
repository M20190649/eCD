\section{One-Pass Trajectory Simplification}
\label{sec-alg}

Following \cite{Trajcevski:DDR,Lin:Operb}, we consider two classes of trajectory simplification.
The first one, referred to as \emph{strong simplification}, that takes as input a trajectory \trajec{T} and an error bound $\epsilon$, and produces
a simplified trajectory \trajec{T'} such that all data points in \trajec{T'} belongs to \trajec{T}.
The second one, referred to as \emph{weak simplification}, that takes input a trajectory \trajec{T} and an error bound $\epsilon$, and produces
a simplified trajectory \trajec{T'} such that some data points in \trajec{T'} may not belong to \trajec{T}. That is,  weak simplification allows data interpolation. %,commonly used in polygonal curve approximation \cite{Williams:Bounded, Heckbert:Survey, Zhao:Sleeve}, time series approximation \cite{ORourke:Fitting, Elmeleegy:Stream, Xie:Stream, Luo:Streaming} and trajectory simplification \cite{Lin:Operb}.


The main result here is stated as follows.

\begin{theorem}
\label{prop-cist-complexity}
There exist one-pass error bounded trajectory simplification algorithms using the synchronous distance for both strong and weak trajectory simplification.
\end{theorem}

We shall prove this by providing such algorithms for both strong and weak trajectory simplification, by employing the constant time synchronous distance checking technique developed in Section~\ref{sec-localcheck}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{{One-pass algorithm}}
\subsection{Strong Trajectory Simplification}
Recall that in Proposition~\ref{prop-3d-ci}, the point $Q$ may not be in the input sub-trajectory $[P_s,...,P_{s+k}]$.
If we restrict $Q=P_{s+k}$, the end point of the sub-trajectory, then the cone projection circles with a radius of $\epsilon/2$ suffice.

\begin{prop}
\label{prop-3d-ci-half}
Given a sub-trajectory $[P_s,...,P_{s+k}]$ and an error bound $\epsilon$, $sed(P_{s+i}, \vv{P_sP_{s+k}})\le \epsilon$ for each $i \in [1,k]$ if and only if $\bigsqcap_{i=1}^{k}$\cone{(P_s, \mathcal{O}(P_{s+i}, \epsilon/2))} $\ne \{P_s\}$.
\end{prop}


\begin{proof}
If $\bigsqcap_{i=s+1}^{e}{\mathcal{C}(P_s, P_{s+i}, \epsilon/2)} \ne \{P_s\}$, then by Proposition~\ref{prop-3d-ci}, there exists a point $Q$, $Q.t = P_{s+k}.t$, such that $sed(P_{s+i}, \vv{P_sQ})\le \epsilon/2$ for all $i \in [1,k]$. By the triangle inequality essentially, $sed(P_{s+i}, \vv{P_sP_{s+k}})\le  sed(P_{s+i}, \vv{P_sQ}) + |\vv{QP_{s+k}}| \le  \epsilon/2+\epsilon/2 = \epsilon$.
\end{proof}



%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[tb!]
\begin{center}
{\small
\begin{minipage}{3.36in}
\myhrule
\vspace{-1ex}
\mat{0ex}{
	{\bf Algorithm} ~\cist$(\dddot{\mathcal{T}}[P_0,\ldots,P_n],~\epsilon,~m)$\\
%	\sstab
	\bcc \hspace{1ex}\= $P_s := P_0$; ~$i := 1$;  ~$\mathcal{G}^* := \emptyset$;  ~$t_c$ := $P_n.t$; ~$\overline{\mathcal{T}} := \emptyset$; \\
	\icc \hspace{1ex}\= \While $i \le n$ \Do \\
	\icc \>\hspace{2ex} $\mathcal{G}$ := \kw{getRegularPolygon}($P_s$, $P_i$, $\epsilon/2$, $m$, $t_c$); \\
	\icc \>\hspace{2ex} \If $\mathcal{G}^* = \emptyset$  \Then \hspace{3ex} /* $\mathcal{G}^*$ needs to be initialized */\\
    \icc \>\hspace{2ex} \ \ \ $\mathcal{G}^* :=\mathcal{G};$ \\
    \icc \>\hspace{2ex} \Else \\
    \icc \>\hspace{2ex}\ \ \ \ $\mathcal{G}^* := {\rpia}(\mathcal{G}^*, ~\mathcal{G})$; \\
    \icc \>\hspace{4ex} \If $\mathcal{G}^* = \emptyset$ \Then \hspace{3ex} /* generate a new line segment */\\
    \icc \> \hspace{4ex} \ \ \ $i$ := $i - 1$;\ \ $\overline{\mathcal{T}} := \overline{\mathcal{T}}\cup \{\vv{P_sP_{i}}\}$; \ \ $P_s := P_{i}$;\\
    \icc \>\hspace{2ex} $i$ := $i +1$;\\
 	\icc \> \hspace{0ex} $\overline{\mathcal{T}}$ := $\overline{\mathcal{T}}\cup \{\vv{P_sP_{n}}\}$; \\
    \icc \hspace{1ex}\Return $\overline{\mathcal{T}}$.
\\
\\
	{\bf Procedure} ~\kw{getRegularPolygon}$(P_s,~P_i,~r,~m,~t_c)$ \\
%	\bcc \hspace{1ex} \textcolor[rgb]{0.00,0.07,1.00}{Transform $P_s$ and $P_i$ to points in Cartesian coordinates} \\
	\bcc \hspace{1ex} $c := (t_c-t_s)/(P_i.t - P_s.t)$; \\
	\icc \hspace{1ex} $x := P_s.x + c\cdot(P_i.x-P_s.x)$; \\
	\icc \hspace{1ex} $y := P_s.y + c\cdot(P_i.y-P_s.y)$; \\
	\icc \hspace{1ex} \For $(j := 1;j \le m;j++)$ \Do \\
	\icc \> \hspace{2ex} $\theta :=  (2j + 1)*\pi /m $; \\
	\icc \> \hspace{2ex} $\mathcal{G}.v_j.x := x + c\cdot r\cdot\cos\theta$;\\
	\icc \> \hspace{2ex} $\mathcal{G}.v_j.y := y + c\cdot r\cdot\sin\theta$;\\
	\icc \hspace{1ex} \Return $\mathcal{G}$.
}
\vspace{-2ex}
\myhrule
\end{minipage}
}
\end{center}
\vspace{-2ex}
\caption{\small One-pass strong trajectory  simplification algorithm.}
\label{alg:CI3d}
\vspace{-3ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


 We first present the  one-pass error bounded {\em strong trajectory simplification} algorithm using the synchronous distance, which is shown in Figure~\ref{alg:CI3d}.

\stitle{Procedure \kw{getRegularPolygon}}.
We first present procedure \kw{getRegularPolygon} that given a cone projection circle, generates its inscribed $m$-edge regular polygon,  following the definition in Section~\ref{subsec-RPI}.

The parameters $P_s$, $P_i$, $r$ and $t_c$ together forms the projection circle \pcircle{(P^c_i, r^c_i)} of the spatio-temporal cone \cone{(P_s, \mathcal{O}(P_{i}, r))} of point $P_{i}$ \wrt point $P_s$ on the plane $P.t - t_c$ = $0$. Firstly, $P^c_i.x$ and $P^c_i.y$ are computed (lines 1--3), and $r^c_i = c\cdot r$.
Then it builds and returns an $m$-edge inscribed regular polygon $\mathcal{G}$ of \pcircle{(P^c_i, r^c_i)} (lines 4--8), by transforming a polar coordinate system
into a Cartesian one. Note that here $\theta$, $r\cdot\sin\theta$ and $r\cdot\cos\theta$ only need to computed once during the entire processing of a trajectory.

\stitle{Algorithm \cist}. We now present algorithm Algorithm \cist. It takes as input a trajectory \trajec{T}${[P_0, \ldots, P_n]}$, an error bound $\epsilon$ and the number $m$ of edges for inscribed regular polygons, and returns a simplified  piece-wise line representation $\overline{\mathcal{T}}$ of $\dddot{\mathcal{T}}$.



The algorithm first initializes the start point $P_s$ to $P_0$, the index $i$ of the current data point to $1$, the intersection polygon $\mathcal{G}^*$ to $\emptyset$, the projection plane $P.t - P_n.t = 0$, the output $\overline{\mathcal{T}}$ to $\emptyset$, respectively (line 1).
%
The algorithm sequentially processes the data points of the trajectory one by one  (lines 2--10). It gets the $m$-inscribed regular polygon \wrt the current point $P_i$ (line 3) by calling procedure $\kw{getRegularPolygon}$. When $\mathcal{G}^* = \emptyset$, $\mathcal{G}^*$ is simply initialized as $\mathcal{G}$ (lines 4, 5). Otherwise,
$\mathcal{G}^*$ is  the intersection of the current regular polygon $\mathcal{G}$ with $\mathcal{G}^*$ by calling procedure $\rpia()$ introduced in Section~\ref{subsec-fastRPI} (line 7). If the resulting intersection $\mathcal{G}^*$ is empty, then a new line segment $\vv{P_sP_{i-1}}$ is generated (lines 8--10).
After the  final new line segment $\vv{P_sP_{n}}$ is generated (line 11), it returns the simplified  piece-wise line representation $\overline{\mathcal{T}}$ (line 12).




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%example of Algorithm CISED
\begin{figure*}[tb!]
\centering
\includegraphics[scale=0.8]{figures/Fig-ex-conest.png}
\vspace{-2ex}
\caption{\small A running example of the \cist algorithm. The points and the oblique circular cones are projected on an x-y space. The trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_{10}]$ is compressed into four line segments.}
\vspace{-3ex}
\label{fig:exm-const}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\begin{example}
\label{exm-alg-conest}
A running example of algorithm \cist is shown in Figure~\ref{fig:exm-const},  taking as input the trajectory shown in Figure~\ref{fig:notations} Figure~\ref{fig:sleeve}.
For convenience, here, we project the points and the oblique circular cones on a x-y space.

\ni (1) After initialization, the \cist algorithm reads point $P_1$ and builds a narrow \emph{oblique circular cone} $\mathcal{C}$($P_0$, $P_{1}$, $\epsilon/2$), taking $P_0$ as the vertex and $\mathcal{O}(P_1, \epsilon/2)$ as the bottom circle (green dash). The \emph{circular cone} is projected on the plane $t=t_1$, and the inscribe regular polygon $\mathcal{G}_1$ of the projection circle is returned. The intersection of $\mathcal{G}_1$ and $\mathcal{G}^*$ is $\mathcal{G}_1 \ne \phi$.

\ni (2) The algorithm reads $P_2$ and builds $\mathcal{C}$($P_0$, $P_{2}$, $\epsilon/2$) (red dash). The \emph{circular cone} is also projected on the plane $t=t_1$ and the inscribe regular polygon $\mathcal{G}_2$ of the projection circle is returned. The intersection of $\mathcal{G}_2$ and $\mathcal{G}^*$ is not $\phi$.

\ni (3) For point $P_3$, the algorithm runs the same routing as $P_2$. However, the intersection of $\mathcal{G}_3$ and $\mathcal{G}^*$ is $\phi$. Thus, line segment $\vv{P_0P_2}$ is output, and a new section is started, taking $P_2$ as the new start point.

\ni (4) At last, the algorithm outputs four continuous line segments, \ie $\vv{P_0P_2}$, $\vv{P_2P_4}$, $\vv{P_4P_{7}}$ and $\vv{P_7P_{10}}$.
\end{example}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Weak Trajectory Simplification}

We then present the one-pass error bounded {\em weak trajectory simplification} algorithm using the synchronous distance.

%, based on Proposition~\ref{prop-circle-intersection}.



\stitle{Algorithm \cista}.
Given a trajectory \trajec{T}${[P_0, \ldots, P_n]}$, an error bound $\epsilon$ and the number $m$ of edges for inscribed
regular polygons, its returns a simplified  piece-wise line representation $\overline{\mathcal{T}}$,
which may contain interpolated points.

By Proposition~\ref{prop-circle-intersection}, algorithm \cista generates spatio-temporal cones whose bases are circles with a radius of $\epsilon$,
and, hence, it replaces $\epsilon/2$ with $\epsilon$ (line 3 of \cist);
It also generates new line segments with interpolated data points $Q$, and, hence,  it replaces the line segment $\vv{P_sP_i}$ with $\vv{P_sO}$ (line 11 of \cist),
such that $Q$ is generated as follows.


\sstab (1) if $G^*_e \ne \emptyset$ and $P^c_e \in G^*_e$, meaning the projection point of $P_e$ on the plane ``$t=t_c$", \ie $P^c_e$, is in the intersection polygon of regular polygons \{$\mathcal{G}_s, \dots, \mathcal{G}_e$\} of all projection circles \{$\mathcal{O}(P^c_s, \epsilon^c_s), \ldots, \mathcal{O}(P^c_e, \epsilon^c_e)$\}, then the point $P_e$ is a candidate point of $Q$ and the algorithm outputs $Q=P_e$.

\sstab (2) if $G^*_e \ne \phi$ and $P^c_e \notin G^*_e$, then it gets the central point of intersection polygon $G^*_e$, projects it on the plane ``$t=t_e$", and outputs the projection point $Q$.

\vspace{1ex}
%Figure~\ref{alg:ciseda} is the P-codes of algorithm \cista.
Algorithm \cista runs the similar routine as algorithm \cist, except that in line 3 of Figure~\ref{alg:CI3d}, $\epsilon/2$ is replaced by $\epsilon$; and in lines 12-13 of Figure~\ref{alg:CI3d}, $P_e$ is replace by $Q$ which is got by the above strategies.



\begin{example}
\label{exm-alg-conesta}
Figure~\ref{fig:exm-consta} is a running example of the \cista algorithm taking as input the same trajectory as shown in above.
The points and the oblique circular cones are projected on a x-y space.

\ni (1) After initialization, the \cista algorithm reads point $P_1$ and builds a \emph{oblique circular cone} $\mathcal{C}$($P_0$, $P_{1}$, $\epsilon$), and projects it on the plane $t=t_1$. The inscribe regular polygon $\mathcal{G}_1$ of the projection circle is returned. The intersection of polygon $\mathcal{G}_1$ and polygon $\mathcal{G}^*$ is $\mathcal{G}_1 \ne \phi$.

\ni (2) $P_2$, $P_3$ and $P_4$ are processed in turn. The intersection polygons are not empty.

\ni (3) For point $P_5$, the intersection of $\mathcal{G}_5$ and $\mathcal{G}^*$ is $\phi$. Thus, line segment $\vv{P_0Q} =\vv{P_0P'_4}$ is output, and a new section is started, taking $P'_4$ as the new start point.

\ni (4) At last, the algorithm outputs 3 continuous line segments, \ie $\vv{P_0P'_4}$, $\vv{P'_4P_8}$ and $\vv{P_8P_{10}}$. Where, $P_0$, $P_8$ and $P_{10}$ are original points.
\end{example}





\begin{cor}
    (corollary of Proposition 3, in sec 3.1) Given any $t_{c_1}> P_s.t$ and $t_{c_2} > P_s.t$, they are equivalent.
\end{cor}

(in sec 4.2) Given a sub-trajectory \trajec{T}${[P_s, \ldots, P_{s+k}]}$, and let $G^*_k$ be the intersection polygons of $G^*_{s+i}$, $1<i\le k$ on the plane $t=t_{s+k}$. If $G^*_k$ is not empty, then any point in $G^*_k$ is feasible for $Q$.

The selection of $Q$ may slight affect the effectiveness (\eg average error and compression ratios) of the algorithm. However, the selection of the ``best" $Q$ is trivial and time consuming.


\eat{%%%%%%%%%%%%%%%%%%%%% Algorithm
\begin{figure}[tb!]
\begin{center}
{\small
\begin{minipage}{3.36in}
\myhrule
\vspace{-1ex}
\mat{0ex}{
	{\bf Algorithm} ~$\cista(\dddot{\mathcal{T}}[P_0,\ldots,P_n], ~\epsilon, ~M, ~t_c)$\\
%	\sstab
	\bcc \hspace{1ex}\= $P_s := P_0$;  ~$P_e := P_0$;  ~$\overline{\mathcal{T}} := \phi$;  ~$\mathcal{G}^* := \phi$;  ~$i := 1$\\
%         \hspace{2ex}     $intersection = \emptyset$;   \\
	\icc \hspace{1ex}\= \While $i \le n$ \Do \\
	\icc \>\hspace{3ex} $\mathcal{G} := {getRegularPolygon}$($P_s$, $P_i$, $\epsilon$, $M$, $t_c$) \\
	\icc \>\hspace{3ex} \If $\mathcal{G}^* = \phi$ \Then \\
	\icc \>\hspace{6ex} $\mathcal{G}^* :=\mathcal{G}$ \\
	\icc \>\hspace{3ex} \Else \\
	\icc \>\hspace{6ex} $\mathcal{G}^* := {\rpia}(\mathcal{G}^*, ~\mathcal{G})$ \\
	\icc \>\hspace{3ex} \If $\mathcal{G}^* \ne \phi$ \Then \\
	\icc \> \hspace{6ex} $P_e := P_i$ \\
	\icc \> \hspace{6ex} $i := i+1$ \\
	\icc \>\hspace{3ex} \Else\\
	\icc \> \hspace{6ex} $\overline{\mathcal{T}} := \overline{\mathcal{T}}\cup \{\mathcal{L}(P_s,Q)\}$ \\
	\icc \> \hspace{6ex} $P_s := Q$;  ~~$\mathcal{G}^* := \phi$ \\
	\icc \hspace{1ex}\Return $\overline{\mathcal{T}}$
%
%	{\bf procedure} $getPolygon$($P_s$, $P_i$, $\epsilon/2$) \\
%
%	{\bf procedure} $getIntersection(ipolygon, \mathcal{G})$ \\
}
\vspace{-2ex}
\myhrule
\end{minipage}
}
\end{center}
\vspace{-2ex}
\caption{\small Aggressive spatio-temporal cone intersection algorithm (\cista).}
\label{alg:ciseda}
\vspace{-2ex}
\end{figure}
}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%A running example of the \cista algorithm
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[tb!]
\centering
\includegraphics[scale=0.8]{figures/Fig-conesta.png}
\vspace{-1ex}
\caption{\small A running example of the \cista algorithm. The points and the oblique circular cones are projected on an x-y space. The trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_{10}]$ is compressed into three line segments.}
\vspace{-2ex}
\label{fig:exm-consta}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\subsection{Correctness and Complexity Analyses}

The correctness of algorithm \cist follows from Theorem~\ref{prop-3d-ci-half} and Corollary~\ref{prop-circle-intersection}, and the correctness of algorithm \cista follows from Corollary~\ref{prop-circle-intersection}. For the circles intersection of Corollary~\ref{prop-circle-intersection}, we replace it by the regular polygons intersection.
Meanwhile, given time $t_c$ and projection circles $\mathcal{O}(P^c_i, r^c_i)$, $i \in (s, e]$, we get a inscribed regular polygon from each projection circle.
If these regular polygons are intersecting, then $sed(P_i, \vv{P_sP_e})<\epsilon$ for all points $P_i$, $i \in [s,e]$.
This ensures the correctness of the algorithms.

{For space complexity, the algorithms need $O(M)$ space.}
For time complexity, we have follows.


\begin{proof}
For each data point in the input trajectory, the procedures $getRegularPolygon()$ and $\rpia()$ are both called one time.
(1) Procedure $getRegularPolygon()$ completes in $O(M)$ time, and
(2) Procedure $\rpia(\mathcal{G}^*, \mathcal{G})$ also completes in $O(M)$ time.
%completes in $O(|\mathcal{G}^*| + |\mathcal{G}|)$ time. By Theorem~\ref{prop-rp-intersection}, we know that $|\mathcal{G}^*| \le M$ and $|\mathcal{G}|\le M$, where $M$ is the number of vertices in a regular polygon. Hence, $getIntersectPolygon()$
$M$ is a constant, thus, the process of a point needs a constant time.
Hence, algorithms \cist and \cista both have a time complexity of $O(N)$, where $N$ is the size of the input trajectory.
This finishes the proof.
\end{proof}



