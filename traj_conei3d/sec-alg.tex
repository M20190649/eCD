%\section{One-Pass Trajectory Simplification}
\section{Fast Trajectory Simplification}

\label{sec-alg}
\textcolor{blue}{Based on the Spatio-temporal cone method, we develop two one-pass sub-optimal algorithms and a fast near optimal algorithm using \sed. For sub-optimal algorithms,} following \cite{Trajcevski:DDR,Lin:Operb}, we further consider two classes of trajectory simplification.
The first one, referred to as \emph{strong simplification}, that takes as input a trajectory \trajec{T}, an error bound $\epsilon$ and the number $m$ of edges for inscribed regular polygons, and produces a simplified trajectory \trajec{T'} such that all data points in \trajec{T'} belongs to \trajec{T}.
The second one, referred to as \emph{weak simplification}, that takes as input a trajectory \trajec{T}, an error bound $\epsilon$ and the number $m$ of edges for inscribed regular polygons, and produces a simplified trajectory \trajec{T'} such that some data points in \trajec{T'} may not belong to \trajec{T}. That is, weak simplification allows data interpolation. 
\textcolor{blue}{For (near) optimal algorithm, it does not allow data interpolation too, thus, it also belongs to strong simplification.}
%,commonly used in polygonal curve approximation \cite{Williams:Bounded, Heckbert:Survey, Zhao:Sleeve}, time series approximation \cite{ORourke:Fitting, Elmeleegy:Stream, Xie:Stream, Luo:Streaming} and trajectory simplification \cite{Lin:Operb}.

\eat{
The main result here is stated as follows.

\begin{theorem}
\label{prop-cist-op}
There exist \textcolor{blue}{sub optimal,} one-pass, error bounded and strong and weak trajectory simplification algorithms using \sed.
\end{theorem}

We shall prove this by providing such algorithms for both strong and weak trajectory simplifications, by employing the constant time synchronous distance checking technique developed in Section~\ref{sec-localcheck}.
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{One-pass Strong Trajectory Simplification}
Recall that in Propositions~\ref{prop-3d-ci} and~\ref{prop-circle-intersection}, the point $Q$ may not be in the input sub-trajectory $[P_s,...,P_{s+k}]$.
If we restrict $Q=P_{s+k}$, the end point of the sub-trajectory, then the narrow cones whose base circles with a radius of $\epsilon/2$ suffice.

\begin{prop}
\label{prop-3d-ci-half}
Given a sub-trajectory $[P_s,...,P_{s+k}]$ and an error bound $\epsilon$, $sed(P_{s+i}, \vv{P_sP_{s+k}})\le \epsilon$ for each $i \in [1,k]$ if  $\bigsqcap_{i=1}^{k}$\cone{(P_s, \mathcal{O}(P_{s+i}, \epsilon/2))} $\ne \{P_s\}$.
\end{prop}


\begin{proof}
If $\bigsqcap_{i=s+1}^{e}{\mathcal{C}(P_s, P_{s+i}, \epsilon/2)} \ne \{P_s\}$, then by Proposition~\ref{prop-3d-ci}, there exists a point $Q$, $Q.t = P_{s+k}.t$, such that $sed(P_{s+i}, \vv{P_sQ})\le \epsilon/2$ for all $i \in [1,k]$. By the triangle inequality essentially, $sed(P_{s+i}, \vv{P_sP_{s+k}})\le  sed(P_{s+i}, \vv{P_sQ}) + |\vv{QP_{s+k}}| \le  \epsilon/2+\epsilon/2 = \epsilon$.
\end{proof}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%example of Algorithm CISED
\begin{figure*}[tb!]
	\centering
	\includegraphics[scale=0.8]{figures/Fig-Ex-Conest.png}
	%\vspace{-2ex}
	\caption{\small A running example of the \cist algorithm. The points and the oblique circular cones are projected on an x-y space. The trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_{10}]$ is compressed into four line segments.}
	\vspace{-1ex}
	\label{fig:exm-const}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 We first present the  one-pass error bounded {\em strong trajectory simplification} algorithm using \sed, as shown in Figure~\ref{alg:CI3d}.

\stitle{Procedure \kw{getRegularPolygon}}.
We first present procedure \kw{getRegularPolygon} that, given a cone projection circle, generates its inscribed $m$-edge regular polygon,  following the definition in Section~\ref{subsec-RPI}.

The parameters $P_s$, $P_i$, $r$ and $t_c$ together form the projection circle \pcircle{(P^c_i, r^c_i)} of the spatio-temporal cone \cone{(P_s, \mathcal{O}(P_{i}, r))} of point $P_{i}$ \wrt point $P_s$ on the plane $P.t - t_c$ = $0$. Firstly, $P^c_i.x$ and $P^c_i.y$ are computed (lines 1--3), and $r^c_i = c\cdot r$.
Then it builds and returns an $m$-edge inscribed regular polygon $\mathcal{G}$ of \pcircle{(P^c_i, r^c_i)} (lines 4--8), by transforming a polar coordinate system
into a Cartesian one. Note that here $\theta$, $r\cdot\sin\theta$ and $r\cdot\cos\theta$ only need to be computed once during the entire processing of a trajectory.

\stitle{Algorithm \cist}. We now present algorithm \cist. It takes as input a trajectory \trajec{T}${[P_0, \ldots, P_n]}$, an error bound $\epsilon$ and the number $m$ of edges for inscribed regular polygons, and returns a simplified  trajectory $\overline{\mathcal{T}}$ of $\dddot{\mathcal{T}}$.



The algorithm first initializes the start point $P_s$ to $P_0$, the index $i$ of the current data point to $1$, the intersection polygon $\mathcal{G}^*$ to $\emptyset$, the output $\overline{\mathcal{T}}$ to $\emptyset$, and $t_c$ to $P_1.t$, respectively (line 1).
%
The algorithm sequentially processes the data points of the trajectory one by one  (lines 2--10). It gets the $m$-inscribed regular polygon \wrt the current point $P_i$ (line 3) by calling procedure $\kw{getRegularPolygon}$. When $\mathcal{G}^* = \emptyset$, $\mathcal{G}^*$ is simply initialized as $\mathcal{G}$ (lines 4, 5). Otherwise,
$\mathcal{G}^*$ is  the intersection of the current regular polygon $\mathcal{G}$ with $\mathcal{G}^*$ by calling procedure $\rpia()$ introduced in Section~\ref{subsec-fastRPI} (line 7). If the resulting intersection $\mathcal{G}^*$ is empty, then a new line segment $\vv{P_sP_{i-1}}$ is generated (lines 8--10).
After the  final new line segment $\vv{P_sP_{n}}$ is generated (line 11), it returns the simplified  piece-wise line representation $\overline{\mathcal{T}}$ (line 12).





%%%%%%%%%%%%%%%%%%%%%algorithm
\begin{figure}[tb!]
	\begin{center}
		{\small
			\begin{minipage}{3.36in}
				\myhrule
				\vspace{-1ex}
				\mat{0ex}{
					{\bf Algorithm} ~\cist$(\dddot{\mathcal{T}}[P_0,\ldots,P_n],~\epsilon,~m)$\\
					%	\sstab
					\bcc \hspace{1ex}\= $P_s := P_0$; ~$i := 1$;  ~$\mathcal{G}^* := \emptyset$;  ~$\overline{\mathcal{T}} := \emptyset$; ~$t_c$ := $P_1.t$;\\
					\icc \hspace{1ex}\= \While $i \le n$ \Do \\
					\icc \>\hspace{2ex} $\mathcal{G}$ := \kw{getRegularPolygon}($P_s$, $P_i$, $\epsilon/2$, $m$, $t_c$); \\
					\icc \>\hspace{2ex} \If $\mathcal{G}^* = \emptyset$  \Then \hspace{4ex} /* $\mathcal{G}^*$ needs to be initialized */\\
					\icc \>\hspace{2ex} \ \ \ $\mathcal{G}^* :=\mathcal{G};$ \\
					\icc \>\hspace{2ex} \Else \\
					\icc \>\hspace{2ex}\ \ \ \ $\mathcal{G}^* := {\rpia}(\mathcal{G}^*, ~\mathcal{G})$; \\
					\icc \>\hspace{4ex} \If $\mathcal{G}^* = \emptyset$ \Then \hspace{2ex} /* generate a new line segment */\\
					\icc \> \hspace{4ex} \ \ \ $i$ := $i - 1$;\ \ $\overline{\mathcal{T}} := \overline{\mathcal{T}}\cup \{\vv{P_sP_{i}}\}$;\ \ $P_s := P_{i}$; \ \ $t_c$ := $P_{i+1}.t$\\
					\icc \>\hspace{2ex} $i$ := $i +1$;\\
					\icc \> \hspace{0ex} $\overline{\mathcal{T}}$ := $\overline{\mathcal{T}}\cup \{\vv{P_sP_{n}}\}$; \\
					\icc \hspace{1ex}\Return $\overline{\mathcal{T}}$.
					\\
					\\
					{\bf Procedure} ~\kw{getRegularPolygon}$(P_s,~P_i,~r,~m,~t_c)$ \\
					%	\bcc \hspace{1ex} \textcolor[rgb]{0.00,0.07,1.00}{Transform $P_s$ and $P_i$ to points in Cartesian coordinates} \\
					\bcc \hspace{1ex} $c := (t_c-t_s)/(P_i.t - P_s.t)$; \\
					\icc \hspace{1ex} $x := P_s.x + c\cdot(P_i.x-P_s.x)$; \\
					\icc \hspace{1ex} $y := P_s.y + c\cdot(P_i.y-P_s.y)$; \\
					\icc \hspace{1ex} \For $(j := 1;j \le m;j++)$ \Do \\
					\icc \> \hspace{2ex} $\theta :=  (2j + 1)*\pi /m $; \\
					\icc \> \hspace{2ex} $\mathcal{G}.v_j.x := x + c\cdot r\cdot\cos\theta$;\\
					\icc \> \hspace{2ex} $\mathcal{G}.v_j.y := y + c\cdot r\cdot\sin\theta$;\\
					\icc \hspace{1ex} \Return $\mathcal{G}$.
				}
				\vspace{-2ex}
				\myhrule
			\end{minipage}
		}
	\end{center}
	\vspace{-2ex}
	\caption{\small One-pass strong trajectory  simplification algorithm.}
	\label{alg:CI3d}
	\vspace{-2ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%A running example of the \cista algorithm
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[tb!]
\centering
\includegraphics[scale=0.79]{figures/Fig-Conesta.png}
%\vspace{-1ex}
\caption{\small A running example of the \cista algorithm. The points and the oblique circular cones are projected on an x-y space. The trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_{10}]$ is compressed into three line segments.}
\vspace{-2ex}
\label{fig:exm-consta}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{example}
\label{exm-alg-conest}
Figure~\ref{fig:exm-const} shows an example of algorithm \cist for compressing the trajectory \trajec{T} in Figure~\ref{fig:notations}.
%For convenience, here, we project the points and the oblique circular cones on a x-y space.

\sstab (1) After initialization, the \cist algorithm reads point $P_1$ and builds a narrow \emph{oblique circular cone} \cone{(P_0, \mathcal{O}(P_{1}, \epsilon/2))}, taking $P_0$ as its apex and \circle{(P_1, \epsilon/2)} as its base (green dash). The \emph{circular cone} is projected on the plane $P.t-P_1.t=0$, and the inscribe regular polygon $\mathcal{G}_1$ of the projection circle is returned. As $\mathcal{G}^*$ is empty, $\mathcal{G}^*$ is set to $\mathcal{G}_1$.

\sstab(2) The algorithm reads $P_2$ and builds \cone{(P_0, \mathcal{O}(P_{2}, \epsilon/2))} (red dash). The \emph{circular cone} is also projected on the plane $P.t-P_1.t=0$ and the inscribe regular polygon $\mathcal{G}_2$ of the projection circle is returned. As $\mathcal{G}^*=\mathcal{G}_1$ is not empty, $\mathcal{G}^*$ is set to the intersection of $\mathcal{G}_2$ and $\mathcal{G}^*$, which is $\mathcal{G}_1 \bigsqcap \mathcal{G}_2 \ne \emptyset$.

\sstab (3) For point $P_3$, the algorithm runs the same routine as $P_2$ until the intersection of $\mathcal{G}_3$ and $\mathcal{G}^*$ is $\emptyset$. Thus, a line segment $\vv{P_0P_2}$ is generated, and the process of a new line segment is started, taking $P_2$ as the new start point and $P.t-P_3.t=0$ as the new projection plane.

\sstab (4) At last, the algorithm outputs four continuous line segments, \ie $\{\vv{P_0P_2}$, $\vv{P_2P_4}$, $\vv{P_4P_{7}}$, $\vv{P_7P_{10}}\}$.
\end{example}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{One-pass Weak Trajectory Simplification}

We then present the one-pass error bounded {\em weak simplification} algorithm using \sed.

%, based on Proposition~\ref{prop-circle-intersection}.



\stitle{Algorithm \cista}.
Given a trajectory \trajec{T}${[P_0, \ldots, P_n]}$, an error bound $\epsilon$ and the number $m$ of edges for inscribed
regular polygons, it returns a simplified trajectory,
which may contain interpolated points.

By Proposition~\ref{prop-circle-intersection}, algorithm \cista generates spatio-temporal cones whose bases are circles with a radius of $\epsilon$,
and, hence, it replaces $\epsilon/2$ with $\epsilon$ (line 3 of \cist). It also generates new line segments with data points $Q$ (may be interpolated points), and,
hence, it replaces point $P_i$ and line segment $\vv{P_sP_i}$  (line 9 of \cist) with $Q$ and $\vv{P_sQ}$, respectively,  such that $Q$ is generated as follows.


\begin{prop}
\label{prop-cist-Q}
Given a sub-trajectory \trajec{T}${[P_s, \ldots, P_{s+k}]}$ and an error bound $\epsilon$,  $t_c=P_{s+k}.t$ and $G^*_k$ be the intersection of all polygons $G_{s+i}$ ($i\in[1,k]$) on the plane $P.t - t_c = 0$. If $G^*_k$ is not empty, then any point in the area of $G^*_k$ is feasible for $Q$.
\end{prop}

\begin{proof}
By Proposition~\ref{prop-circle-intersection} and the nature of inscribed regular polygon, it is easy to find that for any $Q \in G^*_k$  \wrt $t_c=P_{s+k}.t$, there is $sed(P_{s+i}, \vv{P_sQ})\le \epsilon$ for all points $P_{s+i}$ ($i \in [1,k]$). From this, we have the conclusion.
\end{proof}

The choice of a point $Q$ from $G^*_k$ may slightly affect the effectiveness (\eg average errors and compression ratios). However, the choice of an optimal $Q$ is non-trivial. For the benefit of efficiency, we apply the following strategies.

\sstab (1) If $P_{s+k}$ is in the area of $G^*_k$ \wrt $t_c=P_{s+k}.t$, then $Q$ is simply chosen as $P_{s+k}$.
%meaning the projection point of $P_e$ on the plane ``$t=t_c$", \ie $P^c_e$, is in the intersection polygon of regular polygons \{$\mathcal{G}_s, \dots, \mathcal{G}_e$\} of all projection circles \{$\mathcal{O}(P^c_s, \epsilon^c_s), \ldots, \mathcal{O}(P^c_e, \epsilon^c_e)$\},

\sstab (2) If $G^*_k \ne \emptyset$ and $P_{s+k}$ is not in the area of $G^*_k$ \wrt $t_c$=$P_{s+k}.t$, then the central point of $G^*_k$ is chosen as $Q$.

\sstab (3)  If $t_c \ne P_{s+k}.t$, which is the general case, then we project the intersection polygon $G^*_k$ \wrt $t_c \ne P_{s+k}.t$ on the plane $P.t -P_{s+k}.t = 0$, and apply strategies (1) and (2) above. That is, the projection has no affects on the choice of $Q$.
%so as to get the $G^*_k$ \wrt $t_c = t_{s+k}$,

\begin{example}
\label{exm-alg-conesta}
Figure~\ref{fig:exm-consta}  shows a running example of algorithm \cista for compressing the trajectory \trajec{T} in Figure~\ref{fig:notations} again.


\sstab (1) After initialization, the \cista algorithm reads point $P_1$ and builds an \emph{oblique circular cone} \cone{(P_0, \mathcal{O}(P_{1}, \epsilon))}, and projects it on the plane $P.t-P_1.t=0$. The inscribed regular polygon $\mathcal{G}_1$ of the projection circle is returned and the intersection $\mathcal{G}^*$ is set to $\mathcal{G}_1$.

\sstab (2) $P_2$, $P_3$ and $P_4$ are processed in turn. The intersection polygons $\mathcal{G}^*$ are not empty.

\sstab (3) For point $P_5$, the intersection of $\mathcal{G}_5$ and $\mathcal{G}^*$ is $\emptyset$. Thus, line segment $\vv{P_0Q} =\vv{P_0P'_4}$ is output, and a new line segment is started such that $Q=P'_4$ is the new start point and plane $P.t-P_5.t=0$ is the new projection plane.

\sstab (4) At last, the algorithm outputs 3 continuous line segments, \ie $\vv{P_0P'_4}$, $\vv{P'_4P_8}$ and $\vv{P_8P_{10}}$, in which $P'_4$ is an interpolated data points not in \trajec{T}.
\end{example}








\eat{%%%%%%%%%%%%%%%%%%%%% Algorithm
\begin{figure}[tb!]
\begin{center}
{\small
\begin{minipage}{3.36in}
\myhrule
\vspace{-1ex}
\mat{0ex}{
	{\bf Algorithm} ~$\cista(\dddot{\mathcal{T}}[P_0,\ldots,P_n], ~\epsilon, ~M, ~t_c)$\\
%	\sstab
	\bcc \hspace{1ex}\= $P_s := P_0$;  ~$P_e := P_0$;  ~$\overline{\mathcal{T}} := \phi$;  ~$\mathcal{G}^* := \phi$;  ~$i := 1$\\
%         \hspace{2ex}     $intersection = \emptyset$;   \\
	\icc \hspace{1ex}\= \While $i \le n$ \Do \\
	\icc \>\hspace{3ex} $\mathcal{G} := {getRegularPolygon}$($P_s$, $P_i$, $\epsilon$, $M$, $t_c$) \\
	\icc \>\hspace{3ex} \If $\mathcal{G}^* = \phi$ \Then \\
	\icc \>\hspace{6ex} $\mathcal{G}^* :=\mathcal{G}$ \\
	\icc \>\hspace{3ex} \Else \\
	\icc \>\hspace{6ex} $\mathcal{G}^* := {\rpia}(\mathcal{G}^*, ~\mathcal{G})$ \\
	\icc \>\hspace{3ex} \If $\mathcal{G}^* \ne \phi$ \Then \\
	\icc \> \hspace{6ex} $P_e := P_i$ \\
	\icc \> \hspace{6ex} $i := i+1$ \\
	\icc \>\hspace{3ex} \Else\\
	\icc \> \hspace{6ex} $\overline{\mathcal{T}} := \overline{\mathcal{T}}\cup \{\mathcal{L}(P_s,Q)\}$ \\
	\icc \> \hspace{6ex} $P_s := Q$;  ~~$\mathcal{G}^* := \phi$ \\
	\icc \hspace{1ex}\Return $\overline{\mathcal{T}}$
%
%	{\bf procedure} $getPolygon$($P_s$, $P_i$, $\epsilon/2$) \\
%
%	{\bf procedure} $getIntersection(ipolygon, \mathcal{G})$ \\
}
\vspace{-2ex}
\myhrule
\end{minipage}
}
\end{center}
\vspace{-2ex}
\caption{\small Aggressive spatio-temporal cone intersection algorithm (\cista).}
\label{alg:ciseda}
\vspace{-2ex}
\end{figure}
}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{\textcolor{blue}{Near Optimal Trajectory Simplification}}


\stitle{Optimal algorithm using \sed}

\textcolor{blue}{introduce the optimal algorithm using \sed, including its basic idea - the Reachabe graph, its construction and searching for the shortest pash.}



\stitle{$\epsilon - graph$}. The  $\epsilon - graph$ of a trajectory
\trajec{T}${[P_0, \ldots, P_n]}$, an error bound $\epsilon$ is a directed graph $G
= \{V,E\}$, where each vertex in V represents a point t in \trajec{T} and each
edge $(v_r,v_s)$ is in E if and only if the error of the line segment is within
$\epsilon$, i.e., $V = \{v_0,v_1,...,v_{n-1}\}$ and 
$E = \{(v_r,v_s) | r < s \ and \ e(\bar{p_rp_s) \le \epsilon})\}$. 


Given a trajectory \trajec{T}${[P_0, \ldots, P_n]}$, an error bound $\epsilon$ ,
the  \textcolor{blue}{min-\#}  problem can be solved in two steps.
The first step is to construct $\epsilon - graph$ of \trajec{T}. 
The second step is to find the shortest path
in G from $v_0$ to $v_{n-1}$ with each edge of unit length. Thus, the path
length will correspond to the number of line segments in the approximation
curve. Moreover, the shortest path also reveals the subset of points of
\trajec{T} used in the approximate curve.


The brute-force algorithm of constructing G is to check for each pair of points
$p_r,p_s$,whether the error of $\bar{p_rp_s}$ is within $\epsilon$, i.e.,
$(v_r,v_s \in  E)$. There are $O(n^2)$ pairs of points and checking the error of
a line segment, corresponding to a pair of points, takes O(n) time. Thus,this
method takes $O(n^3)$ time. Since finding the shortest path takes no more than
$O(n^2)$ time, the brute-force algorithm takes $O(n^3)$ time.

The crutial part of of the algorithm is the construction of G. In the following,
we shall discuss how G can be constructed in $O(n^2)$ time.


\stitle{Speedup graph constructing by using spatio-temporal cones.}
In \cite{Chan:Optimal} the author proposed a speed-up method of constructing the
$\epsilon$ graph using PED as distance metric.
The key of their method is to leverage the Sector Intersection method.
The intersection of previous sector bounds stores the information of restriction
imposed by all the previous points. 
A new coming point can form a edge with the starting point in the $\epsilon$
graph if and only if it resides within the intersection.
Since checking whether a point is in a sector bound and updating the sector bound can be done in
constant time. The time complexity of this algorithm is $O(n^2)$.

Extending their method to $3-D$ spatio temporal space, we can get an optimal
algorithm using SED for the $min-\#$ problem with time complexity of $O(n^2)$.

\textcolor{blue}{Theorem and proof}

Firstly, we give the necessary condition for the inclusion of an edge to the $\epsilon - graph$.

\begin{prop}
\label{prop-edge-check}
Edge $(v_s,v_r)$ can be included in the $\epsilon - graph$ if and only if the ray
$\vv{P_sP_r}$ lies inside the common intersection of previous cones, i.e.,
$\vv{P_sP_r} \in $ $\bigsqcap_{i=1}^{r - 1}$\cone{(P_s, \mathcal{O}(P_{s+i}, \epsilon))}  and
$\bigsqcap_{i=1}^{r - 1}$\cone{(P_s, \mathcal{O}(P_{s+i}, \epsilon))} $\ne \{P_s\}$. 
\end{prop}

\begin{proof}
If the directed line segment $\vv{P_sP_r} \in$ $\bigsqcap_{i=1}^{r-1}$\cone{(P_s, \mathcal{O}(P_{s+i}, \epsilon))}, the
intersection point $P'_{s+i}$ of the directed line segment $\vv{P_sP_r}$ and the
plane $P.t - P_{s+i}.t = 0$  is  in the area of the  synchronous circle
\circle{(P_{s+i}, \epsilon)} for each $i \in [1,r - 1]$ . By Proposition~\ref{prop-3d-syn-point}, the
synchronous distance of $P_{s+i}$ to $\vv{P_sP_r}$ is error bouned for each $i \in [1,r - 1]$ . Thus,Edge
$(v_s,v_r)$ can be included in the $\epsilon - graph$  
\end{proof}


\textcolor{blue}{How?}
Then we propose the speedup graph constructing by using spatio-temporal cones.

From Proposition~\ref{prop-edge-check}, we can determine whether $(v_s,v_r) \in
G$ by testing whether $\vv{P_sP_r} \in $ $\bigsqcap_{i=1}^{r - 1}$\cone{(P_s,
  \mathcal{O}(P_{s+i}, \epsilon))}. For any r, the algorithm would consider all
pairs of vertices  $(v_s,v_r)$ with  r ranging from s + 1 to n.  

The checking of whether a line segment lies inside a spatio-temporal cone can be
reduced to checking whether its projection point lies inside the projection
circle on a plane which can be done in constant time. Furthermore, as we have
proposed before, the compution of intersection of spatio-temporal cones can be
done in constant time. Thus, checking for each pair of vertices can be done in
constant time.

Since we use inscribed regular polygon to approximate the projection circle,
this method is near optimal.

\stitle{Near Optimal algorithm using \sed.}

\textcolor{blue}{code, algorithm desc and example.}

We now present algorithm the Near Optimal algorithm using \sed. It takes as input a trajectory \trajec{T}${[P_0, \ldots, P_n]}$, an error bound $\epsilon$ and the number $m$ of edges for inscribed regular polygons, and returns a simplified  trajectory $\overline{\mathcal{T}}$ of $\dddot{\mathcal{T}}$.

The algorithm first  constructs the $\epsilon graph$ for the trajectory. It
checks for each point $P_s$, whether the points ``after'' it , i.e., $P_r,r > s$
can form an edge in the graph with the starting point. 

Given a trajectory \trajec{T}${[P_0, \ldots, P_n]}$, an error bound $\epsilon$ and the number $m$ of edges for inscribed
regular polygons, it returns a simplified trajectory,


%%%%%%%%%%%%%%%%%%%%% Algorithm
\begin{figure}[tb!]
	\begin{center}
		{\small
			\begin{minipage}{3.36in}
				\myhrule
				\vspace{-1ex}
				\mat{0ex}{
					{\bf Algorithm} ~$\cista(\dddot{\mathcal{T}}[P_0,\ldots,P_n], ~\epsilon, ~M, ~t_c)$\\
					%	\sstab
					\bcc \hspace{1ex}\= $P_s := P_0$;  ~$P_e := P_0$; ~$E = \phi$;
          ~$\overline{\mathcal{T}} := \phi$;\\
					%         \hspace{2ex}     $intersection = \emptyset$;   \\
					\icc \hspace{1ex}\= \For $s = 0$  \To $n - 2$ \Do \\
          \icc \>\hspace{3ex}\= $\mathcal{G}^* := {getRegularPolygon}$($P_s$, $P_{s+1}$, $\epsilon$, $M$, $t_c$) \\
					\icc \>\hspace{3ex}\= \For $r = s + 2$  \To $n$ \Do \\
					\icc \>\hspace{6ex} \If ${isInside}$($\mathcal{G}^*$, $P_r$) \Then \\
					\icc \>\hspace{9ex} ${addEdge}$($P_s$,$P_r$,$E$) \\
					\icc \>\hspace{6ex} $\mathcal{G} := {getRegularPolygon}$($P_s$, $P_r$, $\epsilon$, $M$, $t_c$) \\
					\icc \>\hspace{6ex} $\mathcal{G}^* := {\rpia}(\mathcal{G}^*, ~\mathcal{G})$ \\

					\icc \>\hspace{6ex} \If $\mathcal{G}^* = \phi$ \Then \\
					\icc \>\hspace{9ex} \Break \\
					% \icc \>\hspace{3ex} \Else \\
					% \icc \>\hspace{3ex} \If $\mathcal{G}^* \ne \phi$ \Then \\
					% \icc \> \hspace{6ex} $P_e := P_i$ \\
					% \icc \> \hspace{6ex} $i := i+1$ \\
					% \icc \>\hspace{3ex} \Else\\
					% \icc \> \hspace{6ex} $\overline{\mathcal{T}} := \overline{\mathcal{T}}\cup \{\mathcal{L}(P_s,Q)\}$ \\
					% \icc \> \hspace{6ex} $P_s := Q$;  ~~$\mathcal{G}^* := \phi$ \\

					\icc \hspace{1ex} $\overline{\mathcal{T}} = {Dijkstra}(E)$\\
					\icc \hspace{1ex}\Return $\overline{\mathcal{T}}$
					%
					%	{\bf procedure} $getPolygon$($P_s$, $P_i$, $\epsilon/2$) \\
					%
					%	{\bf procedure} $getIntersection(ipolygon, \mathcal{G})$ \\
				}
				\vspace{-2ex}
				\myhrule
			\end{minipage}
		}
	\end{center}
	\vspace{-2ex}
	\caption{\small Aggressive spatio-temporal cone intersection algorithm (\cista).}
	\label{alg:ciseda}
	\vspace{-2ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\stitle{Correctness and complexity analyses}.
%
The correctness of algorithms \cist and \cista follows from Propositions~\ref{prop-circle-intersection} and~\ref{prop-3d-ci-half}, and Propositions~\ref{prop-circle-intersection} and~\ref{prop-cist-Q}, respectively.
%
It is easy to verify that each data point in a trajectory is only processed once, and each can be done in $O(1)$ time,
as both procedures  $\kw{getRegularPolygon}$ and $\rpia$ can be done in $O(1)$ time.
Hence, these algorithms are both one-pass error bounded trajectory simplification algorithms.
It is also easy to see that these algorithms take $O(1)$ space.
%These together also complete the proof of Theorem~\ref{prop-cist-op}.

