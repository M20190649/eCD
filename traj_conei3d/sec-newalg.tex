\section{One pass algorithms}
In this section, we present two one pass algorithms implementing the one pass \sed checking method.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{{One-pass algorithm}}
\subsection{{Algorithm \cist}}

Note that in Theorem~\ref{prop-3d-ci}, the point $Q$ may not be in the sub trajectory $[P_s,...,P_e]$. If we mandatory require $Q=P_e$, the end point of the sub trajectory, then a \emph{narrow} spatio-temporal cone with a threshold of $\epsilon/2$ would help.

\begin{theorem}
\label{prop-3d-ci-half}
Given a sub trajectory $\{P_s, \ldots, P_e\}$ and a constant $\epsilon$, if $\bigcap_{i=s+1}^{e}{\mathcal{C}(P_s, P_i, \epsilon/2)} \ne \{P_s\}$ then the sub trajectory can be represented by the line segment $\vv{P_sP_e}$.
\end{theorem}

\begin{proof}
If $\bigcap_{i=s+1}^{e}{\mathcal{C}(P_s, P_i, \epsilon/2)} \ne \{P_s\}$, then by Theorem~\ref{prop-3d-ci}, there exists a point $Q$, $Q.t = P_e.t$, such that $sed(P_i, \vv{P_sQ})<\epsilon/2$ for all $P_i$, $i \in [s,e]$. Hence, $sed(P_i, \vv{P_sP_e})\le \epsilon/2 + |P_eQ| < \epsilon/2 + \epsilon/2 = \epsilon$.
\end{proof}


\begin{figure*}[tb!]
\centering
\includegraphics[scale=0.8]{figures/Fig-ex-conest.png}
\vspace{-1ex}
\caption{\small A running example of the \cist algorithm. The points and the oblique circular cones are projected on an x-y space. The trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_{10}]$ is compressed to four line segments.}
\vspace{-2ex}
\label{fig:exm-const}
\end{figure*}



%%%%%%%%%%%%%%%%%%%%%Baseline Algorithm
\begin{figure}[tb!]
\begin{center}
{\small
\begin{minipage}{3.36in}
\myhrule
\vspace{-1ex}
\mat{0ex}{
	{\bf Algorithm} ~$\cist(\dddot{\mathcal{T}}[P_0,\ldots,P_n], \epsilon, M)$\\
	\sstab
	\bcc \hspace{1ex}\= $P_s := P_0$; $P_e := P_0$; $\overline{\mathcal{T}} := \phi$; $\mathcal{G}^* := \phi$; $i := 1$;\\
%         \hspace{2ex}     $intersection = \emptyset$;   \\
	\icc \hspace{1ex}\= \While $i \le n$ \Do \\
	\icc \>\hspace{3ex} $\mathcal{G} := {getRegularPolygon}$($P_s$, $P_i$, $\epsilon/2$, $M$) \\
	\icc \>\hspace{3ex} $\mathcal{G}^* := {getIntersectPolygon}(\mathcal{G}^*, ~\mathcal{G})$ \\
	\icc \>\hspace{3ex} \If $\mathcal{G}^* \ne \phi$ \Then \\
	\icc \> \hspace{6ex} $P_e := P_i$ \\
	\icc \> \hspace{6ex} $i := i+1$ \\
	\icc \>\hspace{3ex} \Else\\
	\icc \> \hspace{6ex} $\overline{\mathcal{T}} := \overline{\mathcal{T}}\cup \{\mathcal{L}(P_s,P_e)\}$ \\
	\icc \> \hspace{6ex} $P_s = P_e$; $\mathcal{G}^* = \phi$ \\
	\icc \hspace{1ex}\Return $\overline{\mathcal{T}}$
%
%	{\bf procedure} $getPolygon$($P_s$, $P_i$, $\epsilon/2$) \\
%
%	{\bf procedure} $getIntersection(ipolygon, \mathcal{G})$ \\
}
\vspace{-2ex}
\myhrule
\end{minipage}
}
\end{center}
\vspace{-2ex}
\caption{\small Spatio-Temporal Cone Intersection algorithm.}
\label{alg:CI3d}
\vspace{-2ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We now are ready to present the \underline{C}one \underline{I}ntersection with \underline{S}ynchronous \underline{E}uclidean \underline{D}istance (\cist) algorithm.

As shown in Figure~\ref{alg:CI3d}, the algorithm takes as input a trajectory $\dddot{\mathcal{T}}$, an error bound $\epsilon$ and the edges number $M$ of a regular polygon, and returns the simplified trajectory $\overline{\mathcal{T}}$.

The algorithm first initializes the start and end points $P_s$ and $P_e$ to $P_0$, the intersection polygon $\mathcal{G}^*$ to $\phi$, the output set $\overline{\mathcal{T}}$ to $\phi$ and the index $i$ of point to $1$ (line 1).

The algorithm sequentially processes each point in the trajectory (line 2).
It gets the regular polygon of the current point $P_i$ (line 3).
This is performed by calling procedure $getRegularPolygon()$. The procedure $getRegularPolygon()$ is an implementation of equations (1)-(3). It first gets the projection circle for the current point, defined by equations (1) and (2); then it builds the inscribed regular polygon $\mathcal{G}$ from the projection circle, defined by equation (3).

After that, it gets the intersection polygon of the current regular polygon $\mathcal{G}$ with the polygon formed by all the preview regular polygons, and saves it in $\mathcal{G}^*$ (line 4).
This is performed by calling procedure $getIntersectPolygon()$. The {procedure $getIntersectPolygon()$} implements the convex polygons intersection algorithm presented in \cite{ORourke:Intersection}, which returns the intersection polygon of the two input polygons.

If the intersection polygon is not empty, then the process goes on to the next point (lines 5-7).
Otherwise, the current section is terminated and a new section is started (lines 8-10).

At last, the algorithm returns $\overline{\mathcal{T}}$ (line 11).





\begin{example}
\label{exm-alg-conest}
Figure~\ref{fig:exm-const} is a running example of the \cist algorithm taking as input the same trajectory as shown in Figure~\ref{fig:notations} and Figure~\ref{fig:sleeve}.
%, and a distance tolerance $\epsilon$
%At the beginning, $P_0$ is the start point.
For convenience, here, we project the points and the oblique circular cones on a x-y space.

\sstab (1) After initialization, the \cist algorithm reads point $P_1$ and builds a narrow \emph{oblique circular cone} $\mathcal{C}$($P_0$, $P_{1}$, $\epsilon/2$), taking $P_0$ as the vertex and $\mathcal{O}(P_1, \epsilon/2)$ as the bottom circle (green dash). The \emph{circular cone} is projected on the plane $t=t_1$, and the inscribe regular polygon $\mathcal{G}_1$ of the projection circle is returned. The intersection of $\mathcal{G}_1$ and $\mathcal{G}^*$ is $\mathcal{G}_1 \ne \phi$.

\sstab (2) The algorithm reads $P_2$ and builds $\mathcal{C}$($P_0$, $P_{2}$, $\epsilon/2$) (red dash). The \emph{circular cone} is also projected on the plane $t=t_1$ and the inscribe regular polygon $\mathcal{G}_2$ of the projection circle is returned. The intersection of $\mathcal{G}_2$ and $\mathcal{G}^*$ is not $\phi$.

\sstab (3) For point $P_3$, the algorithm runs the same routing as $P_2$. However, the intersection of $\mathcal{G}_3$ and $\mathcal{G}^*$ is $\phi$. Thus, line segment $\vv{P_0P_2}$ is output, and a new section is started, taking $P_2$ as the new start point.

\sstab (4) At last, the algorithm outputs four continuous line segments, \ie $\vv{P_0P_2}$, $\vv{P_2P_4}$, $\vv{P_4P_{7}}$ and $\vv{P_7P_{10}}$.
\end{example}




\subsection{{Algorithm \cista}}


\begin{figure*}[tb!]
\centering
\includegraphics[scale=0.8]{figures/Fig-conesta.png}
\vspace{-1ex}
\caption{\small A running example of the \cista algorithm. The points and the oblique circular cones are projected on an x-y space. The trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_{10}]$ is compressed to three line segments.}
\vspace{-2ex}
\label{fig:exm-consta}
\end{figure*}


%%%%%%%%%%%%%%%%%%%%%Baseline Algorithm
\begin{figure}[tb!]
\begin{center}
{\small
\begin{minipage}{3.36in}
\myhrule
\vspace{-1ex}
\mat{0ex}{
	{\bf Algorithm} ~$\cista(\dddot{\mathcal{T}}[P_0,\ldots,P_n], \epsilon, M)$\\
	\sstab
	\bcc \hspace{1ex}\= $P_s := P_0$; $P_e := P_0$; $\overline{\mathcal{T}} := \phi$; $\mathcal{G}^* := \phi$; $i := 1$;\\
%         \hspace{2ex}     $intersection = \emptyset$;   \\
	\icc \hspace{1ex}\= \While $i \le n$ \Do \\
	\icc \>\hspace{3ex} $\mathcal{G} := {getRegularPolygon}$($P_s$, $P_i$, $\epsilon/2$, $M$) \\
	\icc \>\hspace{3ex} $\mathcal{G}^* := {getIntersectPolygon}(\mathcal{G}^*, ~\mathcal{G})$ \\
	\icc \>\hspace{3ex} \If $\mathcal{G}^* \ne \phi$ \Then \\
	\icc \> \hspace{6ex} $P_e := P_i$ \\
	\icc \> \hspace{6ex} $i := i+1$ \\
	\icc \>\hspace{3ex} \Else\\
	\icc \> \hspace{6ex} $\overline{\mathcal{T}} := \overline{\mathcal{T}}\cup \{\mathcal{L}(P_s,P_e)\}$ \\
	\icc \> \hspace{6ex} $P_s = P_e$; $\mathcal{G}^* = \phi$ \\
	\icc \hspace{1ex}\Return $\overline{\mathcal{T}}$
%
%	{\bf procedure} $getPolygon$($P_s$, $P_i$, $\epsilon/2$) \\
%
%	{\bf procedure} $getIntersection(ipolygon, \mathcal{G})$ \\
}
\vspace{-2ex}
\myhrule
\end{minipage}
}
\end{center}
\vspace{-2ex}
\caption{\small Spatio-Temporal Cone Intersection algorithm.}
\label{alg:ciseda}
\vspace{-2ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


If we allow $\overline{\mathcal{T}}$ be not a sub set of $\dddot{\mathcal{T}}$, then an aggressive \cist (\ie in Figure~\ref{alg:CI3d}, $\epsilon/2$ of line 3 be replaced by $\epsilon$ and $P_e$ of lines 9-10 be replace by $Q$ of Theorem~\ref{prop-3d-ci}) will bring better compression ratios.

\begin{example}
\label{exm-alg-conesta}
Figure~\ref{fig:exm-consta} is a running example of the \cista algorithm taking as input the same trajectory as shown in above.
\end{example}


\subsection{Correctness and complexity analysis}

The correctness of algorithm \cist follows from Corollary~\ref{prop-3d-ci-half} and Corollary~\ref{prop-circle-intersection}. For the circles intersection of Corollary~\ref{prop-circle-intersection}, we replace it by the regular polygons intersection.
Meanwhile, given time $t_c$ and projection circles $\mathcal{O}(P^c_i, r^c_i)$, $i \in (s, e]$, we get a inscribed regular polygon from each projection circle.
If these regular polygons are intersecting, then $sed(P_i, \vv{P_sP_e})<\epsilon$ for all points $P_i$, $i \in [s,e]$.
This ensures the correctness of the algorithm.


For time complexity, we have follows.

%The procedure getPolygon() has $O(M)$ time.




\begin{theorem}
\label{prop-cist-complexity}
The spatio-temporal cone intersection (\cist) algorithm has a linear time complexity.
\end{theorem}

\begin{proof}
For each data point, the procedures $getPolygon()$ and $getIntersection()$ are both called one time.

\hspace{-2ex}(1) Procedure $getPolygon()$ completes in $O(1)$ time, and,

\hspace{-2ex}(2) Procedure $getIntersection()$ implements the polygon intersection algorithm presented in [18]. Given the inputs polygon $\mathcal{G}_1$ and $\mathcal{G}_2$, the algorithm has the time complexity of $O(|\mathcal{G}_1.E| + |\mathcal{G}_2.E|)$. By Theorem~\ref{prop-rp-intersection}, we know that $|\mathcal{G}_1.E| \le M$ and $|\mathcal{G}_2.E|\le M$, where $M$ is the number of vertices in a regular polygon. Hence, $getIntersection()$ completes in $O(M)$ time.

$M$ is a constant, thus, the process of a point needs constant time. Hence, the algorithm has a time complexity of $O(N)$.
This finishes the proof.
\end{proof}


{For space complexity, the algorithm needs $O(M)$ space.}
