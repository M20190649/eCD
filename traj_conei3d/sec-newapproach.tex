%\section{One-pass Spatio-temporal data simplification}
\section{One-pass \sed checking method}

In this section, we first discuss the properties of synchronous data points and \sed, then we present a novel \sed checking method by extending the idea of cone intersection. Finally, we provide a one-pass, error-bounded and \sed enabled trajectory simplification algorithm.
%we first present the spatio-temporal simplification problem in the spatio-temporal space and discuss the properties of the synchronous Euclidean distances, then we solve this problem by an extended cone intersection approach.


\subsection{Properties of \sed} %and synchronous points     %Spatio-temporal Data
Recall in its definition, the \sed of point $P_i$ to a directed line segment $\mathcal{L} = \vv{P_{s}P_{e}}$, denoted as $sed(P_i, \mathcal{L})$, is $|P_iP_i'|$, the distance from $P_i$ to its synchronous point $P_i' (x_i', y_i', t_i)$ \wrt $\mathcal{L}$.
We demonstrate the \sed and the synchronous points in the spatio-temporal space, as shown in Figure~\ref{fig:sed3d}.





%\textcolor[rgb]{1.00,0.00,0.00}{The \sed is demonstrated in 2D space in the previews works~\cite{Meratnia:Spatiotemporal, Chen:Fast, Muckell:Compression, Popa:Spatio}. However,  the trajectory and the \sed are also capable presented in 3D space.}

\begin{lemma}
\label{prop-3d-syn-point}
Given a sub trajectory $[P_s, \ldots, P_e]$ and a point $P_i$, $s<i<e$, the intersection point $P'_i$ of the plane $t=t_i$ and the directed line segment $\mathcal{L} = \vv{P_sP_e}$ is the synchronous data point of $P_i$ \wrt $\mathcal{L}$ in the spatio-temporal space.
\end{lemma}

\begin{proof}
As shown in Figure~\ref{fig:sed3d}, the point $P'_i (x'_i, y'_i, t'_i)$ is the intersection point of the plane $t=t_i$ and the directed line segment $\mathcal{L} = \vv{P_sP_e}$, thus, $t'_i = t_i$ and $\frac{t'_i - t_s}{t_e - t_s}$ = $\frac{t_i - t_s}{t_e - t_s}$  = $\frac{|P_sP'_i|}{|P_sP_e|}$ = $\frac{x'_i - x_s}{x_e - x_s}$ = $\frac{y'_i - y_s}{y_e - y_s}$. Hence, $x'_i = x_s +  \frac{t_i-t_s}{t_e - t_s}(x_e - x_s)$ and $y'_i = y_s +  \frac{t_i - t_s}{t_e - t_s}(y_e - y_s)$, which satisfies the definition of the synchronous data point $P_i$ \wrt $\vv{P_sP_e}$.
\end{proof}




%\begin{definition}
%\label{def:scircle}
\stitle{Synchronous Circles ($\mathcal{O})$}. The synchronous circle of point $P_i$, denoted as $\mathcal{O}(P_i, \epsilon)$, is a circle on the plane $t=t_i$, taking $P_i$ as the center point and having radius of $\epsilon$. %(see Figure~\ref{fig:sed3d}).
%\end{definition}

For example, in Figure~\ref{fig:sed3d}, the point $P_i$ has a synchronous circles $\mathcal{O}(P_i, \epsilon)$. All points in the circle have distances (\ie \sed) less than $\epsilon$ to $P_i$.

With Lemma~\ref{prop-3d-syn-point} and the notion of \emph{synchronous circle}, and from the geometrical perspective, we have Theorem~\ref{prop-3d-sed-sim}.

\begin{theorem}
\label{prop-3d-sed-sim}
Given a sub trajectory $[P_s, \ldots, P_e]$ and a constant $\epsilon$, the sub trajectory can be represented by the line segment $\vv{P_sP_e}$ if and only if the line segment passes through all synchronous circles $\mathcal{O}(P_i, \epsilon)$ for $i \in (s, e)$.
\end{theorem}

\begin{proof}
As shown in Figure~\ref{fig:sed3d}, let $P'_i$ be the intersection point of the line segment $\vv{P_sP_e}$ and the plane $t=t_i$.
By Lemma~\ref{prop-3d-syn-point}, the point $P'_i$ is the synchronous data point of $P_i$ \wrt line segment $\vv{P_sP_e}$.

(1) If the line segment $\vv{P_sP_e}$ passes through all synchronous circles $\mathcal{O}(P_i, \epsilon)$ for $i \in (s, e)$, then by the definition of synchronous circle, it must pass through the circle which is on the plane $t=t_i$ and around point $P_i$, and has a radius of $\epsilon$, thus, $|P'_iP_i| <\epsilon$. Furthermore, the property is hold for each $i \in (s, e)$, hence, the sub trajectory $[P_s, \ldots, P_e]$ can be represented by the line segment $\vv{P_sP_e}$.

(2) If the sub trajectory $[P_s, \ldots, P_e]$ can be represented by the line segment $\vv{P_sP_e}$, then $|P'_iP_i| <\epsilon$ for each $i \in (s, e)$, \ie $P'_i$ is in the synchronous circles $\mathcal{O}(P_i, \epsilon)$. Thus, the line segment $\vv{P_sP_e}$ passes through all synchronous circles $\mathcal{O}(P_i, \epsilon)$ for $i \in (s, e)$.

We have the conclusion.
\end{proof}


\begin{figure}[tb!]
\centering
\includegraphics[scale=0.6]{figures/Fig-SEDin3D.png}
\vspace{-1ex}
\caption{\small Trajectory simplification in the Spatio-temporal space. Note the synchronous circle $\mathcal{O}(P_i, \epsilon)$ is on the plane $t=t_i$.}
\vspace{-3ex}
\label{fig:sed3d}
\end{figure}


%A sub trajectory $\{P_s, \ldots, P_e\}$ is represented by a line segment $\overline{P_sP_e}$
%which passes through the circle on the plane $t=t_i$ and around point $P_i$, for each $s<i<e$.}


\subsection{Spatio-temporal cone intersection}

In this section, we expand the \emph{cone intersection} method from a 2D space, \ie the $x$-$y$ space, to a 3D space, \ie the spatio-temporal space.
In the spatio-temporal space, the notion \emph{cone} of the cone intersection \cite{Williams:Longest, Sklansky:Cone} (or \emph{sector} of sleeve \cite{Zhao:Sleeve}) algorithm is extended to a new notion, \ie the \emph{spatio-temporal cone}.

\stitle{Spatio-temporal cones ($\mathcal{C}$)}. Given a sub trajectory $\{P_s,...,P_e\}$ and a constant $\epsilon$, the spatio-temporal cone of point $P_i$ \wrt point $P_s$, denoted as $\mathcal{C}(P_s, P_i, \epsilon)$, is an oblique circular cone which takes the start point $P_s$ as its vertex and the synchronous circle $\mathcal{O}(P_i, \epsilon)$ as its bottom circle.

For example, in Figure~\ref{fig:cis}, the points $P_s$ and $P_i$ forms an spatio-temporal cone $\mathcal{C}(P_s, P_i, \epsilon)$, and the points $P_s$ and $P_{i+1}$ forms another spatio-temporal cone $\mathcal{C}(P_s, P_{i+1}, \epsilon)$.

Based on the notion of spatio-temporal cone, we further use a novel 3D cone intersection method to check whether there exists a line start from $P_s$ approximating these points.

\begin{theorem}
\label{prop-3d-ci}
Given a sub trajectory $[P_s,...,P_e]$ and a constant $\epsilon$, there exists a point $Q$, $Q.t = P_e.t$, such that $sed(P_i, \vv{P_sQ})<\epsilon$ for all $P_i$, $i \in [s,e]$, if and only if $\bigcap_{i=s+1}^{e}{\mathcal{C}(P_s, P_i, \epsilon)} \ne \{P_s\}$.
\end{theorem}

\begin{proof}
Let $P'_i$ be the intersection point of the line segment $\vv{P_sQ}$ and the plane $t=t_i$.
By Lemma~\ref{prop-3d-syn-point}, the point $P'_i$ is the synchronous data point of $P_i$ \wrt the line segment $\vv{P_sQ}$.


(1) If $\bigcap_{i=s+1}^{e}{\mathcal{C}(P_s, P_i, \epsilon)} \ne \{P_s\}$, then there must exits a point $Q = (x,y,t_e)$ within the circle $\mathcal{O}(P_e, \epsilon)$ of $P_e$ such that $\vv{P_sQ}$ passes through the intersection of all the cones. Hence it pass through all circles $\mathcal{O}(P_i, \epsilon)$ for $i \in (s, e]$, and the intersection point, $P'_i$, is sure within the circle $\mathcal{O}(P_i, \epsilon)$. Thus, $sed(P_i, \vv{P_sQ}) = |P'_iP_i| < \zeta$, for $i \in (s, e]$.

(2) If there exists a point $Q$, $Q.t = P_e.t$, such that $sed(P_i, \vv{P_sQ})<\epsilon$ for all $P_i$, $i \in [s,e]$, then $|P'_iP_i| < \zeta$ for all $i \in (s, e]$. Hence, $\bigcap_{i=s+1}^{e}{\mathcal{C}(P_s, P_i, \epsilon)} \ne \{P_s\}$.

We have the conclusion.
\end{proof}


\begin{figure}[tb!]
\centering
\includegraphics[scale=0.6]{figures/Fig-cis.png}
%\vspace{-1ex}
\caption{\small Examples of spatio-temporal cones. A spatio-temporal cone is an oblique circular cone whose bottom circle and projection circle are parallel to the x-y plane. }
\vspace{-3ex}
\label{fig:cis}
\end{figure}
%Note that the projection circle $\mathcal{O}(P^i_{i+1}, r^i_{i+1})$ is on the plane $t=t_i$.

The checking of intersection of these cones could be enforced by a more simple way, \ie the checking of the intersection of circles on a plane.

\stitle{Projection circles}. Given time $t_c > t_s$, the projection of the synchronous circle $\mathcal{O}(P_i, \epsilon)$ of point $P_i$ on the plane $t=t_c$ is a circle, denoted as $\mathcal{O}(P^c_i, r^c_i)$, where $P^c_i$ =  $(x^c_i, y^c_i, t_c)$ satisfying:


\vspace{-1ex}
\begin{equation*}
\label{equ-proj-circle-xy}
\hspace{10ex} \left\{
    \begin{aligned}
        & x^c_i = x_s +  \frac{t_c - t_s}{t_i - t_s}(x_i - x_s) \\
        & y^c_i = y_s +  \frac{t_c - t_s}{t_i - t_s}(y_i - y_s) \\
    \end{aligned}
    \right.       \hspace{15ex}(1)
\end{equation*}
\vspace{-1ex}

and

\vspace{-1ex}
\begin{equation*}
\label{equ-proj-circle-r}
    \begin{aligned}
        \hspace{17ex}  r^c_i =\frac{t_c-t_s}{t_i-t_s}{\epsilon}   \hspace{25ex}(2) \\
    \end{aligned}
\end{equation*}
\vspace{-1ex}



For example, in Figure~\ref{fig:cis}, the red dash circle on plane $t=t_i$, \ie $\mathcal{O}(P^i_{i+1}, r^i_{i+1})$, is the projection circle of the synchronous circle $\mathcal{O}(P_{i+1}, \epsilon)$ on plane $t=t_i$.

\vspace{1ex}

\begin{cor}
\label{prop-circle-intersection}
Given time $t_c > t_s$, there exists a point $Q$, $Q.t = P_e.t$, such that $sed(P_i, \vv{P_sQ})<\epsilon$ for all points $P_i$, $i \in [s,e]$, if and only if $\bigcap_{i=s+1}^{e}{\mathcal{O}(P^c_i, r^c_i)} \ne \phi$.
\end{cor}


\begin{proof}
These oblique circular cones have the same vertex $P_s$ and their bottom circles are parallel, thus,
 ``$\bigcap_{i=1}^{e}{\mathcal{O}(P^c_i, r^c_i)} \ne \phi$, $t_c > t_s$" is naturally equivalent to ``$\bigcap_{i=s+1}^{e}{\mathcal{C}(P_s, P_i, \epsilon)} \ne \{P_s\}$".
For example, in Figure~\ref{fig:sed3d}, $\mathcal{O}(P^i_{i+1}, r^i_{i+1})$ is the projection circle of synchronous circle $\mathcal{O}(P_{i+1}, \epsilon)$ on the plane $t=t_i$, then ``${\mathcal{O}(P^i_{i+1}, r^i_{i+1})} \bigcap{\mathcal{O}(P_i, \epsilon)} \ne \phi$" is equal to ``$\mathcal{C}(P_s, P_i, \epsilon) \bigcap {\mathcal{C}(P_s, P_{i+1}, \epsilon)} \ne \{P_s\}$".
Hence, by Theorem~\ref{prop-3d-ci}, we have the conclusion.
\end{proof}


\subsection{Approximate circles intersection}

The checking of the $N$ circles intersection has a time complexity of ${O(N\log N)}$~\cite{Shamos:Circle}, which is not the linear time.
To develop a linear time complexity spatio-temporal simplification algorithm, we provide an approximate circles intersection method.
That is, we further replace a circle $\mathcal{O}(P, r)$ to a $M$-edges inscribed regular polygon $\mathcal{G}(V, E)$, where $V=\{v_1, \ldots, v_{M}\}$ is the set of vertexes and $E= \{\overline{v_jv_{j+1}}| j\in [1,M-1]\} \bigcup \{\overline{v_Mv_1}\}$ is the set of edges.
Furthermore, if we let the center point $P$ of the circle be the origin of polar coordinate system, then each vertex satisfies:

\vspace{-2ex}
\begin{equation*}
\label{equ-regular-polygon}
%\hspace{-1.5ex}
    \begin{aligned}
        \hspace{10ex}  v_j = (r, \frac{2(j-1)}{M}\pi), ~j \in [1, M]    \hspace{15ex} (3)\\
    \end{aligned}
\end{equation*}
\vspace{-2ex}




For example, Figure~\ref{fig:polygons}-(1) is a regular octagon whose vertexes satisfying the Equation (3).

%
Then we check the intersection of the regular polygons instead of the checking of circles intersection.
%The intersection of two M-edges convex polygons has a time complexity of $O(M)$ \cite{ORourke:Intersection}.
The regular polygons built by equation (3) have elegant properties, which is helpful to derive an algorithm of linear time and constant space for the intersection of $N$ regular polygons.


\begin{figure}[tb!]
\centering
\includegraphics[scale=0.8]{figures/Fig-polygons.png}
\vspace{-1ex}
\caption{\small Regular octagons and their intersections.}
\vspace{-3ex}
\label{fig:polygons}
\end{figure}



\begin{theorem}
\label{prop-rp-intersection}
If $\mathcal{G}_i$, $i \in [1, k]$, are M-edges regular polygons on a plane which are built by equation (3), then the intersection polygon $\mathcal{G}^*$ of all $\mathcal{G}_i$ has no more than $M$ edges.
\end{theorem}


\begin{proof}
Let $e_{i,j} = \overline{v_{i,j}v_{i,j+1}}$, $j\in [1,M)$, or $e_{i,j} = \overline{v_{i,M}v_{i,1}}$, $j = M$, be an edge of regular polygons $\mathcal{G}_i$, then all $e_{i,j}$, $i\in [1, k]$ form an \emph{edge group}, namely the $j^{th}$ edge group (see Figure~\ref{fig:polygons}-(2)).
We first prove that the intersection polygon $\mathcal{G}^*$ includes at most one edge from an edge group, \eg the $j^{th}$ edge group.
We prove this by contradiction.

Suppose $\mathcal{G}^*$ have two different edges, $e_{h,j}$ and $e_{l,j}$, $h\ne l$, belonging to the $j^{th}$ edge group. Obviously, edge $e_{h,j}$ belongs to regular polygon $\mathcal{G}_h$, edge $e_{l,j}$ belongs to regular polygon $\mathcal{G}_l$ and $e_{h,j}$ is parallel to $e_{l,j}$.

If $\mathcal{G}_l \bigcap \mathcal{G}_h = \phi$, then $\mathcal{G}^*=\phi$, which conflicts with the hypothetic premises.

If $\mathcal{G}_l \bigcap \mathcal{G}_h \ne \phi$, then the intersection polygon of $\mathcal{G}_h$ and $\mathcal{G}_l$ must include at most one edge of $e_{h,j}$ and $e_{l,j}$, which is also the contradiction with the hypothetic premises.

Hence, the intersection polygon $\mathcal{G}^*$ includes at most one edge of an edge group.
%
There are at most $M$ edge groups, thus, the intersection polygon $\mathcal{G}^*$ has no more than $M$ edges.
\end{proof}

Note that the intersection of regular polygons is only a sufficient condition of the intersection of the corresponding circles , and algorithms employ this policy may loss some compression ratio. Obviously, a larger $M$ leads to a better compression ratio and a poorer efficiency.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{{One-pass algorithm}}
\subsection{{Algorithm \cist}}

Note that in theorem~\ref{prop-3d-ci}, the point $Q$ may not be in the sub trajectory $[P_s,...,P_e]$. If we mandatory require $Q=P_e$, the end point of the sub trajectory, then a \emph{narrow} spatio-temporal cone with a threshold of $\epsilon/2$ would help.

\begin{cor}
\label{prop-3d-ci-half}
Given a sub trajectory $\{P_s, \ldots, P_e\}$ and a constant $\epsilon$, if $\bigcap_{i=s+1}^{e}{\mathcal{C}(P_s, P_i, \epsilon/2)} \ne \{P_s\}$ then the sub trajectory can be represented by the line segment $\vv{P_sP_e}$.
\end{cor}

\begin{proof}
If $\bigcap_{i=s+1}^{e}{\mathcal{C}(P_s, P_i, \epsilon/2)} \ne \{P_s\}$, then by Theorem~\ref{prop-3d-ci}, there exists a point $Q$, $Q.t = P_e.t$, such that $sed(P_i, \vv{P_sQ})<\epsilon/2$ for all $P_i$, $i \in [s,e]$. Hence, $sed(P_i, \vv{P_sP_e})\le \epsilon/2 + |P_eQ| < \epsilon/2 + \epsilon/2 = \epsilon$.
\end{proof}


\begin{figure*}[tb!]
\centering
\includegraphics[scale=0.8]{figures/Fig-ex-conest.png}
\vspace{-1ex}
\caption{\small A running example of the \cist algorithm. The points and the oblique circular cones are projected on an x-y space. The trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_{10}]$ is compressed to four line segments.}
\vspace{-2ex}
\label{fig:exm-const}
\end{figure*}



%%%%%%%%%%%%%%%%%%%%%Baseline Algorithm
\begin{figure}[tb!]
\begin{center}
{\small
\begin{minipage}{3.36in}
\myhrule
\vspace{-1ex}
\mat{0ex}{
	{\bf Algorithm} ~$\cist(\dddot{\mathcal{T}}[P_0,\ldots,P_n], \epsilon, M)$\\
	\sstab
	\bcc \hspace{1ex}\= $P_s := P_0$; $P_e := P_0$; $\overline{\mathcal{T}} := \phi$; $\mathcal{G}^* := \phi$; $i := 1$;\\
%         \hspace{2ex}     $intersection = \emptyset$;   \\
	\icc \hspace{1ex}\= \While $i \le n$ \Do \\
	\icc \>\hspace{3ex} $\mathcal{G} := {getRegularPolygon}$($P_s$, $P_i$, $\epsilon/2$, $M$) \\
	\icc \>\hspace{3ex} $\mathcal{G}^* := {getIntersectPolygon}(\mathcal{G}^*, ~\mathcal{G})$ \\
	\icc \>\hspace{3ex} \If $\mathcal{G}^* \ne \phi$ \Then \\
	\icc \> \hspace{6ex} $P_e := P_i$ \\
	\icc \> \hspace{6ex} $i := i+1$ \\
	\icc \>\hspace{3ex} \Else\\
	\icc \> \hspace{6ex} $\overline{\mathcal{T}} := \overline{\mathcal{T}}\cup \{\mathcal{L}(P_s,P_e)\}$ \\
	\icc \> \hspace{6ex} $P_s = P_e$; $\mathcal{G}^* = \phi$ \\
	\icc \hspace{1ex}\Return $\overline{\mathcal{T}}$
%
%	{\bf procedure} $getPolygon$($P_s$, $P_i$, $\epsilon/2$) \\
%
%	{\bf procedure} $getIntersection(ipolygon, \mathcal{G})$ \\
}
\vspace{-2ex}
\myhrule
\end{minipage}
}
\end{center}
\vspace{-2ex}
\caption{\small Spatio-Temporal Cone Intersection algorithm}
\label{alg:CI3d}
\vspace{-2ex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We now are ready to present the \underline{C}one \underline{I}ntersection with \underline{S}ynchronous \underline{E}uclidean \underline{D}istance (\cist) algorithm.

As shown in Figure~\ref{alg:CI3d}, the algorithm takes as input a trajectory $\dddot{\mathcal{T}}$, an error bound $\epsilon$ and the edges number $M$ of a regular polygon, and returns the simplified trajectory $\overline{\mathcal{T}}$.

The algorithm first initializes the start and end points $P_s$ and $P_e$ to $P_0$, the intersection polygon $\mathcal{G}^*$ to $\phi$, the output set $\overline{\mathcal{T}}$ to $\phi$ and the index $i$ of point to $1$ (line 1).

The algorithm sequentially processes each point in the trajectory (line 2).
It gets the regular polygon of the current point $P_i$ (line 3).
This is performed by calling procedure $getRegularPolygon()$. The procedure $getRegularPolygon()$ is an implementation of equations (1)-(3). It first gets the projection circle for the current point, defined by equations (1) and (2); then it builds the inscribed regular polygon $\mathcal{G}$ from the projection circle, defined by equation (3).

After that, it gets the intersection polygon of the current regular polygon $\mathcal{G}$ with the polygon formed by all the preview regular polygons, and saves it in $\mathcal{G}^*$ (line 4).
This is performed by calling procedure $getIntersectPolygon()$. The {procedure $getIntersectPolygon()$} implements the convex polygons intersection algorithm presented in \cite{ORourke:Intersection}, which returns the intersection polygon of the two input polygons.

If the intersection polygon is not empty, then the process goes on to the next point (lines 5-7).
Otherwise, the current section is terminated and a new section is started (lines 8-10).

At last, the algorithm returns $\overline{\mathcal{T}}$ (line 11).





\begin{example}
\label{exm-alg-conest}
Figure~\ref{fig:exm-const} is a running example of the \cist algorithm taking as input the same trajectory as shown in Figure~\ref{fig:notations} and Figure~\ref{fig:sleeve}.
%, and a distance tolerance $\epsilon$
%At the beginning, $P_0$ is the start point.
For convenience, here, we project the points and the oblique circular cones on a x-y space.

\sstab (1) After initialization, the \cist algorithm reads point $P_1$ and builds a narrow \emph{oblique circular cone} $\mathcal{C}$($P_0$, $P_{1}$, $\epsilon/2$), taking $P_0$ as the vertex and $\mathcal{O}(P_1, \epsilon/2)$ as the bottom circle (green dash). The \emph{circular cone} is projected on the plane $t=t_1$, and the inscribe regular polygon $\mathcal{G}_1$ of the projection circle is returned. The intersection of $\mathcal{G}_1$ and $\mathcal{G}^*$ is $\mathcal{G}_1 \ne \phi$.

\sstab (2) The algorithm reads $P_2$ and builds $\mathcal{C}$($P_0$, $P_{2}$, $\epsilon/2$) (red dash). The \emph{circular cone} is also projected on the plane $t=t_1$ and the inscribe regular polygon $\mathcal{G}_2$ of the projection circle is returned. The intersection of $\mathcal{G}_2$ and $\mathcal{G}^*$ is not $\phi$.

\sstab (3) For point $P_3$, the algorithm runs the same routing as $P_2$. However, the intersection of $\mathcal{G}_3$ and $\mathcal{G}^*$ is $\phi$. Thus, line segment $\vv{P_0P_2}$ is output, and a new section is started, taking $P_2$ as the new start point.

\sstab (4) At last, the algorithm outputs four continuous line segments, \ie $\vv{P_0P_2}$, $\vv{P_2P_4}$, $\vv{P_4P_{7}}$ and $\vv{P_7P_{10}}$.
\end{example}




\subsection{{Algorithm \cista}}


\begin{figure*}[tb!]
\centering
\includegraphics[scale=0.8]{figures/Fig-conesta.png}
\vspace{-1ex}
\caption{\small A running example of the \cista algorithm. The points and the oblique circular cones are projected on an x-y space. The trajectory $\dddot{\mathcal{T}}[P_0, \ldots, P_{10}]$ is compressed to three line segments.}
\vspace{-2ex}
\label{fig:exm-consta}
\end{figure*}



If we allow $\overline{\mathcal{T}}$ be not a sub set of $\dddot{\mathcal{T}}$, then an aggressive \cist (\ie in Figure~\ref{alg:CI3d}, $\epsilon/2$ of line 3 be replaced by $\epsilon$ and $P_e$ of lines 9-10 be replace by $Q$ of Theorem~\ref{prop-3d-ci}) will bring better compression ratios.

\begin{example}
\label{exm-alg-conesta}
Figure~\ref{fig:exm-consta} is a running example of the \cista algorithm taking as input the same trajectory as shown in above.
\end{example}


\subsection{Correctness and complexity analysis}

The correctness of algorithm \cist follows from Corollary~\ref{prop-3d-ci-half} and Corollary~\ref{prop-circle-intersection}. For the circles intersection of Corollary~\ref{prop-circle-intersection}, we replace it by the regular polygons intersection.
Meanwhile, given time $t_c$ and projection circles $\mathcal{O}(P^c_i, r^c_i)$, $i \in (s, e]$, we get a inscribed regular polygon from each projection circle.
If these regular polygons are intersecting, then $sed(P_i, \vv{P_sP_e})<\epsilon$ for all points $P_i$, $i \in [s,e]$.
This ensures the correctness of the algorithm.


For time complexity, we have follows.

%The procedure getPolygon() has $O(M)$ time.




\begin{theorem}
\label{prop-cist-complexity}
The spatio-temporal cone intersection (\cist) algorithm has a linear time complexity.
\end{theorem}

\begin{proof}
For each data point, the procedures $getPolygon()$ and $getIntersection()$ are both called one time.

\hspace{-2ex}(1) Procedure $getPolygon()$ completes in $O(1)$ time, and,

\hspace{-2ex}(2) Procedure $getIntersection()$ implements the polygon intersection algorithm presented in [18]. Given the inputs polygon $\mathcal{G}_1$ and $\mathcal{G}_2$, the algorithm has the time complexity of $O(|\mathcal{G}_1.E| + |\mathcal{G}_2.E|)$. By Theorem~\ref{prop-rp-intersection}, we know that $|\mathcal{G}_1.E| \le M$ and $|\mathcal{G}_2.E|\le M$, where $M$ is the number of vertices in a regular polygon. Hence, $getIntersection()$ completes in $O(M)$ time.

$M$ is a constant, thus, the process of a point needs constant time. Hence, the algorithm has a time complexity of $O(N)$.
This finishes the proof.
\end{proof}


{For space complexity, the algorithm needs $O(M)$ space.}
