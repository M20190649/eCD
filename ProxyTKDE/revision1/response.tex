\documentclass[11pt]{letter}

\usepackage{times,,xspace,amsmath,amssymb,color}
\usepackage[english]{babel}
\parindent=0cm
\parskip=0.28cm
\setlength{\textwidth}{17cm}
\setlength{\oddsidemargin}{-0.24cm}
\setlength{\evensidemargin}{-0.24cm}
\setlength{\topmargin}{0cm}
\setlength{\headheight}{0cm}
\setlength{\textheight}{24cm}
\setlength{\headsep}{0cm}
\newcommand{\eat}[1]{}
\date{}

\newcommand{\sstab}{\rule{0pt}{8pt}\\[-3.4ex]}
\newcommand{\stab}{\rule{0pt}{8pt}\\[-2.4ex]}
\newcommand{\vs}{\vspace{1ex}}
\newcommand{\svs}{\vspace{0.36ex}}
\newcommand{\kw}[1]{{\ensuremath {\mathsf{#1}}}\xspace}
\newcommand{\dist}{\kw{dist}}
\newcommand{\pred}{\kw{pred}}
\newcommand{\desc}{\kw{desc}}
\newcommand{\pSim}{\kw{Match}}
\newcommand{\at}[1]{\protect\ensuremath{\mathsf{#1}}\xspace}

\newcommand{\NP}{\kw{NP}}
\newcommand{\DAGs}{{\sc dag}s\xspace}
\newcommand{\NC}{\kw{NC}\xspace}
\newcommand{\coNP}{co\kw{NP}\xspace}
\newcommand{\PTIME}{\kw{PTIME}}
\newcommand{\PSPACE}{\kw{PSPACE}}
\newcommand{\EXPTIME}{\kw{EXPTIME}\xspace}
\newcommand{\NPSPACE}{\kw{NPSPACE}\xspace}


\newcommand{\bi}{\begin{itemize}}
\newcommand{\ei}{\end{itemize}}
\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\im}{\item}
\newenvironment{tbi}{\begin{itemize}
        \setlength{\topsep}{1.5ex}\setlength{\itemsep}{0ex}\vspace{-0.5ex}}
        {\end{itemize}\vspace{-0.5ex}}
\newenvironment{tbe}{\begin{enumerate}
        \setlength{\topsep}{0ex}\setlength{\itemsep}{-0.7ex}\vspace{-1ex}}
        {\end{itemize}\vspace{-1ex}}

\newcommand{\eps}{\prec}
\newcommand{\deps}{\prec_{D}}
\newcommand{\leps}{\prec_L}
\newcommand{\dleps}{\prec_{D}^{L}}
\newcommand{\iso}{\lhd}
\newcommand{\bieps}{\sim}
\newcommand{\embed}{\lessdot}
\newcommand{\neps}{\ntrianglelefteq}
\newcommand{\ees}{\preceq_{(e,e)}}
\newcommand{\nees}{\not\preceq_{e,e}}
\newcommand{\Reps}{S}
\newcommand{\bcp}{{\sc bcp}\xspace}
\newcommand{\ie}{\emph{i.e.,}\xspace}
\newcommand{\eg}{\emph{e.g.,}\xspace}
\newcommand{\wrt}{\emph{w.r.t.}\xspace}
\newcommand{\aka}{\emph{a.k.a.}\xspace}
\newcommand{\kwlog}{\emph{w.l.o.g.}\xspace}


\definecolor{gray}{rgb}{0.5,0.5,0.5}
\newcommand{\added}[1]{\textcolor{blue}{#1}}
\newcommand{\changed}[1]{\textcolor{red}{#1}}
\newcommand{\removed}[1]{\textcolor{gray}{#1}}

\newcommand{\ball}[1]{\hat{G}[#1]}
\newcommand{\amazon}{\kw{Amazon}}
\newcommand{\Amazon}{\kw{Amazon}}
\newcommand{\youtube}{\kw{YouTube}}
\newcommand{\YouTube}{\kw{YouTube}}


\newcommand{\match}{\kw{Match}}
\newcommand{\optmatch}{\kw{Match^+}}
\newcommand{\dismatch}{\kw{dMatch}}
\newcommand{\optdismatch}{\kw{dMatch^+}}
\newcommand{\minq}{\kw{minQ}}
\newcommand{\graphsim}{\kw{Sim}}
%\newcommand{\subiso}{\kw{SubIso}}
%\newcommand{\dissubiso}{\kw{dSubIso}}
\newcommand{\metis}{{\sc Metis}\xspace}
\newcommand{\vf}{\kw{VF2}}
\newcommand{\tale}{\kw{TALE}}
\newcommand{\mcs}{\kw{MCS}}
\newcommand{\dsim}{\kw{dSim}}
\newcommand{\dissubiso}{\kw{dVF2}}
\newcommand{\dvf}{\kw{dVF2}}

\newcommand{\stitle}[1]{\vspace{0.5ex} \noindent{\bf #1}}
\newcommand{\etitle}[1]{\vspace{1ex}\noindent{\underline{\em #1}}}






\begin{document}



\noindent
Prof. Jian Pei,\\
Editor-in-Chief,\\
IEEE Transactions on Knowledge and Data Engineering

\vspace{0.3cm}
\noindent
Dear Prof. Pei,


Attached please find a revised version of our submission to IEEE Transactions on Knowledge and Data Engineering,
{\em Proxies for Shortest Path and Distance Queries}.

%The paper has been substantially revised according to the referees'
%comments. In particular,
%
%(1) we have added discussions on the axiomatizations of $CFD^ps$ and $CIND^ps$,
%
%(2) we have added the discussions of three new references in the related work, and
%
%(3) we have also taken this opportunity to rewrite several parts of the paper to improve the presentation.



We would like to thank all the referees for their thorough reading of our
paper and for their valuable comments.

Below please find our responses to the comments by the referees.

%%%%%%%%%%%%%%%%%%%%%
\vspace{3.6ex}
\hrule
\vspace{0.6ex}

\vspace{2ex} \stitle{Response to the comments of Referee 1}.

{\em
{\bf [R1C1]} The dataset include data from road networks. But the evaluation does not include well known strong baselines for road networks (For example, Arterial Hierarchy (AH), SIGMOD'13).
It would be helpful to measure the proposed approach to a well known baseline for road network (as the major part of dataset includes data from road network).}
\svs

Thanks for your suggestion! We have added Arterial Hierarchy as one of our baselines.


\noindent
{\em
{\bf [R1C2]}  The major reason to pre-process the graph is to speed up the queries. But in some cases it seems questionable. For example, Figure 6g, query 7: The time of Arcflag and PROXY+Arcflag
is similar. But the preprocessing takes 435 seconds. So, for 10000 queries (considering the fact that presented time is an average of 10000 queries), the time taken by PROXY+Arcflag and preprocessing exceeds actual Arcflag algorithm by a huge margin.}
\svs

Thanks. Speeding up the queries is one of the major reason to use preprocess the graph. As a data reduction method, proxies can preprocess the graph and represent the nodes in the DRA, thus generates a smaller graph. Then, we can apply any existing algorithm designed for shortest path and distance queries on the smaller graph. The preprocessing yields two benefits: (1) We only need to apply the existing algorithm on the smaller graph, which requires less time and space cost to build the index. (2) Given a shortest path or distance query, we decompose the original query into two parts, inside of the DRA and outside of the DRA, which usually yields a better efficiency to answer the query.

Meanwhile, shortest path and distance queries are very common in our daily life and numerous users will consistently issue queries in the system. The number of queries is far beyond 10000 in real life.


\noindent{\em{\bf[R1C3]}As it is evaluated with TNR, one would expect that the proposed approach produces better results. It would be also nicer to explain that how this reduction of graph can be improved
to guarantee better results  by Proxy+TNR than TNR.}

\svs
Thanks. The key operation in TNR is to select Transit Nodes from the network, which has a significant impact on the performance. Different transit nodes may get a different query efficiency. In CH-based TNR, the selection of transit nodes highly relies on the graph structure. Since we use proxies to represent the nodes in DRAs and apply TNR on the reduced graph with a different graph structure, it is hard to guarantee that the transit nodes selected from the reduced graph have a better performance. This also explains that why Proxy+TNR outperforms TNR in some cases and not in others.


\noindent{\em{\bf[R1C4]}I would suggest to reorganize the experiment section. The plots are little hard to understand as they are missing labels in X and Y axis. Also the explanations are presented really far from the figures.}

\svs

\noindent{\em{\bf[R1C5]}Page 3, second column, (4)- The number 5 has an extra $\mid$ beside it.}

\svs
Fixed!

\noindent{\em{\bf[R1C6]} Figure 3 can be improved along with its caption. It is not even clear from the figure that the proxies might have edges between them.}

\svs
To avoid confusion, we removed Figure 3.

\noindent{\em{\bf[R1C7]} In proposition 7, '+' operation between paths is not defined.}

\svs
Yes, we have now replaced `+' with `/', and the latter is used when we define paths in Section 3.
We also point out in the proof of Proposition 7 that `/' is the concatenation of paths as well.

Thanks!

\noindent{\em{\bf[R1C8]} DBLP data reduction (removal of nodes with degree more than 14) needs an explanation.}

\svs
Thanks. CH is designed for the road network, which is a sparse graph and the average degree is quite low. It is very inefficient for dense graphs. The DBLP dataset is a dense co-authorship network. In our experiment, it takes more than 1 week for the preprocessing of TNR. Thus, we remove all nodes whose degrees are higher than 14, and picked the largest connected component from the remaining graph to form a new dataset.





\vspace{2.8ex}
\hrule
\vspace{0.6ex}
{\bf Response to the comments of Referee 2.}



\vs
\noindent
{\em
{\bf [R2C1]}
 Page 1, line 24, left column - comma after edge-weights required.}
\svs

Fixed!

\vs
\noindent
{\em
{\bf [R2C2]} Page 1, line 26, right column - The task *of finding*}
\svs

Fixed!

\vs
\noindent
{\em
{\bf [R2C3]} Page 2, lines 13-18, right column - why not simply write $V_s \subseteq V$, $E_s \subseteq E$ (and H is a graph so $E_s \subseteq V_s \times V_s$)?
}
\svs

Yes, we have revised accordingly. Thanks!


\vs
\noindent
{\em{\bf[R2C4]} Page 3, Sec 3.1, paragraph "Proxies" - This definition is needlessly confusing. Are the sets $A_u^1, ..., A_u^k$ defined uniquely? The definition of a proxy of a set of nodes *does not preculude* that
if u is a proxy of $A_u^1$ and $A_u^2$ then $A_u^1 \cap A_u^2 = {u}$.
Their intersection could be larger. So, if you are mandating that
$A_u^+ = A_u^1 \cup ... \cup A_u^k$ where $A_u^i$ satisfy that property,
it has to be specified so that either $A_u^i$ are defined uniquely or
they are *some* maximal collection satisfying the property. This
has not been specified at all. As such, the notion of a DRA has
not been defined properly.}
\svs

We indeed mean all the set $A_u^i$ of nodes for proxy $u$. We removed $A^i_u\cap A^j_u$ = $\{u\}$ in our revision now.
%
That is, we use ``Note that a node $u$ may be a proxy of multiple sets of nodes $A^1_u, \ldots, A^k_u$''.

Note that this has no effects on the definition of DRAs, even if we only use the maximal collection satisfying the property, as this would not change the union of these sets. Thanks for spotting this out!

\vs
\noindent
{\em{\bf[R2C5]} Why is Proposition 1 needed - is it because there can be multiple ways to define a DRA? If so, why has that not been clarified (see 4 above)?}
\svs

Sorry about the confusion, due to the use of ``$A^i_u\cap A^j_u$ = $\{u\}$ for any $i\ne j\in[1, k]$'' when we introduce $A_u^+$.
 Proposition 1 is to say that there is a unique DRA for a proxy, by the definition of proxies and DRAs.


\vs
\noindent
{\em{\bf[R2C6]} Again, in defining routing proxies - conditions 1, 2, 3 needlessly
complicate things. One simply looks at $G \setminus u$, and looks at the
new connected components created. The regions for which u is proxy
is a union of such CCs whose total size is at most c sqrt\{n\}. This
is a more intuitive way of introducing it.
*** I am assuming an intuitive notion of DRA in what follows ***
}
\svs

We agree that this is a more  way of introducing proxies.  We have now added this intuitive explanation in the definition. Thanks for the nice suggestions!



\vs
\noindent
{\em{\bf[R2C7]} Why is Proposition 4 required?}
\svs

We have moved Proposition 4 (Proposition 1 in the revision) to Section 3.1. Thanks!

\vs
\noindent
{\em{\bf[R2C8]} The lemmas Proposition 5, Corollary 6, Proposition 7, 8 probably
are relevant to the next section 3.3 : it would be better to tie them
in there somehow. The other two (9, 10) are relevant to computing DRA
and should be in that section - the general properties of Proxies, DRA
looks out of place and unmotivated. Why should the reader be
interested
in such general properties without the correct motivation?
}

\svs
Yes, we have moved Propositions 9\&10 to Section 4. Thanks for the suggestion!

\vs
\noindent
{\em{\bf[R2C9]}Page 4, line 30, right column - contradicts our assumption - "to" not necessary. Same error in line 49.}
\svs

Fixed! Thanks!

\vs
\noindent
{\em{\bf[R2C10]}What is the worst case space complexity of storing the entire routing information for all the DRA's. Why is this analysis not done?}
\svs

In the worst case, the space complexity of storing the entire routing information for all the DRA's is $O(d)$, where $d$ is the total number of nodes in all DRAs. We have now discussed this in the remarks at the end of Section 3.3. Thanks!



\vs
\noindent
{\em{\bf[R2C11]} Proposition 12 - proof not written clearly.}

\svs
We have rewritten the proof of Proposition 12. Thanks!

\vs
\noindent
{\em{\bf[R2C12]} Page 6, algorithm computeDRA's, line 13, and 15 - mark X' as ... : X' is a set of BCC. You want the union of all vertices in X'?}
\svs

Yes, it is. To clarify this, we have also changed the sentence to ``Let the DRA $A^+_{v'}$ of proxy $v'$ := $X'$''.


\vs
\noindent
{\em{\bf[R2C13]} Sorry - but the proof of correctness of algorithm as claimed on line 33-35 on page 6, right column is not obvious and/or short. It needs to be written.}

\svs
We have refined the correctness proof of algorithm computeDRA.


\vs
\noindent
{\em{\bf[R2C14]} All the experiments - how much space usage increased due to storage of extra information. Where is that presented?}

\svs
Thanks. We presented the space usage in Table 2 in our original version. In the amended version, we have reorganized Section 6 and emphasized this in Section XXX.

\vs
\noindent
{\em{\bf[R2C15]} Several errors in the bio's of authors.
second author - 20012 as opposed to 2012
fourth author - 2015-2013}

\svs
Fixed!










\vspace{2.8ex}
\hrule
\vspace{0.6ex}
{\bf Response to the comments of Referee 3.}


\vs
\noindent
{\em{\bf[R3C1]}
Experimental results show some reduction in query time, but much more improvements are needed to the paper in terms of presentation, related work and experiments before it can be accepted.}
\svs

Thanks. In our amended version, we have XXXXXX.



\vs
\noindent
{\em{\bf[R3C2]}  However, it was very hard to understand the details since the paper was not easy to read. The presentation should be lightened with a running example and more intuition.  The current draft makes for a tough read since the text often goes from one lemma to another. The mechanics of the paper was hard to understand without a running example.  For instance Graph G2 could make a good running example to describe how proxies are identified, how computeDRAs algorithm works, and how routing is performed etc.}
\svs

We have reorganized our paper, by (1) moving detailed proofs to the appendix, (2) adjust the section 3 and the experimental section, (3) added a related work section, and (4) added a running example for section 3.3. We indeed have a running example, and we further added a running example for query answering with routing proxies in Section 3.3.


\vs
\noindent
{\em{\bf[R3C3]}There are plenty of prior works that deal with decomposing a network by advantage of the commonality in the shortest paths. In fact all these methods use the same strategy: simplify the topology of the graph representation to make shortest path computing faster. In particular, how does this approach compare with other competing methods? Clearly all these methods (including the proposed one) perform a trade-off between precomputation effort and run-time performance. For instance, [25] does a better job of balancing this trade-off than [27] just to pick two examples. How does the proposed method fit into this spectrum of choices? Either a theoretical exercise or some sort of an experimental evaluation is needed here.}
\svs

\vs
\noindent
{\em{\bf[R3C4]}This leads to the major problem with the paper, which is a missing related work section.  One needs a serious treatment of related literature to appreciate the contributions here. This is especially true in this case where there is quite a bit of similar prior work. I would like to see methods compared and contrasted in terms of (a) technique used for precomputing (b) technique needed for computing queries.}
\svs

Thanks. In our revised version, we have added a related work section.


\vs\noindent{\em{\bf[R3C5]}The authors mention that "hierarchical approaches, graph partitioning approaches" and "path oracles" as "complementary methods" in the sense that the proposed method can be used as a pre-processing steps before the competing methods can be applied. I think this claim is a stretch since these methods rely on the same principles and applying one could very well preclude the other from being applied. For instance, [25] uses network contractions, [27] decomposes graphs into "spatially coherent" pairs.  Both these methods make certain assumptions about the topology in the graph input. In particular, this claim could be substantiated for one of the prior methods (e.g, Highway Hierarchies) by showing comparison results of running on original graph representation and using one after applying the graph reduction technique from this paper. I wonder if Proxy + TNR does something similar I think but it looks worse than Proxy alone for many cases so was not sure.
}
\svs

Thanks. We would like to politely clarify that by saying "complementary methods", we are saying that our proxies can be combined with these existing methods to achieve a better efficiency. This misunderstanding could be because we did not present the idea of combining proxies with existing methods clearly. We have now discuss the idea in Section XXX in the amended version.

To elaborate further, our method is a data reduction method: by using proxies to represent all nodes in the DRAs, we can ignore all nodes in the DRAs and get a reduced graph. Then, any existing approaches can be applied on this reduced graph. Given a query, we decompose it into two parts: inside of the reduced graph and inside of the DRAs. By using the existing approach to answer the decomposed queries separately, we can combine the result to produce the final result.



\vs\noindent{\em{\bf[R3C6]}The experimental results need quite a bit of more thought to make it useful. At this point it is just a permutation combination of datasets, few queries and a few methods.  I am not sure if there is much to glean from so many different graphs when they all seem to covey the same message. Can you instead show comparison results with other methods? One way is to report results on some standard datasets from http://www.dis.uniroma1.it/challenge9/download.shtml. Likely all the competing works have results for these datasets, which can be used for comparison without redoing them. Can you use experimental results to highlight some property of your algorithm?}
\svs

Thanks. In the original version, we have already done experiment on the dataset suggested by the reviewer.

In our amended version, we have added a new baseline algorithm namely Arterial Hierarchy.



\vspace{3.6ex}
\hrule
\vspace{3.6ex}
\closing{Your sincerely,}

\vspace{-8ex}
Shuai Ma, Kaiyu Feng, Jianxin Li, Haixun Wang, Gao Cong, and Jinpeng Huai
\end{document}
