\section{Experimental Study}
\label{sec-expt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%

%We next present an experimental study to show how proxies speed up shortest  path and distance queries.
%Using real-life networks, we conducted three
%sets of experiments to evaluate:
%(1) the performance of proxies,
%(2) the efficiency of (bidirectional) Dijkstra~\cite{LubyR89}, \arcflag \cite{MohringSSWW05}, \tnr \cite{arz2013transit} and their counterparts with proxies (Proxy+Dijkstra, Proxy+\arcflag, Proxy+\tnr) with respect to  graph queries, and (3) the efficiency of these algorithms with respect to graph sizes.
Using real-life road networks and social graphs, we next conduct an extensive experimental study to evaluate: (1) the performance of computing routing proxies, and (2) how routing proxies speed up shortest  path and distance queries, by comparing the efficiency of (bidirectional) Dijkstra~\cite{LubyR89}, \arcflag \cite{MohringSSWW05}, \tnr \cite{arz2013transit}, \ah \cite{zhu2013shortest} with their counterparts using proxies (Proxy+Dijkstra, Proxy+\arcflag, Proxy+\tnr, Proxy+\ah) with respect to graph queries and graph sizes.

\eat{%%%%%%%%%%%%EAT
\begin{table}[t!]
\label{tab-datasets}
\caption{Real-world graphs}
\vspace{-1ex}
\begin{center}
%\begin{small}
\begin{tabular}{|c|c|r|r|}
\hline
Name                            &  Regions               & \# of Nodes  &  \# of Edges \\
\hline\hline
DBLP14    &   A subgraph of DBLP                 & 141,359  &   246,462 \\ \hline
DBLP    & DBLP & 317,080 & 1,049,866 \\ \hline
CO      &  Colorado              & 435,666      &  521,200  \\ \hline
FL      &  Florida               & 1,070,376    &  1,343,951  \\ \hline
CA      &  California \& Nevada   & 1,890,815   &  2,315,222  \\ \hline
E-US    &  Eastern US            & 3,598,623    &  4,354,029 \\ \hline
W-US    &  Western US            & 6,262,104    &  7,559,642  \\ \hline
C-US    &  Central US            & 14,081,816   &  16,933,413 \\ \hline
US      &  Entire US             & 23,947,347   &  28,854,312  \\ \hline
\end{tabular}
%\end{small}
\end{center}
\end{table}
}%%%EAT%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{table*}[t!]
\label{tab-exp1-proxies-dras}
\begin{center}
\begin{scriptsize}
\caption{Effectiveness of proxies and \dras}
\vspace{-1ex}
\begin{tabular}{|c||c|c|c||r|r|r|r|r|r|}
\hline
  \multicolumn{4}{|c||}{\bf Datasets} & \multicolumn{6}{c|}{\bf Evaluation of Computing Routing Proxies}\\
  \hline
                          &  &  &  &  \multicolumn{1}{c|}{\bf Proxies}   &  \multicolumn{1}{c|}{\bf Nodes in \dras}  & \multicolumn{1}{c|}{\bf Extra space} & \multicolumn{1}{c|}{\bf Space of $G$} & \multicolumn{1}{c|}{\bf Space of $G'$} & \multicolumn{1}{c|}{\bf Time}\\
                          
  \raisebox{1.5ex}[0pt]{\bf Graphs} &   \raisebox{1.5ex}[0pt]{\bf Regions} &   \raisebox{1.5ex}[0pt]{\bf \# of Nodes} &   \raisebox{1.5ex}[0pt]{\bf \# of Edges} & \multicolumn{1}{c|}{\bf (\#, \%)}  &  \multicolumn{1}{c|}{\bf (\#, \%)}  & \multicolumn{1}{c|}{\bf (MB)} & \multicolumn{1}{c|}{\bf (MB)} & \multicolumn{1}{c|}{\bf (MB)} & \multicolumn{1}{c|}{\bf (Sec.)}\\
\hline\hline
DBLP14      &   Subgraph of DBLP          & 141,359  &   246,462     &  (14, 090, 9.8)         & (102,085, 72.2)  & 1.56 & 4.30 & 1.36 &  1.5 \\ \hline
DBLP        & DBLP                        & 317,080 & 1,049,866     & (31,475 , 9.9)             & (105,671 , 33.3) & 1.61 & 17.22 & 14.29  & 5.7 \\ \hline
CO          &  Colorado              & 435,666      &  521,200       &  (56,277, 12.9)         & (156,329, 35.9)  & 2.38  & 9.61 & 6.64 & 3.47  \\ \hline
FL          &  Florida               & 1,070,376    &  1,343,951      &  (140,382, 13.1)        & (378,804, 35.4)  & 5.78  & 24.59 & 17.12 &  9.9 \\ \hline
CA          &  California \& Nevada   & 1,890,815   &  2,315,222      &  (273,191, 14.4)        & (623,811, 33.0)  & 9.52  & 42.55 & 30.66 & 21.1 \\ \hline
E-US        &  Eastern US            & 3,598,623    &  4,354,029    &  (546,481, 15.2)        & (1,228,876, 34.1)& 18.75  & 80.17 & 56.48 &  52.5  \\ \hline
W-US        &  Western US            & 6,262,104    &  7,559,642      &  (869,907, 13.9)        & (2,116,382, 33.8)& 32.29  & 139.23 & 98.68 &  111.9 \\ \hline
C-US        &  Central US            & 14,081,816   &  16,933,413    &  (2,034,358, 14.4)      & (4,583,413, 32.5)& 69.94 & 312.09 & 225.28 & 435.8 \\ \hline
US          &  Entire US             & 23,947,347   &  28,854,312      &  (3,452,222, 14.4)      & (7,927,453, 33.1)& 120.96 & 531.63 & 380.59 &  1,925.4 \\ \hline
\end{tabular}
\end{scriptsize}
\end{center}
\vspace{-2ex}
\end{table*}
%%%%%%%%%%%%%%%%%%%





\subsection{Experimental Settings}
We first introduce the settings of our experimental study.







\stitle{Real-life graphs}.
We use two types of datasets, and the details of all datasets are reported in Table~1.



\sstab (1) The first type of datasets is {\em co-authorship networks}. We extracted co-authorship graphs from DLBP~\cite{snapnets}, where each node in the graph represents an author and two authors are connected if they have published papers together. The edge weight is computed by a revised Adamic/Adar similarity function: $w(u,v) = \frac{1}{\sum_{z\in {\Gamma(u)\cap \Gamma(v) \cup \{u,v\}}}\frac{1}{\log{|\Gamma(z)|}}}$, where $\Gamma(u)$ and $\Gamma(v)$ are the sets of neighbors of nodes $u$ and $v$, respectively. The weight of the edge $(u,v)$ represents the closeness between $u$ and $v$ and a smaller weight means the two authors are closer. \tnr is designed for road networks and it is very inefficient for \tnr to preprocess dense graphs such as DBLP (it took more than 1 week to finish the preprocessing). To guarantee that we can evaluate the improvement of \tnr with proxies on general graphs, we remove all nodes whose degrees are higher than 14, and choose the largest connected component in the remaining graph, referred to as \dblpone.


\sstab (2) The second type of datasets is {\em road networks}. We chose seven standard road network datasets of various sizes from the Ninth DIMACS
Implementation Challenge~\cite{dimacs-datasets} (available at {\url{http://www.dis.uniroma1.it/challenge9/download.shtml}}). Each road network is released as an undirected graph representing a part of the road network in the United States, where each edge weight is the distance (an integer) required to travel between the two endpoints of the edge.


\stitle{Shortest  path and distance queries}. Our queries were generated as follows.
(1) On each road  or co-authorship network, we first randomly choose a node $u$, and run a Dijikstra algorithm from $u$ to find the node $s$ that is farthest from $u$. Then we run a Dijkstra again from $s$ to find the node $t$ that is farthest from $s$. Let $\ell$ be the distance $\dist(s,t)$ from $s$ to $t$.
(2) We then randomly chose ten thousand node pairs from
the road network to compose $Q_i (i \in [1,7])$, such that the grid
distance of all node pairs in $Q_i$ is in $[2^{i-9}\cdot\ell, 2^{i-8}\cdot\ell)$.
For each query set $Q_i$ $(i\in [1,7])$, we report the average running time of 10,000 queries in the set.

%On each road network, we generated eight sets $Q_1$, $Q_2$, $\dots$ , $Q_{7}$ of
%queries. (1) We first imposed a $256 \times 256$ grid on the
%road network and computed the side length $\ell$ of each grid cell.
%(2) We then randomly chose ten thousand node pairs from
%the road network to compose $Q_i (i \in [1, 7])$, such that the grid
%distance of all node pairs in $Q_i$ is in $[2^{i-1}\cdot\ell, 2^i\cdot\ell)$. Note
%that the grid distance of two nodes $u, v$ in a query set is the distance of the cells into which $u$ and $v$ fall, respectively.
%Moreover, the grid distance of any node pair in $Q_i$ is
%larger than the grid distance of all node pairs in $Q_{i-1}$.
%For each query set $Q_i$ $(i \in [1, 7])$, we report the average running time of 10,000 queries in the set.

\etitle{Algorithms.} We implemented algorithms bidirectional-Dijkstra~\cite{LubyR89}, \arcflag~\cite{MohringSSWW05}, \tnr~\cite{arz2013transit} and \ah \cite{zhu2013shortest}.

For \arcflag, it first needs to partition graphs to pre-compute information on whether an arc is useful for a shortest path search. Any possible partition methods~\cite{kl70,Karypis98,YangYZK12, delling2011graph} can be used here. Since we have both road networks and co-authorship networks, we adopted the latest version 5.0.2 of \metis~\cite{metis}, implemented with ANSI C, because it is open source and performs quite well in practice.

For \tnr, since we do not have coordinates information in the co-authorship network, we implemented the CH-based \tnr~\cite{arz2013transit} that does not require the geometry information.

We obtained the C++ implementation of \ah from \cite{zhu2013shortest} and adopted its default settings.



\etitle{Implementations.} All algorithms were implemented with C++, and
all experiments were run on a PC with an Intel Xeon(R) X5650 CPU@2.67GHz
and 24GB of memory.






%\subsection{Experimental Results}
%We next present our findings. In all experiments, we tested the datasets in Table~1, and fixed the constant $c = 2$ for computing proxies on all graphs.
%The preprocessing of \arcflag was slow, and it spent over four days on C-US. Hence, we did not test the largest dataset US for \arcflag.
\subsection{Performance of Computing Routing Proxies}
Using the datasets in Table~1, we first conduct experiments to evaluate the performance of computing proxies, \ie\ how many nodes can be represented by proxies, how much extra space we need to store the routing information for the proxies, and how much time we need to find all proxies. More specifically, we evaluate (1) the number of non-trivial proxies, (2) the number and percentage of the nodes represented by the proxies (excluding the proxies themselves from \dras), (3) the extra space cost of using proxies, (4) the space overhead of storing the original graph $G$, (5) the space overhead of storing the reduced graph $G'$, and (6) the efficiency of algorithm $\compDRAs$ for computing proxies and their \dras. We fixed the constant $c = 2$ for computing proxies on all graphs. When computing the space overhead for the original graphs and the reduced graphs, we assume that all graphs are stored as adjacency lists. The experimental results are reported in Table~1.

%Note that to speed up shortest  path and distance queries, for each node represented by a proxy, we need to store (1) the distance between the node and its proxy, and (2) the shortest path from the node to its proxy. Distances are stored as 4-byte integers and it takes $4 \cdot |V_{\dras}|$ bytes to store all the distances, where $V_{\dras}$ is the set of nodes in all \dras. All the shortest paths between the nodes in a \dra and its proxy form a tree whose root is the proxy. Each node is also represented as a 4-byte integer. So it takes $ 4 \cdot (|V_{proxy}|+ |V_{\dras}|) $ bytes to maintain all the trees, where $V_{proxy}$ is the set of proxies. So the extra space cost of using proxies is $4 \cdot |V_{proxy}| + 8 \cdot |V_{\dras}|$ bytes. The results are reported in Table~2.
\stitle{1. Effectiveness evaluation}.
In the \dblp graph, about $1/10$ nodes are non-trivial proxies, and about $1/3$ nodes are captured by proxies in the graph, which means basically the reduced graph is only about $2/3$ of the input graph. In the \dblpone graph, about $1/10$ nodes are non-trivial proxies, and about $2/3$ nodes are captured by the \dras of proxies in the graph, which means basically the reduced graph is only about $1/3$ of the original input graph.

In all the road graphs,  about $1/7$ nodes are non-trivial proxies, and about $1/3$ nodes are captured by the \dras of these proxies, which means basically the reduced graph is only about $2/3$ of the original input graph.
 
 Moreover, although the size restriction is $\le 2\cdot\lfloor\sqrt{|V|}\rfloor$, \dras are typically small such that each proxy represents 2 or 3 other nodes on average.


\stitle{2. Efficiency evaluation}.
In the \dblp graph, proxies can be found in about 6 seconds. In the \dblpone graph, it only takes 1.5 seconds to find all \dras with their proxies.

In all road networks, proxies can be found efficiently. Algorithm $\compDRAs$ also scales well, and it can be done in less than half an hour for the largest graph US with $2.4$ $\times$ $10^7$ nodes and $5.7$ $\times$ $10^7$ edges.

\stitle{3. Space evaluation}.
To support shortest distance queries, for each node in a \dra, we store its proxy $u$, its distance to $u$ and the component of $A^{+}_u$ to which it belongs, and, moreover, to support shortest path queries, we further keep the shortest paths from proxy $u$ to all nodes in the \dra. Assume that distances are stored as a 4-byte integer. Each node is represented as a 4-byte integer. Then the extra space that we need for shortest path and distance queries is $16\cdot |V_{dra}|$, where $V_{dra}$ is the set of nodes in all \dras.

In the \dblp and \dblpone graphs, it only takes about 1.6 MB extra space to store the routing information for all proxies, since there are similar number of nodes in the \dras of both datasets. Observe that by using proxies to represent all nodes in \dras, the reduced graph  has a smaller size than the original graph, especially for the \dblpone graph. In \dblpone graph, 72.2\% of its nodes are captured by proxies, which leads to a much smaller reduced graph.

In all road networks, it incurs small space overhead to store the routing information for proxies. Only about 100 MB extra space is taken for the largest graph US. The use of proxies also results in a smaller reduced graph. We can see that the size of the reduced graph is about 70\% of the original graph on average.


\stitle{Summary.}
From these test, we can find that using proxies is a light-weight optimization technique. It runs efficiently and scales well to large networks, and it incurs appropriate space overhead. These properties benefit existing shortest  path and distance algorithms, such as (bidirectional) Dijkstra, \arcflag , \tnr and \ah, to be seen immediately.

\subsection{Benefits of Using Routing Proxies}
Our proxies can be used as a preprocessing step before we apply other existing approaches, such as Dijkstra, \arcflag, \tnr or \ah etc. In this subsection, we conduct experiments to show the comparison results of running an existing approach and running the combination of existing approach and proxies.



In this set of experiments, we tested the datasets in Table~1. Due to the space limitation, we only reports the results on \dblpone, CA, E-US, and C-US. A more detailed results can be found in the supplementary document. We fixed the constant $c = 2$ for computing proxies on all graphs. Note that \ah requires coordinates information to answer shortest path or distance queries, which is not available in \dblpone. Thus, we only reports results on CA, E-US, and C-US for \ah and its counterparts.
%The preprocessing of \arcflag was slow, and it spent over 4 days on C-US. Hence, we did not test the largest road network dataset US for \arcflag.
%\tnr invokes Contract Hierarchies (\ch) for preprocessing and \ch is very inefficient on dense graphs. Unfortunately \dblp is a very dense graph and it took more than 7 days for \ch to finish preprocessing on \dblp. Thus we tested \dblpone, instead of \dblp, for the performance of shortest path and distance queries. The CH-based \tnr whose space cost was very high, and consequently, and we could not run either \tnr or Proxy+\tnr on the largest road network dataset US, as both of them ran out of memory. Hence, we did not test the largest graph for \tnr as well. However, on the second largest road network dataset C-US, Proxy+\tnr can while \tnr cannot. We report this to show that proxies serve as a data reduction technique and benefit existing methods in terms of space cost as well.

\stitle{Effectiveness  \wrt graph queries}.
%In the second set of experiments, we justified that the \gdp problem could be solved well by \metis, originally for traditional graph partitioning problems. Using the shrink graphs generated at Exp-1, we evaluated the effectiveness and  efficiency of \metis. To ensure the query efficiency of \disland, each fragment has at most $c \cdot \lfloor\sqrt{|V|}\rfloor$ number of nodes. We used the multilevel bisection method of \metis with the balance factor fixed to 1.003. The results are reported in Table~4.
%
In this set of experiments, we evaluated the efficiency of shortest path and distance queries with respect to the graph queries. For the \arcflag and Proxy+\arcflag methods, the graph and the reduced graph are partitioned into fragments such that each fragment has at most $2\cdot \lfloor\sqrt{|V|}\rfloor$ nodes in order to add labels to edges. We used \metis  to partition graphs with the balance factor fixed to 1.003. For the \tnr and Proxy+\tnr methods, we always select 10,000 transit nodes, as suggested in \cite{arz2013transit}. Note that the space cost of the CH-based \tnr is very high. Consequently, we could not run \tnr on dataset C-US as it ran out of memory. However, we can successfully run Proxy+\tnr on C-US. We report this to show that proxies serve as a data reduction technique and benefit existing methods in terms of space cost as well. \tnr invokes Contract Hierarchies (\ch) to preprocess the graph and \ch runs very slow on \dblp dataset (it takes more than 7 days to run \ch on \dblp). Thus we report the results on \dblpone and all the road networks. The results of distance queries and path queries are reported in Figures~\ref{fig:performance_dist_queries_dj}, ~\ref{fig:performance_path_queries_dj} (comparison between Dijkstra and Proxy+Dijkstra), Figures~\ref{fig:performance_dist_queries_af}, ~\ref{fig:performance_path_queries_af} (comparison between \arcflag and Proxy+\arcflag), Figures~\ref{fig:performance_dist_queries_tnr}, ~\ref{fig:performance_path_queries_tnr} (comparison between \tnr and Proxy+\tnr), Figures~\ref{fig:performance_dist_queries_ah}, ~\ref{fig:performance_path_queries_ah} (comparison between \ah and Proxy+\ah), respectively.


\begin{figure*}[t!]
\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize DBLP14}]{\label{fig-dist-dj-varyQ-dblp}
\includegraphics[scale=0.45]{./exp/query_dblp_dist_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize CA}]{\label{fig-dist-dj-varyQ-CAL}
\includegraphics[scale=0.45]{./exp/query_cal_dist_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize E-US}]{\label{fig-dist-dj-varyQ-E-US}
\includegraphics[scale=0.45]{./exp/query_eus_dist_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize C-US}]{\label{fig-dist-dj-varyQ-C-US}
\includegraphics[scale=0.45]{./exp/query_cus_dist_dj.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph queries  for shortest distances: Dijkstra vs. Proxy+Dijkstra}
\label{fig:performance_dist_queries_dj}
\vspace{-1ex}
\end{figure*}

\begin{figure*}[t!]
%\vspace{-2ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize DBLP14}]{\label{fig-dist-af-varyQ-dblp}
\includegraphics[scale=0.45]{./exp/query_dblp_dist_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize CA}]{\label{fig-dist-af-varyQ-CAL}
\includegraphics[scale=0.45]{./exp/query_cal_dist_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize E-US}]{\label{fig-dist-af-varyQ-E-US}
\includegraphics[scale=0.45]{./exp/query_eus_dist_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize C-US}]{\label{fig-dist-af-varyQ-C-US}
\includegraphics[scale=0.45]{./exp/query_cus_dist_af.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph queries  for shortest distances: \arcflag vs. Proxy+\arcflag}
\label{fig:performance_dist_queries_af}
\vspace{-1ex}
\end{figure*}


\begin{figure*}[t!]
%\vspace{-2ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize DBLP14}]{\label{fig-dist-tnr-varyQ-dblp}
\includegraphics[scale=0.45]{./exp/query_dblp_dist_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize CA}]{\label{fig-dist-tnr-varyQ-CAL}
\includegraphics[scale=0.45]{./exp/query_cal_dist_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize E-US}]{\label{fig-dist-tnr-varyQ-E-US}
\includegraphics[scale=0.45]{./exp/query_eus_dist_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize C-US}]{\label{fig-dist-tnr-varyQ-ME-C-US}
\includegraphics[scale=0.45]{./exp/query_cus_dist_tnr.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph queries  for shortest distances: \tnr and Proxy+\tnr}
\label{fig:performance_dist_queries_tnr}
\vspace{-1ex}
\end{figure*}

\begin{figure*}[t!]
%\vspace{-2ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize CA}]{\label{fig-dist-ah-varyQ-CAL}
\includegraphics[scale=0.45]{./exp/query_cal_dist_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize E-US}]{\label{fig-dist-ah-varyQ-E-US}
\includegraphics[scale=0.45]{./exp/query_eus_dist_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize C-US}]{\label{fig-dist-ah-varyQ-ME-C-US}
\includegraphics[scale=0.45]{./exp/query_cus_dist_ah.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph queries  for shortest distances: \ah vs. Proxy+\ah}
\hrule
\label{fig:performance_dist_queries_ah}
\vspace{-1ex}
\end{figure*}


In the co-authorship network \dblpone, the results tell us that with the help of proxies, Proxy+Dijkstra, Proxy+\arcflag and Proxy+\tnr can all achieve a better performance than their counterparts Dijkstra, \arcflag and \tnr without using proxies. On average, the time cost of Proxy+\arcflag, Proxy+Dijkstra and Proxy+\tnr is about 96\%, 51\% and 51\% of their counterparts without proxies for distance queries, and 98\%, 49\% and 76\% of their counterparts without proxies for shortest path queries, respectively. More specifically, we can see that (1) proxies have a better speed-up effect on bidirectional Dijkstra and \tnr than \arcflag, (2) for \arcflag, proxies have a better speed-up effect when the two query nodes are far from each other, which is different from the observation in road networks. To explain the second observation, we need to notice that about 2/3 nodes are captured by proxies in \dblpone. Thus two close nodes are more likely to fall in the \dras. Since there are no speed-up techniques used inside a \dra, so the search space saved by proxies is less than using \arcflag alone.

In the road networks, the results tell us that with the help of proxies, Proxy+Dijkstra and Proxy+\arcflag can achieve a better performance than their counterparts without proxies. On average, the time cost of Proxy+\arcflag, Proxy+Dijkstra and Proxy+\ah is about 80\%, 68\% and 99\% of their counterparts without proxies for distance queries, and 82\%, 67\% and 99\% of their counterparts without proxies for shortest path queries, respectively. More specifically, we can see that (1) proxies have a better speed-up effect on bidirectional Dijkstra than \arcflag, (2) for \arcflag, proxies have a better speed-up effect when the two query nodes are close to each other, (3) different from \arcflag, proxy+Dijkstra has a better performance when the query nodes are far from each other, and (4) though \ah is one of the state-of-art method for shortest path and distance queries, proxies still improves the its efficiency about 1\%. To explain these observations, we need to think how much search space is saved by proxies. Since \arcflag has already used flags on edges to reduce the search space, the proportion of search space saved by proxies is smaller than bidirectional Dijkstra. That explains why proxies have a better speed-up effect on bidirectional Dijkstra. For \arcflag, two close nodes are more likely to fall into the same partition. In this case, the effect of flags on edges are less useful and the search space saved by proxies takes a large proportion, which explains the second observation. For bidirectional Dijkstra, proxies can save more search space when the query nodes are far from each other. As a state-of-art approach for shortest path and distance queries, the search space of \ah is much smaller than Dijkstra and \arcflag. Thus although the speed-up effect on \ah is not very impressive, \ah still benefits from proxies in terms of efficiency.

Proxy+\tnr achieves a comparable performance to its counterparts without proxies. This is because in \tnr, a heuristic method is used to generate the node order, based on the structure of the graph. And the node order can affect the performance of \tnr. Since we reduce the input graph by using proxies, the reduced graph has a different topology structure. Thus a different node order will be generated. So it is hard to guarantee that Proxy+\tnr outperforms \tnr. We should also notice that \tnr cannot run on C-US while Proxy+\tnr can. To explain this, we first recall that in \tnr, we have to store the access nodes and distances for each node. For the original input of C-US, there are too many nodes and it runs out of memory. By using proxies, about 1/3 nodes are captured by proxies and we only need to run \tnr on 2/3 of the input graph, which is more practical.

We next use Proxy+\ah and \ah to further study how existing solutions benefit from proxies in terms of space cost. We run Proxy+\ah and its counterparts without proxies and report the (1) the size of the index generated by \ah on the original graph, and (2) the sum of the size of the index generated by \ah on the reduced graph and the extra space it takes to store routing information for proxies. The results are reported in Table~\ref{tab-spacecost}. We can observe that, in terms of space cost, Proxy+\ah is about 82\% of its counterparts without proxies. To explain this observation, we can think how proxies are combined with \ah. We first use proxies to represent nodes in \dras. Then \ah is applied on the reduced graph. Thus, the size of the index for the reduced graph is much smaller than for the original graph. In addition, as we have stated in Section~\ref{sec-query}, we only need to maintain some simple information for the proxies to support shortest path and distance queries. Putting these together, Proxy+\ah has a smaller space cost than \ah. This experiment also shows that most existing solution benefit from proxies, in terms of both preprocessing phase and query answering phase.

\begin{table}[t!]
\caption{Index sizes of \ah and Proxy+\ah}
\label{tab-spacecost}
\vspace{-1ex}
\begin{center}
%\begin{small}
\begin{tabular}{|c|c|c|}
\hline
& \multicolumn{2}{|c|}{Index Size} \\
\cline{2-3}
Dataset                            &  Proxy+\ah              & \ah  \\
\hline\hline
CO & 58.1 MB & 72.2 MB \\ \hline
FL & 150.9 MB & 187.3 MB \\ \hline
CA & 277.9 MB & 338.1 MB \\ \hline
E-US & 525.5 MB & 642.0 MB \\ \hline
W-US & 889.6 MB & 1092.3 MB \\ \hline
C-US & 2082.3 MB & 2512.3 MB \\ \hline
US & 3512.7 MB & 4266.9 MB \\ \hline
\end{tabular}
%\end{small}
\end{center}
\end{table}

\begin{figure*}[t!]
\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize DBLP14}]{\label{fig-path-dj-varyQ-dblp}
\includegraphics[scale=0.45]{./exp/query_dblp_path_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize CA}]{\label{fig-path-dj-varyQ-CAL}
\includegraphics[scale=0.45]{./exp/query_cal_path_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize E-US}]{\label{fig-path-dj-varyQ-E-US}
\includegraphics[scale=0.45]{./exp/query_eus_path_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize C-US}]{\label{fig-path-dj-varyQ-C-US}
\includegraphics[scale=0.45]{./exp/query_cus_path_dj.eps}}
%\hfill
%\vspace{-1ex}
\end{center}
\vspace{1ex}
\caption{Varying graph queries for shortest paths: Dijkstra vs. Proxy+Dijkstra}
\label{fig:performance_path_queries_dj}
\vspace{-1ex}
\end{figure*}

\begin{figure*}[t!]
%\vspace{2ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize DBLP14}]{\label{fig-path-af-varyQ-dblp}
\includegraphics[scale=0.45]{./exp/query_dblp_path_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize CA}]{\label{fig-path-af-varyQ-CAL}
\includegraphics[scale=0.45]{./exp/query_cal_path_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize E-US}]{\label{fig-path-af-varyQ-E-US}
\includegraphics[scale=0.45]{./exp/query_eus_path_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize C-US}]{\label{fig-path-af-varyQ-C-US}
\includegraphics[scale=0.45]{./exp/query_cus_path_af.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph queries for shortest paths: \arcflag and Proxy+\arcflag}
\label{fig:performance_path_queries_af}
\vspace{-1ex}
\end{figure*}

\begin{figure*}[t!]
%\vspace{2ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize DBLP14}]{\label{fig-path-tnr-varyQ-dblp}
\includegraphics[scale=0.45]{./exp/query_dblp_path_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize CA}]{\label{fig-path-tnr-varyQ-CAL}
\includegraphics[scale=0.45]{./exp/query_cal_path_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize E-US}]{\label{fig-path-tnr-varyQ-E-US}
\includegraphics[scale=0.45]{./exp/query_eus_path_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize C-US}]{\label{fig-path-tnr-varyQ-ME-C-US}
\includegraphics[scale=0.45]{./exp/query_cus_path_tnr.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph queries  for shortest paths: \tnr and Proxy+\tnr}
\label{fig:performance_path_queries_tnr}
\vspace{-1ex}
\end{figure*}

\begin{figure*}[t!]
%\vspace{2ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize CA}]{\label{fig-path-ah-varyQ-CAL}
\includegraphics[scale=0.45]{./exp/query_cal_path_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize E-US}]{\label{fig-path-ah-varyQ-E-US}
\includegraphics[scale=0.45]{./exp/query_eus_path_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize C-US}]{\label{fig-path-ah-varyQ-ME-C-US}
\includegraphics[scale=0.45]{./exp/query_cus_path_ah.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph queries for shortest paths: \ah and Proxy+\ah}
\label{fig:performance_path_queries_ah}
\hrule
\vspace{-1ex}
\end{figure*}
















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



 %The approaches are speeded up by reducing the search space. because , especially when the two nodes in the query are close to each other. For example for Q1 in dataset CO, the time cost of \arcflag is 1.4 times of the time cost of Proxy+\arcflag. This is because when two nodes are close, their proxies are more likely to be close to each other and computing the shortest path between the two proxies has a smaller share in the total time cost. %For the \ch and its counterparts with proxies, though the time cost of the two methods are very similar, \ch with proxies is slightly faster than the original \ch.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\stitle{Effectiveness \wrt graph sizes}.

Since \dblpone is a single dataset, we only compare the efficiency of a group of shortest path and distance queries $\{Q_1, Q_3, Q_5, Q_7\}$  on road graphs using the same settings.
The results of distance and path queries are reported in
Figures~\ref{fig:performance_dist_graph_size_dj}, ~\ref{fig:performance_path_graph_size_dj} (comparison between Dijkstra and Proxy+Dijkstra), Figures~\ref{fig:performance_dist_graph_size_af}, ~\ref{fig:performance_path_queries_af} (comparison between \arcflag and Proxy+\arcflag), Figures~\ref{fig:performance_dist_graph_size_tnr}, ~\ref{fig:performance_path_graph_size_tnr} (comparison between \tnr and Proxy+\tnr), Figures~\ref{fig:performance_dist_graph_size_ah}, ~\ref{fig:performance_path_graph_size_ah} (comparison between \ah and Proxy+\ah), respectively.


%In the third set of experiments, we evaluated the efficiency of shortest path and distance queries with respect to graph sizes. Using the same settings as Exp-2, for each group of queries, we vary the graph size. The results of distance and path queries are reported in Figures~\ref{fig:performance_dist_graph_size_af} and~\ref{fig:performance_dist_graph_size_dj} and Figures~\ref{fig:performance_path_graph_size_af} and~\ref{fig:performance_path_graph_size_dj}, respectively.
%In the third set of experiments, using the graph fragments generated at Exp-2, we evaluated (1) the average number of nodes and edges enforced by the hybrid landmarks covers  with or without the cost model, and (2) their average efficiency on a single fragment. The results are reported in Table~5.

The results tell us that (1) all algorithms scale well with respect to graph sizes, (2) for Proxy+Dijkstra, its time cost is 68\% and 67\% of  its counterpart without proxies for shortest path and distance queries on average, respectively, and (3) for Proxy+\arcflag, its time cost is 80\% and 82\% of its counterpart without proxies for shortest  path and distance queries on average, respectively, (4) for Proxy+\tnr, its time cost is comparable to its counterpart without proxies for shortest path and distance queries on average, respectively, (5) for Proxy+\tnr, it is applicable to handle larger dataset C-US while its counterpart \tnr without proxies is not. (6) for Proxy+\ah, its time cost is 98\% and 99\% of its counterparts without proxies for shortest path and distance queries on average, respectively. %For Proxy+\ch, the improvement is not very obvious since \ch is already very fast.
%, and (2) proxies can be easily combined with existing shortest path algorithms and improve its efficiency


%The results tell us that the usage of the cost model both reduces the number of landmarks and enforced edges, moreover, it only incurs little extra time cost.

%We also report the \super graphs in Table~6.
%The \super graphs $\G$ are quite small, typically have 2--4\% nodes and 10--15\% edges compared with the original graphs $G(V, E)$.
%Using hybrid landmark covers with the cost model, the \super graphs $\G(\V_c, \E_c)$ further reduce 0.2--0.3\% edges. This justified the effectiveness of proxies and graph partitions, and the introduction of the cost model for hybrid landmark covers.

\begin{figure*}[tb!]
\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize $Q_1$}]{\label{fig-dist-dj-varySize-Q1}
\includegraphics[scale=0.45]{./exp/query_q1_dist_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_3$}]{\label{fig-dist-dj-varySize-Q3}
\includegraphics[scale=0.45]{./exp/query_q3_dist_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_5$}]{\label{fig-dist-dj-varySize-Q5}
\includegraphics[scale=0.45]{./exp/query_q5_dist_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_7$}]{\label{fig-dist-dj-varySize-Q7}
\includegraphics[scale=0.45]{./exp/query_q7_dist_dj.eps}}
%\hspace{-4ex}\vspace{-1ex}
%\subfigure[{\scriptsize $Q_8$}]{\label{fig-exp4-varySize-Q8}
%\includegraphics[scale=0.422]{./exp/query_q8_dist_dj.eps}}
%\hfill
%\vspace{-1ex}
\end{center}
\vspace{1ex}
\caption{Varying graph sizes  for shortest distances: Dijkstra vs. Proxy+Dijkstra}
\label{fig:performance_dist_graph_size_dj}
\vspace{-1ex}
\end{figure*}

\begin{figure*}[tb!]
\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize $Q_1$}]{\label{fig-dist-af-varySize-Q1}
\includegraphics[scale=0.45]{./exp/query_q1_dist_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_3$}]{\label{fig-dist-af-varySize-Q3}
\includegraphics[scale=0.45]{./exp/query_q3_dist_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_5$}]{\label{fig-dist-af-varySize-Q5}
\includegraphics[scale=0.45]{./exp/query_q5_dist_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_7$}]{\label{fig-dist-af-varySize-Q7}
\includegraphics[scale=0.45]{./exp/query_q7_dist_af.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph sizes  for shortest distances: \arcflag vs. Proxy+\arcflag}
\label{fig:performance_dist_graph_size_af}
\vspace{-1ex}
\end{figure*}


\begin{figure*}[tb!]
\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize $Q_1$}]{\label{fig-dist-tnr-varySize-Q1}
\includegraphics[scale=0.45]{./exp/query_q1_dist_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_3$}]{\label{fig-dist-tnr-varySize-Q3}
\includegraphics[scale=0.45]{./exp/query_q3_dist_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_5$}]{\label{fig-dist-tnr-varySize-Q5}
\includegraphics[scale=0.45]{./exp/query_q5_dist_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_7$}]{\label{fig-dist-tnr-varySize-Q7}
\includegraphics[scale=0.45]{./exp/query_q7_dist_tnr.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph sizes  for shortest distances: \tnr vs. Proxy+\tnr}
\label{fig:performance_dist_graph_size_tnr}
\vspace{-1ex}
\end{figure*}

\begin{figure*}[tb!]
\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize $Q_1$}]{\label{fig-dist-ah-varySize-Q1}
\includegraphics[scale=0.45]{./exp/query_q1_dist_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_3$}]{\label{fig-dist-ah-varySize-Q3}
\includegraphics[scale=0.45]{./exp/query_q3_dist_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_5$}]{\label{fig-dist-ah-varySize-Q5}
\includegraphics[scale=0.45]{./exp/query_q5_dist_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_7$}]{\label{fig-dist-ah-varySize-Q7}
\includegraphics[scale=0.45]{./exp/query_q7_dist_ah.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph sizes  for shortest distances: \ah vs. Proxy+\ah}
\label{fig:performance_dist_graph_size_ah}
\hrule
\vspace{-1ex}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\begin{figure*}[tb!]
\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize $Q_1$}]{\label{fig-path-dj-varySize-Q1}
\includegraphics[scale=0.422]{./exp/query_q1_path_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_3$}]{\label{fig-path-dj-varySize-Q3}
\includegraphics[scale=0.422]{./exp/query_q3_path_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_5$}]{\label{fig-path-dj-varySize-Q5}
\includegraphics[scale=0.422]{./exp/query_q5_path_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_7$}]{\label{fig-path-dj-varySize-Q7}
\includegraphics[scale=0.422]{./exp/query_q7_path_dj.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph sizes  for shortest paths: Dijkstra vs. Proxy+Dijkstra}
\label{fig:performance_path_graph_size_dj}
\vspace{-1ex}
\end{figure*}



\begin{figure*}[tb!]
\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize $Q_1$}]{\label{fig-path-af-varySize-Q1}
\includegraphics[scale=0.422]{./exp/query_q1_path_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_3$}]{\label{fig-path-af-varySize-Q3}
\includegraphics[scale=0.422]{./exp/query_q3_path_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_5$}]{\label{fig-path-af-varySize-Q5}
\includegraphics[scale=0.422]{./exp/query_q5_path_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_7$}]{\label{fig-path-af-varySize-Q7}
\includegraphics[scale=0.422]{./exp/query_q7_path_af.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph sizes  for shortest paths: \arcflag and Proxy+\arcflag}
\label{fig:performance_path_graph_size_af}
\vspace{-1ex}
\end{figure*}

\begin{figure*}[tb!]
\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize $Q_1$}]{\label{fig-path-tnr-varySize-Q1}
\includegraphics[scale=0.422]{./exp/query_q1_path_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_3$}]{\label{fig-path-tnr-varySize-Q3}
\includegraphics[scale=0.422]{./exp/query_q3_path_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_5$}]{\label{fig-path-tnr-varySize-Q5}
\includegraphics[scale=0.422]{./exp/query_q5_path_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_7$}]{\label{fig-path-tnr-varySize-Q7}
\includegraphics[scale=0.422]{./exp/query_q7_path_tnr.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph sizes  for shortest paths: \tnr vs. Proxy+\tnr}
\label{fig:performance_path_graph_size_tnr}
\vspace{-1ex}
\end{figure*}

\begin{figure*}[tb!]
\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize $Q_1$}]{\label{fig-path-ah-varySize-Q1}
\includegraphics[scale=0.422]{./exp/query_q1_path_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_3$}]{\label{fig-path-ah-varySize-Q3}
\includegraphics[scale=0.422]{./exp/query_q3_path_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_5$}]{\label{fig-path-ah-varySize-Q5}
\includegraphics[scale=0.422]{./exp/query_q5_path_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_7$}]{\label{fig-path-ah-varySize-Q7}
\includegraphics[scale=0.422]{./exp/query_q7_path_ah.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph sizes  for shortest paths: \ah vs. Proxy+\ah}
\label{fig:performance_path_graph_size_ah}
\hrule
\vspace{-1ex}
\end{figure*}

\vspace{-0.5ex}
\stitle{Summary}.
From these experimental results, we find the following. (1) Proxies are a light-weight preprocessing technique, which can be computed efficiently and take linear space to support shortest path and distance queries.  (2) According to our experiments, in most cases, about 1/3 nodes in the graph are captured by proxies, leaving the reduced graph about 2/3 of the input graph. In some special cases (like \dblpone), about 2/3 nodes in the graph are captured by proxies, leaving the reduced graph about only 1/3 of the input graph. (3) Proxies and their \dras benefit existing shortest path and distance algorithms in terms of time cost and space cost. In terms of time cost, \eg they reduce 20\% , 30\% and 1\% time for \arcflag ,bidirectional Dijkstra and \ah in road networks, respectively. They also has comparable time cost to their counterparts without proxies for \tnr in road networks; They reduce 49\%, 4\% and 49\% time for birirectional Dijkstra, \arcflag, and \tnr on co-authorship network \dblpone, respectively. In terms of space cost, since the input graph is reduced by proxies, larger datasets can be handled when existing methods are combined with proxies. \eg \tnr with proxies can handle road network C-US while \tnr cannot. We also conduct an experiment to show that the size of the index for Proxy+\ah is about 82\% of that for \ah.

\eat{\vspace{-0.5ex}
\stitle{Remark}. We also combined proxies with a notion of {\em revised distance landmarks} to improve the efficiency of \ch~\cite{GeisbergerSSD08} for shortest distance queries in \cite{corrMaFWLH14}. \ch assigns a level to each the node in the graph and adds shortcuts into the graph. It adopts a revised bidirectional Dijkstra search which only utilizes the edges and shortcuts from lower level nodes to higher level nodes. Thus the searching space of \ch is quite small. With the help of proxies, \ch further reduces search space, and improves the efficiency of shortest distance queries \cite{corrMaFWLH14}.
}
