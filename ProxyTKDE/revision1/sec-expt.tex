\section{Experimental Study}
\label{sec-expt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%We next present an experimental study to show how proxies speed up shortest  path and distance queries.
%Using real-life networks, we conducted three
%sets of experiments to evaluate:
%(1) the performance of proxies,
%(2) the efficiency of (bidirectional) Dijkstra~\cite{LubyR89}, \arcflag \cite{MohringSSWW05}, \tnr \cite{arz2013transit} and their counterparts with proxies (Proxy+Dijkstra, Proxy+\arcflag, Proxy+\tnr) with respect to  graph queries, and (3) the efficiency of these algorithms with respect to graph sizes.
Using real-life road networks and social graphs, we next conduct an extensive experimental study to evaluate: (1) the performance of computing routing proxies, and (2) how routing proxies speed up shortest  path and distance queries, by comparing the efficiency of (bidirectional) Dijkstra~\cite{LubyR89}, \arcflag \cite{MohringSSWW05}, \tnr \cite{arz2013transit}, \ah \cite{zhu2013shortest} with their counterparts using proxies (Proxy+Dijkstra, Proxy+\arcflag, Proxy+\tnr, Proxy+\ah) with respect to graph queries and graph sizes.

\eat{%%%%%%%%%%%%EAT
\begin{table}[t!]
\label{tab-datasets}
\caption{Real-world graphs}
\vspace{-1ex}
\begin{center}
%\begin{small}
\begin{tabular}{|c|c|r|r|}
\hline
Name                            &  Regions               & \# of Nodes  &  \# of Edges \\
\hline\hline
DBLP14    &   A subgraph of DBLP                 & 141,359  &   246,462 \\ \hline
DBLP    & DBLP & 317,080 & 1,049,866 \\ \hline
CO      &  Colorado              & 435,666      &  521,200  \\ \hline
FL      &  Florida               & 1,070,376    &  1,343,951  \\ \hline
CA      &  California \& Nevada   & 1,890,815   &  2,315,222  \\ \hline
E-US    &  Eastern US            & 3,598,623    &  4,354,029 \\ \hline
W-US    &  Western US            & 6,262,104    &  7,559,642  \\ \hline
C-US    &  Central US            & 14,081,816   &  16,933,413 \\ \hline
US      &  Entire US             & 23,947,347   &  28,854,312  \\ \hline
\end{tabular}
%\end{small}
\end{center}
\end{table}
}%%%EAT%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{table*}[t!]
\label{tab-exp1-proxies-dras}
\begin{center}
\begin{scriptsize}
\caption{Effectiveness of proxies and \dras}
\vspace{-2ex}
\begin{tabular}{|c||c|c|c||r|r|r|r|r|r|}
\hline
  \multicolumn{4}{|c||}{\bf Datasets} & \multicolumn{6}{c|}{\bf Evaluation of Computing Routing Proxies}\\
  \hline
                          &  &  &  &  \multicolumn{1}{c|}{\bf Proxies}   &  \multicolumn{1}{c|}{\bf Nodes in \dras}  & \multicolumn{1}{c|}{\bf Extra space} & \multicolumn{1}{c|}{\bf Space of $G$} & \multicolumn{1}{c|}{\bf Space of $G'$} & \multicolumn{1}{c|}{\bf Time}\\

  \raisebox{1.5ex}[0pt]{\bf Graphs $G$} &   \raisebox{1.5ex}[0pt]{\bf Regions} &   \raisebox{1.5ex}[0pt]{\bf \# of Nodes} &   \raisebox{1.5ex}[0pt]{\bf \# of Edges} & \multicolumn{1}{c|}{\bf (\#, \%)}  &  \multicolumn{1}{c|}{\bf (\#, \%)}  & \multicolumn{1}{c|}{\bf (MB)} & \multicolumn{1}{c|}{\bf (MB)} & \multicolumn{1}{c|}{\bf (MB)} & \multicolumn{1}{c|}{\bf (Sec.)}\\
\hline\hline
DBLP14      &   Subgraph of DBLP          & 141,359  &   246,462     &  (14, 090, 9.8)         & (102,085, 72.2)  & 1.56 & 4.30 & 1.36 &  1.5 \\ \hline
DBLP        & DBLP                        & 317,080 & 1,049,866     & (31,475 , 9.9)             & (105,671 , 33.3) & 1.61 & 17.22 & 14.29  & 5.7 \\ \hline
CO          &  Colorado              & 435,666      &  521,200       &  (56,277, 12.9)         & (156,329, 35.9)  & 2.38  & 9.61 & 6.64 & 3.47  \\ \hline
FL          &  Florida               & 1,070,376    &  1,343,951      &  (140,382, 13.1)        & (378,804, 35.4)  & 5.78  & 24.59 & 17.12 &  9.9 \\ \hline
CA          &  California \& Nevada   & 1,890,815   &  2,315,222      &  (273,191, 14.4)        & (623,811, 33.0)  & 9.52  & 42.55 & 30.66 & 21.1 \\ \hline
E-US        &  Eastern US            & 3,598,623    &  4,354,029    &  (546,481, 15.2)        & (1,228,876, 34.1)& 18.75  & 80.17 & 56.48 &  52.5  \\ \hline
W-US        &  Western US            & 6,262,104    &  7,559,642      &  (869,907, 13.9)        & (2,116,382, 33.8)& 32.29  & 139.23 & 98.68 &  111.9 \\ \hline
C-US        &  Central US            & 14,081,816   &  16,933,413    &  (2,034,358, 14.4)      & (4,583,413, 32.5)& 69.94 & 312.09 & 225.28 & 435.8 \\ \hline
US          &  Entire US             & 23,947,347   &  28,854,312      &  (3,452,222, 14.4)      & (7,927,453, 33.1)& 120.96 & 531.63 & 380.59 &  1,925.4 \\ \hline
\end{tabular}
\end{scriptsize}
\end{center}
\vspace{-4ex}
\end{table*}
%%%%%%%%%%%%%%%%%%%





\subsection{Experimental Settings}
We first introduce the settings of our experimental study.







\stitle{Real-life graphs}.
We use two types of datasets, and the details of all datasets are reported in Table~1.



\sstab (1) The first type of datasets is {\em co-authorship networks}. We extracted co-authorship graphs from DLBP~\cite{snapnets}, where each node in the graph represents an author and two authors are connected if they have published papers together. The edge weight is computed by a revised Adamic/Adar similarity function: $w(u,v) = \frac{1}{\sum_{z\in {\Gamma(u)\cap \Gamma(v) \cup \{u,v\}}}\frac{1}{\log{|\Gamma(z)|}}}$, where $\Gamma(u)$ and $\Gamma(v)$ are the sets of neighbors of nodes $u$ and $v$, respectively. The weight of the edge $(u,v)$ represents the closeness between $u$ and $v$ and a smaller weight means the two authors are closer. \tnr is designed for road networks and it is very inefficient for \tnr to preprocess dense graphs such as DBLP (it took more than 1 week to finish the preprocessing). To guarantee that we can evaluate the improvement of \tnr with proxies on general graphs, we remove all nodes whose degrees are higher than 14, and choose the largest connected component in the remaining graph, referred to as \dblpone.


\sstab (2) The second type of datasets is {\em road networks}. We chose seven standard road network datasets of various sizes from the Ninth DIMACS
Implementation Challenge~\cite{dimacs-datasets} (available at {\url{http://www.dis.uniroma1.it/challenge9/download.shtml}}). Each road network is released as an undirected graph representing a part of the road network in the United States, where each edge weight is the distance (an integer) required to travel between the two endpoints of the edge.


\stitle{Shortest  path and distance queries}. Our queries were generated as follows.
(1) On each road  or co-authorship network, we first randomly choose a node $u$, and run a Dijikstra algorithm from $u$ to find the node $s$ that is farthest from $u$. Then we run a Dijkstra again from $s$ to find the node $t$ that is farthest from $s$. Let $\ell$ be the distance $\dist(s,t)$ from $s$ to $t$.
(2) We then randomly chose ten thousand node pairs from
the road network to compose $Q_i (i \in [1,7])$, such that the grid
distance of all node pairs in $Q_i$ is in $[2^{i-9}\cdot\ell, 2^{i-8}\cdot\ell)$.
For each query set $Q_i$ $(i\in [1,7])$, we report the average running time of 10,000 queries in the set.

%On each road network, we generated eight sets $Q_1$, $Q_2$, $\dots$ , $Q_{7}$ of
%queries. (1) We first imposed a $256 \times 256$ grid on the
%road network and computed the side length $\ell$ of each grid cell.
%(2) We then randomly chose ten thousand node pairs from
%the road network to compose $Q_i (i \in [1, 7])$, such that the grid
%distance of all node pairs in $Q_i$ is in $[2^{i-1}\cdot\ell, 2^i\cdot\ell)$. Note
%that the grid distance of two nodes $u, v$ in a query set is the distance of the cells into which $u$ and $v$ fall, respectively.
%Moreover, the grid distance of any node pair in $Q_i$ is
%larger than the grid distance of all node pairs in $Q_{i-1}$.
%For each query set $Q_i$ $(i \in [1, 7])$, we report the average running time of 10,000 queries in the set.

\stitle{Algorithms.} We implemented algorithms bidirectional-Dijkstra~\cite{LubyR89}, \arcflag~\cite{MohringSSWW05}, \tnr~\cite{arz2013transit} and \ah \cite{zhu2013shortest}.

For \arcflag, it first needs to partition graphs to pre-compute information on whether an arc is useful for a shortest path search. Any possible partition methods~\cite{kl70,Karypis98,YangYZK12, delling2011graph} can be used here. Since we have both road networks and co-authorship networks, we adopted the latest version 5.0.2 of \metis~\cite{metis}, implemented with ANSI C, because it is open source and performs quite well in practice.

For \tnr, since we do not have coordinates information in the co-authorship network, we implemented the CH-based \tnr~\cite{arz2013transit} that does not require the geometry information.

We obtained the C++ implementation of \ah from \cite{zhu2013shortest} and adopted its default settings.



\stitle{Implementations.} All algorithms were implemented with C++, and
all experiments were run on a PC with an Intel Xeon(R) X5650 CPU@2.67GHz
and 24GB of memory.






%\subsection{Experimental Results}
%We next present our findings. In all experiments, we tested the datasets in Table~1, and fixed the constant $c = 2$ for computing proxies on all graphs.
%The preprocessing of \arcflag was slow, and it spent over four days on C-US. Hence, we did not test the largest dataset US for \arcflag.
\subsection{Performance of Computing Routing Proxies}
Using the datasets in Table~1, we first conduct experiments to evaluate the performance of computing proxies, \ie\ how many nodes can be represented by proxies, how much extra space we need to store the routing information for the proxies, and how much time we need to find all proxies. More specifically, we evaluate (1) the number of non-trivial proxies, (2) the number and percentage of the nodes represented by the proxies (excluding the proxies themselves from \dras), (3) the extra space cost of using proxies, (4) the space overhead of storing the original graph $G$, (5) the space overhead of storing the reduced graph $G'$, and (6) the efficiency of algorithm $\compDRAs$ for computing proxies and their \dras. We fixed the constant $c = 2$ for computing proxies on all graphs. When computing the space overhead for the original graphs and the reduced graphs, we assume that all graphs are stored as adjacency lists. The experimental results are reported in Table~1.

%Note that to speed up shortest  path and distance queries, for each node represented by a proxy, we need to store (1) the distance between the node and its proxy, and (2) the shortest path from the node to its proxy. Distances are stored as 4-byte integers and it takes $4 \cdot |V_{\dras}|$ bytes to store all the distances, where $V_{\dras}$ is the set of nodes in all \dras. All the shortest paths between the nodes in a \dra and its proxy form a tree whose root is the proxy. Each node is also represented as a 4-byte integer. So it takes $ 4 \cdot (|V_{proxy}|+ |V_{\dras}|) $ bytes to maintain all the trees, where $V_{proxy}$ is the set of proxies. So the extra space cost of using proxies is $4 \cdot |V_{proxy}| + 8 \cdot |V_{\dras}|$ bytes. The results are reported in Table~2.
\stitle{1. Effectiveness evaluation}.
For the \dblp graph, about $1/10$ nodes are non-trivial proxies, and about $1/3$ nodes are captured by proxies in the graph, which means basically the reduced graph is only about $2/3$ of the original input graph. For the \dblpone graph, about $1/10$ nodes are non-trivial proxies, and about $2/3$ nodes are captured by the \dras of proxies in the graph, which means basically the reduced graph is only about $1/3$ of the original input graph.

For all the road graphs,  about $1/7$ nodes are non-trivial proxies, and about $1/3$ nodes are captured by the \dras of these proxies, which means basically the reduced graph is only about $2/3$ of the original input graph.

 Moreover, although the size restriction is $\le 2\cdot\lfloor\sqrt{|V|}\rfloor$, \dras are typically small such that each proxy represents 2 or 3 other nodes on average.


\begin{figure*}[t!]
%\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize DBLP14}]{\label{fig-dist-dj-varyQ-dblp}
\includegraphics[scale=0.45]{./exp/query_dblp_dist_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize CA}]{\label{fig-dist-dj-varyQ-CAL}
\includegraphics[scale=0.45]{./exp/query_cal_dist_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize E-US}]{\label{fig-dist-dj-varyQ-E-US}
\includegraphics[scale=0.45]{./exp/query_eus_dist_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize C-US}]{\label{fig-dist-dj-varyQ-C-US}
\includegraphics[scale=0.45]{./exp/query_cus_dist_dj.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph queries  for shortest distances: Dijkstra vs. Proxy+Dijkstra}
\label{fig:performance_dist_queries_dj}
\vspace{-1ex}
\end{figure*}

\begin{figure*}[t!]
%\vspace{-2ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize DBLP14}]{\label{fig-dist-af-varyQ-dblp}
\includegraphics[scale=0.45]{./exp/query_dblp_dist_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize CA}]{\label{fig-dist-af-varyQ-CAL}
\includegraphics[scale=0.45]{./exp/query_cal_dist_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize E-US}]{\label{fig-dist-af-varyQ-E-US}
\includegraphics[scale=0.45]{./exp/query_eus_dist_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize C-US}]{\label{fig-dist-af-varyQ-C-US}
\includegraphics[scale=0.45]{./exp/query_cus_dist_af.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph queries  for shortest distances: \arcflag vs. Proxy+\arcflag}
\label{fig:performance_dist_queries_af}
\vspace{-1ex}
\end{figure*}


\begin{figure*}[t!]
%\vspace{-2ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize DBLP14}]{\label{fig-dist-tnr-varyQ-dblp}
\includegraphics[scale=0.45]{./exp/query_dblp_dist_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize CA}]{\label{fig-dist-tnr-varyQ-CAL}
\includegraphics[scale=0.45]{./exp/query_cal_dist_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize E-US}]{\label{fig-dist-tnr-varyQ-E-US}
\includegraphics[scale=0.45]{./exp/query_eus_dist_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize C-US}]{\label{fig-dist-tnr-varyQ-ME-C-US}
\includegraphics[scale=0.45]{./exp/query_cus_dist_tnr.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph queries  for shortest distances: \tnr and Proxy+\tnr}
\label{fig:performance_dist_queries_tnr}
\vspace{-1ex}
\end{figure*}

\begin{figure*}[t!]
%\vspace{-2ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize CA}]{\label{fig-dist-ah-varyQ-CAL}
\includegraphics[scale=0.45]{./exp/query_cal_dist_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize E-US}]{\label{fig-dist-ah-varyQ-E-US}
\includegraphics[scale=0.45]{./exp/query_eus_dist_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize C-US}]{\label{fig-dist-ah-varyQ-ME-C-US}
\includegraphics[scale=0.45]{./exp/query_cus_dist_ah.eps}}
\end{center}
%\vspace{1ex}
\caption{Varying graph queries  for shortest distances: \ah vs. Proxy+\ah}
\hrule
\label{fig:performance_dist_queries_ah}
\vspace{-2ex}
\end{figure*}




\stitle{2. Efficiency evaluation}.
In the \dblp graph, proxies can be found in about 6 seconds. In the \dblpone graph, it only takes 1.5 seconds to find all \dras with their proxies.

In all road networks, proxies can be found efficiently. Algorithm $\compDRAs$ also scales well, and it can be done in less than half an hour for the largest graph US with $2.4$ $\times$ $10^7$ nodes and $5.7$ $\times$ $10^7$ edges.

\stitle{3. Space evaluation}.
To support shortest distance queries, for each node in a \dra, we store its proxy $u$, its distance to $u$ and the component of $A^{+}_u$ to which it belongs, and, moreover, to support shortest path queries, we further keep the shortest paths from proxy $u$ to all nodes in the \dra. Assume that distances are stored as a 4-byte integer. Each node is represented as a 4-byte integer. Then the extra space that we need for shortest path and distance queries is $16\cdot |V_{dra}|$, where $V_{dra}$ is the set of nodes in all \dras.

In the \dblp and \dblpone graphs, it only takes about 1.6 MB extra space to store the routing information for all proxies, since there are similar number of nodes in the \dras of both datasets. Observe that by using proxies to represent all nodes in \dras, the reduced graph  has a smaller size than the original graph, especially for the \dblpone graph. In the \dblpone graph, 72.2\% of its nodes are captured by proxies, which leads to a much smaller reduced graph.

In all road networks, it incurs small extra space overhead to store the routing information for proxies. Only about 100 MB extra space is taken for the largest graph US. The use of proxies also results in a smaller reduced graph. As shown in Table~1, the size of the reduced graph is about 70\% of the original graph on average.



From these tests, we can find that using proxies is a light-weight optimization technique, which scales well to large networks, and incurs appropriate space overhead. %These properties benefit existing shortest  path and distance algorithms, such as (bidirectional) Dijkstra, \arcflag , \tnr and \ah, to be seen immediately.

\subsection{Benefits of Using Routing Proxies}
Our proxies can be used as a preprocessing step before we apply other existing approaches.
We next conduct experiments to show the comparison results of an existing approach (\ie \ Dijkstra, \arcflag, \tnr and \ah) with its counterpart using proxies, using the datasets in Table~1.



Due to the space limitation, we sometimes only report the results on \dblpone, CA, E-US, and C-US.
%A more detailed results can be found in the supplementary document.
We fixed the constant $c = 2$ for computing proxies on all graphs. Note that \ah requires the coordinate information to answer shortest path or distance queries, which is not available in \dblp and \dblpone. Thus, we only report results on CA, E-US, and C-US for \ah and its counterpart.
%The preprocessing of \arcflag was slow, and it spent over 4 days on C-US. Hence, we did not test the largest road network dataset US for \arcflag.
%\tnr invokes Contract Hierarchies (\ch) for preprocessing and \ch is very inefficient on dense graphs. Unfortunately \dblp is a very dense graph and it took more than 7 days for \ch to finish preprocessing on \dblp. Thus we tested \dblpone, instead of \dblp, for the performance of shortest path and distance queries. The CH-based \tnr whose space cost was very high, and consequently, and we could not run either \tnr or Proxy+\tnr on the largest road network dataset US, as both of them ran out of memory. Hence, we did not test the largest graph for \tnr as well. However, on the second largest road network dataset C-US, Proxy+\tnr can while \tnr cannot. We report this to show that proxies serve as a data reduction technique and benefit existing methods in terms of space cost as well.




\stitle{1. Effectiveness  \wrt graph queries}.
%In the second set of experiments, we justified that the \gdp problem could be solved well by \metis, originally for traditional graph partitioning problems. Using the shrink graphs generated at Exp-1, we evaluated the effectiveness and  efficiency of \metis. To ensure the query efficiency of \disland, each fragment has at most $c \cdot \lfloor\sqrt{|V|}\rfloor$ number of nodes. We used the multilevel bisection method of \metis with the balance factor fixed to 1.003. The results are reported in Table~4.
%
In this set of experiments, we evaluated the efficiency of shortest path and distance queries with respect to the graph queries.

For the \arcflag and Proxy+\arcflag methods, the graph and the reduced graph are partitioned into fragments such that each fragment has at most $2\cdot \lfloor\sqrt{|V|}\rfloor$ nodes in order to add labels to edges. We used \metis to partition graphs with the balance factor fixed to 1.003.

For the \tnr and Proxy+\tnr methods, we always select 10,000 transit nodes, as suggested in \cite{arz2013transit}. Note that the space cost of the CH-based \tnr is very high. Consequently, we could not run \tnr on C-US as it ran out of memory. However, we can successfully run Proxy+\tnr on C-US. We report this to show that proxies serve as a data reduction technique and benefit existing methods in terms of space cost as well. \tnr invokes Contract Hierarchies (\ch) \cite{GeisbergerSSD08} to preprocess the graph and \ch runs very slowly on \dblp (it took more than 7 days to run \ch on \dblp). Thus we report the results on \dblpone and all the road networks.

The results of distance queries and path queries are reported in Figures~\ref{fig:performance_dist_queries_dj} and \ref{fig:performance_path_queries_dj} (comparison between Dijkstra and Proxy+Dijkstra), Figures~\ref{fig:performance_dist_queries_af} and~\ref{fig:performance_path_queries_af} (comparison between \arcflag and Proxy+\arcflag), Figures~\ref{fig:performance_dist_queries_tnr} and~\ref{fig:performance_path_queries_tnr} (comparison between \tnr and Proxy+\tnr), and Figures~\ref{fig:performance_dist_queries_ah} and~\ref{fig:performance_path_queries_ah} (comparison between \ah and Proxy+\ah), respectively.

In the co-authorship network \dblpone, the results show that with the help of proxies, Proxy+Dijkstra, Proxy+\arcflag and Proxy+\tnr all achieve a better performance than their counterparts Dijkstra, \arcflag and \tnr without proxies, respectively. On average, the time cost of Proxy+\arcflag, Proxy+Dijkstra and Proxy+\tnr is about 96\%, 51\% and 51\% of their counterparts without proxies for distance queries, and 98\%, 49\% and 76\% of their counterparts without proxies for shortest path queries, respectively. More specifically, we can see that (1) proxies have a better speed-up effect on bidirectional Dijkstra and \tnr than \arcflag, (2) for \arcflag, proxies have a better speed-up effect when the two query nodes are far from each other, which is different from the observation on road networks. To explain the second observation, we need to notice that about 2/3 nodes are captured by proxies in \dblpone. Thus two close nodes are more likely to fall into the same \dras. Since there are no speed-up techniques used inside single \dras, the search space saved by proxies is less than using \arcflag alone.

In the road networks, the results show that with the help of proxies, Proxy+Dijkstra and Proxy+\arcflag can achieve a better performance than their counterparts without proxies, respectively. On average, the time cost of Proxy+\arcflag, Proxy+Dijkstra and Proxy+\ah is about 80\%, 68\% and 99\% of their counterparts without proxies for distance queries, and 82\%, 67\% and 99\% of their counterparts without proxies for shortest path queries, respectively. More specifically, we can see that (1) proxies have a better speed-up effect on bidirectional Dijkstra than \arcflag, (2) for \arcflag, proxies have a better speed-up effect when the two query nodes are close to each other, (3) different from \arcflag, proxy+Dijkstra has a better performance when the query nodes are far from each other, and (4) though \ah is one of the state-of-art method for shortest path and distance queries, proxies still improves the its efficiency about 1\%. To explain these observations, we need to think how much search space is saved by proxies. Since \arcflag has already used flags on edges to reduce the search space, the proportion of search space saved by proxies is smaller than bidirectional Dijkstra. That explains why proxies have a better speed-up effect on bidirectional Dijkstra. For \arcflag, two close nodes are more likely to fall into the same partition. In this case, the effect of flags on edges is less useful and the search space saved by proxies takes a large proportion, which explains the second observation. For bidirectional Dijkstra, proxies can save more search space when the query nodes are far from each other. As a state-of-art approach for shortest path and distance queries, the search space of \ah is much smaller than Dijkstra and \arcflag. However, the search space of \ah is still reduced, and \ah still benefits from proxies in terms of efficiency.

Proxy+\tnr achieves a comparable performance to its counterpart without proxies. This is because for \tnr, a heuristic method is used to generate the node order, based on the structure of the graph. And the node order can affect the performance of \tnr. Since we reduce the input graph by using proxies, the reduced graph has a different topology structure. Thus a different node order will be generated. So it is hard to guarantee that Proxy+\tnr outperforms \tnr. We should also notice that \tnr cannot run on C-US while Proxy+\tnr can. To explain this, we first recall that for \tnr, we have to store the access nodes and distances for each node. For the original input of C-US, there are too many nodes and it runs out of memory. By using proxies, about 1/3 nodes are captured by proxies and we only need to run \tnr on 2/3 of the input graph, which is more practical.


\begin{figure*}[t!]
%\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize DBLP14}]{\label{fig-path-dj-varyQ-dblp}
\includegraphics[scale=0.45]{./exp/query_dblp_path_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize CA}]{\label{fig-path-dj-varyQ-CAL}
\includegraphics[scale=0.45]{./exp/query_cal_path_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize E-US}]{\label{fig-path-dj-varyQ-E-US}
\includegraphics[scale=0.45]{./exp/query_eus_path_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize C-US}]{\label{fig-path-dj-varyQ-C-US}
\includegraphics[scale=0.45]{./exp/query_cus_path_dj.eps}}
%\hfill
%\vspace{-1ex}
\end{center}
\vspace{1ex}
\caption{Varying graph queries for shortest paths: Dijkstra vs. Proxy+Dijkstra}
\label{fig:performance_path_queries_dj}
\vspace{-1ex}
\end{figure*}
\begin{figure*}[t!]
%\vspace{2ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize DBLP14}]{\label{fig-path-af-varyQ-dblp}
\includegraphics[scale=0.45]{./exp/query_dblp_path_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize CA}]{\label{fig-path-af-varyQ-CAL}
\includegraphics[scale=0.45]{./exp/query_cal_path_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize E-US}]{\label{fig-path-af-varyQ-E-US}
\includegraphics[scale=0.45]{./exp/query_eus_path_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize C-US}]{\label{fig-path-af-varyQ-C-US}
\includegraphics[scale=0.45]{./exp/query_cus_path_af.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph queries for shortest paths: \arcflag and Proxy+\arcflag}
\label{fig:performance_path_queries_af}
\vspace{-1ex}
\end{figure*}
\begin{figure*}[t!]
%\vspace{2ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize DBLP14}]{\label{fig-path-tnr-varyQ-dblp}
\includegraphics[scale=0.45]{./exp/query_dblp_path_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize CA}]{\label{fig-path-tnr-varyQ-CAL}
\includegraphics[scale=0.45]{./exp/query_cal_path_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize E-US}]{\label{fig-path-tnr-varyQ-E-US}
\includegraphics[scale=0.45]{./exp/query_eus_path_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize C-US}]{\label{fig-path-tnr-varyQ-ME-C-US}
\includegraphics[scale=0.45]{./exp/query_cus_path_tnr.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph queries  for shortest paths: \tnr and Proxy+\tnr}
\label{fig:performance_path_queries_tnr}
\vspace{-1ex}
\end{figure*}
\begin{figure*}[t!]
%\vspace{2ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize CA}]{\label{fig-path-ah-varyQ-CAL}
\includegraphics[scale=0.45]{./exp/query_cal_path_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize E-US}]{\label{fig-path-ah-varyQ-E-US}
\includegraphics[scale=0.45]{./exp/query_eus_path_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize C-US}]{\label{fig-path-ah-varyQ-ME-C-US}
\includegraphics[scale=0.45]{./exp/query_cus_path_ah.eps}}
\end{center}
%\vspace{1ex}
\caption{Varying graph queries for shortest paths: \ah and Proxy+\ah}
\label{fig:performance_path_queries_ah}
\hrule
\vspace{-2ex}
\end{figure*}



 %The approaches are speeded up by reducing the search space. because , especially when the two nodes in the query are close to each other. For example for Q1 in dataset CO, the time cost of \arcflag is 1.4 times of the time cost of Proxy+\arcflag. This is because when two nodes are close, their proxies are more likely to be close to each other and computing the shortest path between the two proxies has a smaller share in the total time cost. %For the \ch and its counterparts with proxies, though the time cost of the two methods are very similar, \ch with proxies is slightly faster than the original \ch.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\stitle{2. Effectiveness \wrt graph sizes}.
%
Since \dblpone is a single dataset, we only compare the efficiency of a group of shortest path and distance queries $\{Q_1, Q_3, Q_5, Q_7\}$  on road graphs using the same settings.
The results of distance and path queries are reported in
Figures~\ref{fig:performance_dist_graph_size_dj} and~\ref{fig:performance_path_graph_size_dj} (comparison between Dijkstra and Proxy+Dijkstra), Figures~\ref{fig:performance_dist_graph_size_af} and~\ref{fig:performance_path_queries_af} (comparison between \arcflag and Proxy+\arcflag), Figures~\ref{fig:performance_dist_graph_size_tnr} and~\ref{fig:performance_path_graph_size_tnr} (comparison between \tnr and Proxy+\tnr), and Figures~\ref{fig:performance_dist_graph_size_ah} and~\ref{fig:performance_path_graph_size_ah} (comparison between \ah and Proxy+\ah), respectively.

\begin{figure*}[tb!]
%\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize $Q_1$}]{\label{fig-dist-dj-varySize-Q1}
\includegraphics[scale=0.45]{./exp/query_q1_dist_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_3$}]{\label{fig-dist-dj-varySize-Q3}
\includegraphics[scale=0.45]{./exp/query_q3_dist_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_5$}]{\label{fig-dist-dj-varySize-Q5}
\includegraphics[scale=0.45]{./exp/query_q5_dist_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_7$}]{\label{fig-dist-dj-varySize-Q7}
\includegraphics[scale=0.45]{./exp/query_q7_dist_dj.eps}}
%\hspace{-4ex}\vspace{-1ex}
%\subfigure[{\scriptsize $Q_8$}]{\label{fig-exp4-varySize-Q8}
%\includegraphics[scale=0.422]{./exp/query_q8_dist_dj.eps}}
%\hfill
%\vspace{-1ex}
\end{center}
\vspace{1ex}
\caption{Varying graph sizes  for shortest distances: Dijkstra vs. Proxy+Dijkstra}
\label{fig:performance_dist_graph_size_dj}
\vspace{-1ex}
\end{figure*}
\begin{figure*}[tb!]
%\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize $Q_1$}]{\label{fig-dist-af-varySize-Q1}
\includegraphics[scale=0.45]{./exp/query_q1_dist_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_3$}]{\label{fig-dist-af-varySize-Q3}
\includegraphics[scale=0.45]{./exp/query_q3_dist_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_5$}]{\label{fig-dist-af-varySize-Q5}
\includegraphics[scale=0.45]{./exp/query_q5_dist_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_7$}]{\label{fig-dist-af-varySize-Q7}
\includegraphics[scale=0.45]{./exp/query_q7_dist_af.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph sizes  for shortest distances: \arcflag vs. Proxy+\arcflag}
\label{fig:performance_dist_graph_size_af}
\vspace{-1ex}
\end{figure*}
\begin{figure*}[tb!]
%\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize $Q_1$}]{\label{fig-dist-tnr-varySize-Q1}
\includegraphics[scale=0.45]{./exp/query_q1_dist_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_3$}]{\label{fig-dist-tnr-varySize-Q3}
\includegraphics[scale=0.45]{./exp/query_q3_dist_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_5$}]{\label{fig-dist-tnr-varySize-Q5}
\includegraphics[scale=0.45]{./exp/query_q5_dist_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_7$}]{\label{fig-dist-tnr-varySize-Q7}
\includegraphics[scale=0.45]{./exp/query_q7_dist_tnr.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph sizes  for shortest distances: \tnr vs. Proxy+\tnr}
\label{fig:performance_dist_graph_size_tnr}
\vspace{-1ex}
\end{figure*}
\begin{figure*}[tb!]
%\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize $Q_1$}]{\label{fig-dist-ah-varySize-Q1}
\includegraphics[scale=0.45]{./exp/query_q1_dist_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_3$}]{\label{fig-dist-ah-varySize-Q3}
\includegraphics[scale=0.45]{./exp/query_q3_dist_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_5$}]{\label{fig-dist-ah-varySize-Q5}
\includegraphics[scale=0.45]{./exp/query_q5_dist_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_7$}]{\label{fig-dist-ah-varySize-Q7}
\includegraphics[scale=0.45]{./exp/query_q7_dist_ah.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph sizes  for shortest distances: \ah vs. Proxy+\ah}
\label{fig:performance_dist_graph_size_ah}
\hrule
\vspace{-2ex}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5





%In the third set of experiments, we evaluated the efficiency of shortest path and distance queries with respect to graph sizes. Using the same settings as Exp-2, for each group of queries, we vary the graph size. The results of distance and path queries are reported in Figures~\ref{fig:performance_dist_graph_size_af} and~\ref{fig:performance_dist_graph_size_dj} and Figures~\ref{fig:performance_path_graph_size_af} and~\ref{fig:performance_path_graph_size_dj}, respectively.
%In the third set of experiments, using the graph fragments generated at Exp-2, we evaluated (1) the average number of nodes and edges enforced by the hybrid landmarks covers  with or without the cost model, and (2) their average efficiency on a single fragment. The results are reported in Table~5.

The results tell us that (1) all algorithms scale well with respect to graph sizes, (2) for Proxy+Dijkstra, its time cost is 68\% and 67\% of  its counterpart without proxies for shortest path and distance queries on average, respectively, and (3) for Proxy+\arcflag, its time cost is 80\% and 82\% of its counterpart without proxies for shortest  path and distance queries on average, respectively, (4) for Proxy+\tnr, its time cost is comparable to \tnr for shortest path and distance queries on average, respectively, (5) for Proxy+\tnr, it is applicable to handle the larger dataset C-US while \tnr cannot, and (6) for Proxy+\ah, its time cost is 98\% and 99\% of \ah for shortest path and distance queries on average, respectively. (7) As the size of graphs increases, the running time of Dijkstra, \arcflag and \ah increases in the same way as their counterparts with proxies. (8) For \tnr, the selection of transit nodes is based on the graph structure and has a significantly effect on the efficiency. By using proxies, the reduced graph has a different set of transit nodes and it is hard to guarantee that which set of transit nodes can get a better query efficiency. Thus, Proxy+\tnr does not outperform \tnr constantly as the other 3 approaches do.   %For Proxy+\ch, the improvement is not very obvious since \ch is already very fast.
%, and (2) proxies can be easily combined with existing shortest path algorithms and improve its efficiency


%The results tell us that the usage of the cost model both reduces the number of landmarks and enforced edges, moreover, it only incurs little extra time cost.

%We also report the \super graphs in Table~6.
%The \super graphs $\G$ are quite small, typically have 2--4\% nodes and 10--15\% edges compared with the original graphs $G(V, E)$.
%Using hybrid landmark covers with the cost model, the \super graphs $\G(\V_c, \E_c)$ further reduce 0.2--0.3\% edges. This justified the effectiveness of proxies and graph partitions, and the introduction of the cost model for hybrid landmark covers.


\stitle{3. Space overhead}.
In the last set of experiments, we evaluate the space overhead of \arcflag, \tnr and \ah compared with their counterparts with proxies, since all of them require preprocessing for query answering. We report (1) the size of the index generated by \arcflag, \tnr and \ah on the original input graphs, and (2) the sum of the size of the index generated by \ah on the reduced graph and the extra space it takes to store routing information for proxies. Note that for \tnr and Proxy+\tnr, no compression techniques are used. The results are reported in Table~2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\begin{figure*}[tb!]
%\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize $Q_1$}]{\label{fig-path-dj-varySize-Q1}
\includegraphics[scale=0.45]{./exp/query_q1_path_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_3$}]{\label{fig-path-dj-varySize-Q3}
\includegraphics[scale=0.45]{./exp/query_q3_path_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_5$}]{\label{fig-path-dj-varySize-Q5}
\includegraphics[scale=0.45]{./exp/query_q5_path_dj.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_7$}]{\label{fig-path-dj-varySize-Q7}
\includegraphics[scale=0.45]{./exp/query_q7_path_dj.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph sizes  for shortest paths: Dijkstra vs. Proxy+Dijkstra}
\label{fig:performance_path_graph_size_dj}
\vspace{-1ex}
\end{figure*}
\begin{figure*}[tb!]
%\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize $Q_1$}]{\label{fig-path-af-varySize-Q1}
\includegraphics[scale=0.45]{./exp/query_q1_path_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_3$}]{\label{fig-path-af-varySize-Q3}
\includegraphics[scale=0.45]{./exp/query_q3_path_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_5$}]{\label{fig-path-af-varySize-Q5}
\includegraphics[scale=0.45]{./exp/query_q5_path_af.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_7$}]{\label{fig-path-af-varySize-Q7}
\includegraphics[scale=0.45]{./exp/query_q7_path_af.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph sizes  for shortest paths: \arcflag and Proxy+\arcflag}
\label{fig:performance_path_graph_size_af}
\vspace{-1ex}
\end{figure*}
\begin{figure*}[tb!]
%\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize $Q_1$}]{\label{fig-path-tnr-varySize-Q1}
\includegraphics[scale=0.45]{./exp/query_q1_path_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_3$}]{\label{fig-path-tnr-varySize-Q3}
\includegraphics[scale=0.45]{./exp/query_q3_path_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_5$}]{\label{fig-path-tnr-varySize-Q5}
\includegraphics[scale=0.45]{./exp/query_q5_path_tnr.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_7$}]{\label{fig-path-tnr-varySize-Q7}
\includegraphics[scale=0.45]{./exp/query_q7_path_tnr.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph sizes  for shortest paths: \tnr vs. Proxy+\tnr}
\label{fig:performance_path_graph_size_tnr}
\vspace{-1ex}
\end{figure*}
\begin{figure*}[tb!]
%\vspace{-1ex}
\begin{center}
\hspace{-4ex}
\subfigure[{\scriptsize $Q_1$}]{\label{fig-path-ah-varySize-Q1}
\includegraphics[scale=0.45]{./exp/query_q1_path_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_3$}]{\label{fig-path-ah-varySize-Q3}
\includegraphics[scale=0.45]{./exp/query_q3_path_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_5$}]{\label{fig-path-ah-varySize-Q5}
\includegraphics[scale=0.45]{./exp/query_q5_path_ah.eps}}
\hspace{-4ex}\vspace{-1.5ex}
\subfigure[{\scriptsize $Q_7$}]{\label{fig-path-ah-varySize-Q7}
\includegraphics[scale=0.45]{./exp/query_q7_path_ah.eps}}
\end{center}
\vspace{1ex}
\caption{Varying graph sizes  for shortest paths: \ah vs. Proxy+\ah}
\label{fig:performance_path_graph_size_ah}
\hrule
\vspace{-2ex}
\end{figure*}


In the co-authorship network \dblpone, different from our expectation, \arcflag requires less space overhead than Proxy+\arcflag. This is because that the graph is relatively small and has small number of partitions. Thus, for each edge we only need to maintain a 8-byte label in \arcflag. However, when using proxy, we need to maintain 12-byte routing information for each node. As we have shown before, about 70\% of the nodes in \dblpone fall into the \dras, thus, \arcflag requires less space overhead than Proxy+\arcflag. However, in \dblp, since the graph is larger (we need to maintain a 17-byte label for each edge), Proxy+\arcflag requires only about 14\% of the space overhead of \arcflag. We can also observe that the space overhead of Proxy+\tnr is about 98\% of \tnr.

In the road networks, we can make the following observations: (1) Proxy+\arcflag incurs less space overhead than \arcflag (from 38\% to 68\%), especially for large graphs (about 38\% for CUS). This is because we need more bytes to maintain edge labels for large graphs. Thus the reduction has a better performance on large graphs. (2) Proxy+\tnr incurs less space overhead than \tnr (from 72\% to 92\%). Recall that for \tnr, we need to maintain a list of access nodes and a list of filter nodes for each node in the graph. A larger graph usually incurs a larger size of filter nodes. Thus, by using proxies to represent nodes in \dras, we can save more space for larger graphs. (3) Proxy+\ah is about 82\% of its counterpart without proxies.

From the above experimental results, we can see that the existing solution benefit from proxies in terms of space overhead in the query answering stage.

















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{table}[t!]
\label{tab-spacecost}
\caption{Comparison \wrt space overhead}
\vspace{-3ex}
\begin{center}
\begin{scriptsize}
%\hspace{-2ex}
\begin{tabular}{|c||c|c|c|}
\hline
& \multicolumn{1}{c|}{\bf \arcflag (MB)}  & \multicolumn{1}{c|}{\bf \tnr (MB)} & \multicolumn{1}{c|}{\bf \ah (MB)} \\
\cline{2-4}
{\bf Graphs}  & {\bf with vs. no proxies} & {\bf with vs. no proxies} & {\bf with vs. no proxies}   \\
\hline\hline
DBLP14  &(4.9, 4.3)         &(386.5, 389.2)     &(NA, NA) \\ \hline
DBLP    &(16.1, 35.2)       &(NA, NA)           &(NA, NA) \\ \hline
CO      & (9.3, 13.6)       &(417.1, 430.18)    & (58.1, 72.2)  \\ \hline
FL      & (29.7, 52.8)      &(491.9, 530.5)     & (150.9, 187.3)  \\ \hline
CA      & (55.1, 108.8)     &(701.9, 806.4)     & (277.9, 338.1)  \\ \hline
E-US    &(134.9, 287.8)     &(1842.9, 2382.7)   & (525.5, 642.0)  \\ \hline
W-US    &(277.3, 643.9)     &(2996.4, 4154.1)   & (889.6, 1092.3)  \\ \hline
C-US    &(838.8, 2153.1)    &(13894.5, N.A)     & (2082.3, 2512.3) \\ \hline
US      &(NA, NA)           &(NA, NA)           & (3512.7, 4266.9)  \\ \hline
\end{tabular}
\end{scriptsize}
\end{center}
\vspace{-5ex}
\end{table}



\vspace{-0.5ex}
\stitle{Summary}.
From these experimental results, we find the following. (1) Proxies are a light-weight preprocessing technique, which can be computed efficiently and take linear space to support shortest path and distance queries.  (2) According to our experiments, in most cases, about 1/3 nodes in the graph are captured by proxies, leaving the reduced graph about 2/3 of the input graph. In some special cases (like \dblpone), about 2/3 nodes in the graph are captured by proxies, leaving the reduced graph about only 1/3 of the input graph. (3) Proxies and their \dras benefit existing shortest path and distance algorithms in terms of time cost. They reduce 20\%, 30\% and 1\% time for \arcflag, bidirectional Dijkstra and \ah on road networks, respectively. They also has comparable time cost for \tnr on road networks; They reduce 49\%, 4\% and 49\% time for bidirectional Dijkstra, \arcflag, and \tnr on the co-authorship network \dblpone, respectively. (4) Existing approaches also benefit from proxies in terms of space overhead. Since the original input graph is reduced by proxies, larger datasets may be handled when existing methods are combined with proxies.  Proxy+\tnr can handle the road network C-US while \tnr cannot. Moreover, Proxy+\arcflag incurs less space overhead than \arcflag (from 38\% to 68\%), Proxy+\tnr is about from 72\% to 92\% of its counterpart without proxies, and Proxy+\ah is about 82\% of its counterpart without proxies.

\eat{\vspace{-0.5ex}
\stitle{Remark}. We also combined proxies with a notion of {\em revised distance landmarks} to improve the efficiency of \ch~\cite{GeisbergerSSD08} for shortest distance queries in \cite{corrMaFWLH14}. \ch assigns a level to each the node in the graph and adds shortcuts into the graph. It adopts a revised bidirectional Dijkstra search which only utilizes the edges and shortcuts from lower level nodes to higher level nodes. Thus the searching space of \ch is quite small. With the help of proxies, \ch further reduces search space, and improves the efficiency of shortest distance queries \cite{corrMaFWLH14}.
}
