\section{Introduction}
\label{sec-intro}


%Problem definition
We study the {\em node-to-node shortest path} ({\em distance}) problem on large graphs: given a weighted undirected graph $G(V, E)$ with non-negative edge weights, and two nodes of $G$, the source $s$ and the target $t$, find the shortest path (distance) from $s$ to $t$ in $G$. We allow the usage of auxiliary structures  generated by preprocessing, but restrict them to have a moderate size (compared with the input graph).  In this work, we are only interested in shortest paths and {\em exact}  shortest distances on {\em large} graphs.

%The importance of shortest distance.
Finding shortest  paths and distances is one of the fundamental problems on graphs, and has found its usage as a building block in various applications, \eg measuring the closeness of nodes in social networks and Web graphs~\cite{LappasLT09,PotamiasBCG09,SarmaGNP10}, finding the distances between physical locations in road networks~\cite{WuXDCZZ12}, and drivers' routing services~\cite{DLiuYK13}.

%History of algorithms
Algorithms for computing shortest  paths and distances have been studied since 1950's and still remain an {\em active} area of research. The classical one is Dijkstra's algorithm~\cite{CormenLRS01} due to Edsger Dijkstra. Dijkstra's original algorithm runs in $O(n^2)$~\cite{Dijkstra59}, and the enhanced implementation with Fibonacci heaps runs in $O(n\log n + m)$ due to Fredman \& Tarjan~\cite{FredmanT84}, where $n$ and $m$ denote the numbers of nodes and edges in a graph, respectively. The latter remains asymptotically the fastest known solution on arbitrary undirected graphs with non-negative edge weights~\cite{ThorupZ05}.

%The challenge of computing shortest paths on large graphs.
However, computing shortest  paths and distances remains a challenging problem, in terms of both time and space cost, for large-scale graphs such as Web graphs, social networks and road networks. The Dijkstra's algorithm~\cite{FredmanT84} is not acceptable on large graphs (\eg with tens of millions of nodes and edges) for online applications ~\cite{PotamiasBCG09}. Therefore, a lot of optimization techniques have been recently developed to speed up the computation~\cite{PotamiasBCG09,SarmaGNP10,WuXDCZZ12,LubyR89,GeisbergerSSD08,Wei10,SankaranarayananSA09,SandersS05,ChengKCC12}.


\eat{%The story of distance landmarks.
{\em Distance landmarks} (\aka\ {\em distance oracles}) are data structures that support efficient shortest distance query answering, and have been recently studied in both theory~\cite{ThorupZ05,MozesS12} and practice~\cite{PotamiasBCG09,SarmaGNP10,SankaranarayananS10}. It can also be used to answer shortest path queries. An $n\times n$ {\em triangular matrix} of size $n^2/2$ for all-pair shortest distances can be computed in $O(n^2\log n + $ $mn)$ time, using Dijkstra's algorithm~\cite{FredmanT84}, where $n$ and $m$ are the numbers of nodes and edges, respectively. With the distance matrix, shortest distance queries can be answered in $O(1)$ time.
%
This solution, however, is {\em not practical} on large graphs: the preprocessing time is too long, and even if one is willing to wait that long, the matrix is too large to be stored effectively. For instance, the matrix of a graph with one million nodes needs about $1,862$ GB memory (here the distance entries are stored as $4$-byte integers).
%Hence, it is impractical for large graphs.

Distance landmarks aim at {\em striking a balance} between the efficiency benefits of answering shortest distance queries and the time and space cost of computing and storing them. And distance landmarks have already been adopted for answering {\em approximate} shortest distances~\cite{PotamiasBCG09,SarmaGNP10,ThorupZ05,SankaranarayananS10}, and for answering {\em exact} shortest distances on directed graphs~\cite{GoldbergH05,MozesS12}. However, how to apply distance landmarks for answering exact shortest distances on undirected graphs is mainly limited to pure theoretical analyses~\cite{ThorupZ05}.
}
%
\eat{

In this work, we show, both theoretically and experimentally, that distance landmarks can not be directly use for real-life large graph. Nevertheless, we propose a set of techniques for distance landmarks, which together work well for answering shortest distance queries on large graphs.
}



To speed-up shortest  path and distance queries, our approach is to use {\em representatives}, each of which captures a set of nodes in a graph. The task of finding a proper form of representatives is, however, {\em nontrivial}. Intuitively, we expect representatives to have the following properties.
%
(1) A small number of representatives can represent a large number of nodes in a graph;
%
(2) Shortest paths and distances involved within the set of nodes being represented by the same representative can be answered efficiently; And,
%
(3) the representatives and the set of nodes being represented can be computed efficiently.


\stitle{Contributions \& Roadmap}. In this work, we develop a light-weight data reduction technique for speeding-up shortest  path and distance queries on large weighted undirected graphs.


%\sstab (1) We develop an approximation algorithm with a constant  factor $2$ to analyze distance landmarks by establishing connections with vertex covers (Section~\ref{sec-analysis}), based on which we show that the {\em direct} application of distance landmarks is not practical for large-scale graphs. We then propose {\em hybrid landmark covers}, a revised notion of traditional landmark covers, to reduce the space cost (Section~\ref{sec-analysis}).

\stab (1) We first propose a notion of {\em routing proxies} (or simply proxies), each of which represents a small subgraph, referred to as  {\em deterministic routing areas} (\dras)  (Section~\ref{sec-proxy}). We also give an analysis of routing proxies and \dras, and show that they hold good properties for speeding-up shortest path and distance queries.

\stab (2) We then develop a {\em linear-time} algorithm for computing \dras along with their maximal routing proxies (Section~\ref{sec-proxy-algorithms}). This makes our solution a light-weight technique that is scalable to large graphs.


\stab (3) Using real-life large road and co-authorship graphs, we finally conduct an extensive experimental study (Section~\ref{sec-expt}).
We find that (a) on average 1/3 nodes in a graph are captured by routing proxies, leaving the reduced graph about 2/3 of the input graph for both road and co-authorship graphs, and  (b) routing proxies benefit existing shortest  path and distance algorithms, \eg it reduces around 30\% and 20\% time for  bidirectional Dijkstra \cite{LubyR89} and \arcflag \cite{MohringSSWW05} on road graphs, respectively, and 49\%, 4\% and 49\% time for birirectional Dijkstra, \arcflag and \tnr \cite{arz2013transit} on co-authorship graphs, respectively.

%These make proxies and their \dras are a light-weight preprocessing technique for speeding-up shortest  path and distance queries.


%\sstab (3) We introduce the {\em bounded graph partitioning} problem (\gdp) to deal with the remaining subgraph that cannot be captured by the \dras of agents, and show that the problem is \NP-complete (Section~\ref{sec-decomposition}). We then propose a notion of {\em \super} graphs that combine graph partitions with hybrid landmark covers to support efficient shortest distance answering. We also build connections between the traditional graph partitioning problem and the \gdp problem, and utilize the traditional graph partitioning approaches, \eg\ \metis, to solve the problem. As shown by the experiments, \metis works well.


%\sstab (4) We propose a unified framework \disland for fast shortest distance query answering (Section~\ref{sec-query}), which seamlessly combines distance landmarks with agents, graphs partitions (\super graphs), and existing speed-up techniques~\cite{WuXDCZZ12,WagnerW07}.



